# compiler-2: baz

Experimental compiler for a minimalistic, specialized language that targets NASM
x86_64 assembly on Linux.

## Intention

* minimalistic language
* gain experience writing compilers
* generate handwritten-like assembler compiled by NASM for x86_64
* super loop program with non-reentrant inlined functions

## Supports

* built-in integer types (64, 32, 16, 8 bit)
* built-in boolean type
* user defined types
* inlined functions
* keywords: `func`, `field`, `var`, `loop`, `if`, `else`, `continue`, `break`, `return`

## Howto

* to compile the compiler that compiles `prog.baz` and assembles the generated
code run `./make.sh`
* after that use `./run-baz.sh myprogram.baz` or `./run-baz.sh` to compile and
run `prog.baz`
* to run the tests `qa/coverage/run-tests.sh` and see coverage report in `qa/coverage/report/`

## Source

```text
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
C/C++ Header                    35            792            550           4271
C++                              1             51             64            385
-------------------------------------------------------------------------------
SUM:                            36            843            614           4656
-------------------------------------------------------------------------------
```

## Sample

```text
field   hello = "hello world from baz\n"
field   input = "............................................................"
field prompt1 = "enter name:\n"
field prompt2 = "that is not a name.\n"
field prompt3 = "hello "
field     dot = "."
field      nl = "\n"
field counter = 0

# all functions are inlined

# arguments can be placed in specified register using `reg_...` syntax
func exit(v : reg_rdi) {
    mov(rax, 60)  # exit system call
    mov(rdi, v)   # return code
    syscall()
}

func assert(expr : bool) {
    if not expr exit(1)
}

func print(len : reg_rdx, ptr : reg_rsi) {
    mov(rax, 1)   # write system call
    mov(rdi, 1)   # file descriptor for standard out
    mov(rsi, ptr) # buffer address 
    mov(rdx, len) # buffer size
    syscall()
}

func read(len : reg_rdx, ptr : reg_rsi) : i64 nbytes {
    mov(rax, 0)   # read system call
    mov(rdi, 0)   # file descriptor for standard input
    mov(rsi, ptr) # buffer address
    mov(rdx, len) # buffer size
    syscall()
    mov(nbytes, rax) # return value
}

# user types are defined using keyword `type`

# default type is `i64` and does not need to be specified
type point {x, y}

type object {pos : point, color : i32}

# function arguments are equivalent to mutable references
func foo(pt : point) {
    pt.x = 0b10    # binary value 2
    pt.y = 0xb     # hex value 11
    assert(pt.x == 0b10)
}

# default argument type is `i64`
func bar(arg) {
    if arg == 0 return
    arg = 0xff
}

# return target is specified as a variable, in this case `res`
func baz(arg) : i64 res {
    res = arg * 2
}

func main() {
    var p : point = {0, 0}
    foo(p)
    assert(p.x == 2)
    assert(p.y == 0xb)

    var i = 0
    bar(i)
    assert(i == 0)

    i = 1
    bar(i)
    assert(i == 0xff)

    var j = 1
    var k = baz(j)
    assert(k == 2)

    k = baz(1)
    assert(k == 2)

    var p0 : point = {baz(2), 0}
    assert(p0.x == 4)

    var x = 1
    var y = 2

    var o1 : object = {{x * 10, y}, 0xff0000}
    assert(o1.pos.x == 10)
    assert(o1.pos.y == 2)
    assert(o1.color == 0xff0000)
    
    var p1 : point = {-x, -y}
    o1.pos = p1
    assert(o1.pos.x == -1)
    assert(o1.pos.y == -2)

    var o2 : object = o1
    assert(o2.pos.x == -1)
    assert(o2.pos.y == -2)
    assert(o2.color == 0xff0000)

    counter = counter + 1
    assert(counter == 1)

    print(hello.len, hello)
    loop {
        print(prompt1.len, prompt1)
        var len = read(input.len, input) - 1    # -1 don't include the '\n'
        if len == 0 {
            break
        } else if len <= 4 {
            print(prompt2.len, prompt2)
            continue
        } else {
            print(prompt3.len, prompt3)
            print(len, input)
            print(dot.len, dot)
            print(nl.len, nl)
        }
    }
}
```

## Generates

```nasm
; generated by baz

section .bss
stk resd 1024
stk.end:

true equ 1
false equ 0

section .data
;[1:1] field hello = "hello world from baz\n"
hello: db 'hello world from baz',10,''
hello.len equ $-hello
;[2:1] field input = "............................................................"
input: db '............................................................'
input.len equ $-input
;[3:1] field prompt1 = "enter name:\n"
prompt1: db 'enter name:',10,''
prompt1.len equ $-prompt1
;[4:1] field prompt2 = "that is not a name.\n"
prompt2: db 'that is not a name.',10,''
prompt2.len equ $-prompt2
;[5:1] field prompt3 = "hello "
prompt3: db 'hello '
prompt3.len equ $-prompt3
;[6:1] field dot = "."
dot: db '.'
dot.len equ $-dot
;[7:1] field nl = "\n"
nl: db '',10,''
nl.len equ $-nl
;[8:1] field counter = 0
counter: dq 0

section .text
bits 64
global _start
_start:
mov rsp,stk.end
; program
;[10:1] # all functions are inlined
;[12:1]  # arguments can be placed in specified register using `reg_...` syntax
;[40:1]  # user types are defined using keyword `type`
;[42:1]  # default type is `i64` and does not need to be specified
;[47:1]  # function arguments are equivalent to mutable references
;[54:1]  # default argument type is `i64`
;[60:1]  # return target is specified as a variable, in this case `res`
main:
;    var p: point @ qword[rsp-16]
;    [66:5]  var p : point = {0, 0}
;    [66:9] p : point = {0, 0}
;    [66:21]  {0, 0}
;    [66:21] {0, 0}
;    [66:22] 0
;    [66:22] 0
;    [66:22] p.x = 0
    mov qword[rsp-16], 0
;    [66:25]  0
;    [66:25] 0
;    [66:25] p.y = 0
    mov qword[rsp-8], 0
;    [67:5]  foo(p)
;    foo(pt : point) 
    foo_67_5:
;        alias pt -> p
;        [49:5]  pt.x = 0b10
;        [49:12]  0b10
;        [49:12] 0b10
;        [49:12] pt.x = 0b10
        mov qword[rsp-16], 0b10
;        [49:20] # binary value 2
;        [50:5]  pt.y = 0xb
;        [50:12]  0xb
;        [50:12] 0xb
;        [50:12] pt.y = 0xb
        mov qword[rsp-8], 0xb
;        [50:20] # hex value 11
;        [51:5]  assert(pt.x == 0b10)
;        alloc r15
;        [51:12] pt.x == 0b10
;        [51:12] ? pt.x == 0b10
;        [51:12] ? pt.x == 0b10
        cmp_51_12_67_5:
        cmp qword[rsp-16], 0b10
        jne bool_false_51_12_67_5
        bool_true_51_12_67_5:  ; opt1
        mov r15, true
        jmp bool_end_51_12_67_5
        bool_false_51_12_67_5:
        mov r15, false
        bool_end_51_12_67_5:
;        assert(expr : bool) 
        assert_51_5_67_5:
;            alias expr -> r15
            if_20_8_51_5_67_5:
;            [20:8] ? not expr
;            [20:8] ? not expr
            cmp_20_8_51_5_67_5:
            cmp r15, false
            jne if_20_5_51_5_67_5_end
            if_20_8_51_5_67_5_code:  ; opt1
;                [20:17] exit(1)
;                alloc rdi
                mov rdi, 1
;                exit(v : reg_rdi) 
                exit_20_17_51_5_67_5:
;                    alias v -> rdi
;                    [14:5]  mov(rax, 60)
                    mov rax, 60
;                    [14:19] # exit system call
;                    [15:5]  mov(rdi, v)
;                    [15:19] # return code
;                    [16:5]  syscall()
                    syscall
;                    free rdi
                exit_20_17_51_5_67_5_end:
            if_20_5_51_5_67_5_end:
;            free r15
        assert_51_5_67_5_end:
    foo_67_5_end:
;    [68:5] assert(p.x == 2)
;    alloc r15
;    [68:12] p.x == 2
;    [68:12] ? p.x == 2
;    [68:12] ? p.x == 2
    cmp_68_12:
    cmp qword[rsp-16], 2
    jne bool_false_68_12
    bool_true_68_12:  ; opt1
    mov r15, true
    jmp bool_end_68_12
    bool_false_68_12:
    mov r15, false
    bool_end_68_12:
;    assert(expr : bool) 
    assert_68_5:
;        alias expr -> r15
        if_20_8_68_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_68_5:
        cmp r15, false
        jne if_20_5_68_5_end
        if_20_8_68_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_68_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_68_5_end:
        if_20_5_68_5_end:
;        free r15
    assert_68_5_end:
;    [69:5] assert(p.y == 0xb)
;    alloc r15
;    [69:12] p.y == 0xb
;    [69:12] ? p.y == 0xb
;    [69:12] ? p.y == 0xb
    cmp_69_12:
    cmp qword[rsp-8], 0xb
    jne bool_false_69_12
    bool_true_69_12:  ; opt1
    mov r15, true
    jmp bool_end_69_12
    bool_false_69_12:
    mov r15, false
    bool_end_69_12:
;    assert(expr : bool) 
    assert_69_5:
;        alias expr -> r15
        if_20_8_69_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_69_5:
        cmp r15, false
        jne if_20_5_69_5_end
        if_20_8_69_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_69_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_69_5_end:
        if_20_5_69_5_end:
;        free r15
    assert_69_5_end:
;    var i: i64 @ qword[rsp-24]
;    [71:5] var i = 0
;    [71:9] i = 0
;    [71:13]  0
;    [71:13] 0
;    [71:13] i = 0
    mov qword[rsp-24], 0
;    [72:5] bar(i)
;    bar(arg) 
    bar_72_5:
;        alias arg -> i
        if_56_8_72_5:
;        [56:8] ? arg == 0
;        [56:8] ? arg == 0
        cmp_56_8_72_5:
        cmp qword[rsp-24], 0
        jne if_56_5_72_5_end
        if_56_8_72_5_code:  ; opt1
;            [56:17] return
            jmp bar_72_5_end
        if_56_5_72_5_end:
;        [57:5] arg = 0xff
;        [57:11]  0xff
;        [57:11] 0xff
;        [57:11] arg = 0xff
        mov qword[rsp-24], 0xff
    bar_72_5_end:
;    [73:5] assert(i == 0)
;    alloc r15
;    [73:12] i == 0
;    [73:12] ? i == 0
;    [73:12] ? i == 0
    cmp_73_12:
    cmp qword[rsp-24], 0
    jne bool_false_73_12
    bool_true_73_12:  ; opt1
    mov r15, true
    jmp bool_end_73_12
    bool_false_73_12:
    mov r15, false
    bool_end_73_12:
;    assert(expr : bool) 
    assert_73_5:
;        alias expr -> r15
        if_20_8_73_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_73_5:
        cmp r15, false
        jne if_20_5_73_5_end
        if_20_8_73_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_73_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_73_5_end:
        if_20_5_73_5_end:
;        free r15
    assert_73_5_end:
;    [75:5] i = 1
;    [75:9]  1
;    [75:9] 1
;    [75:9] i = 1
    mov qword[rsp-24], 1
;    [76:5] bar(i)
;    bar(arg) 
    bar_76_5:
;        alias arg -> i
        if_56_8_76_5:
;        [56:8] ? arg == 0
;        [56:8] ? arg == 0
        cmp_56_8_76_5:
        cmp qword[rsp-24], 0
        jne if_56_5_76_5_end
        if_56_8_76_5_code:  ; opt1
;            [56:17] return
            jmp bar_76_5_end
        if_56_5_76_5_end:
;        [57:5] arg = 0xff
;        [57:11]  0xff
;        [57:11] 0xff
;        [57:11] arg = 0xff
        mov qword[rsp-24], 0xff
    bar_76_5_end:
;    [77:5] assert(i == 0xff)
;    alloc r15
;    [77:12] i == 0xff
;    [77:12] ? i == 0xff
;    [77:12] ? i == 0xff
    cmp_77_12:
    cmp qword[rsp-24], 0xff
    jne bool_false_77_12
    bool_true_77_12:  ; opt1
    mov r15, true
    jmp bool_end_77_12
    bool_false_77_12:
    mov r15, false
    bool_end_77_12:
;    assert(expr : bool) 
    assert_77_5:
;        alias expr -> r15
        if_20_8_77_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_77_5:
        cmp r15, false
        jne if_20_5_77_5_end
        if_20_8_77_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_77_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_77_5_end:
        if_20_5_77_5_end:
;        free r15
    assert_77_5_end:
;    var j: i64 @ qword[rsp-32]
;    [79:5] var j = 1
;    [79:9] j = 1
;    [79:13]  1
;    [79:13] 1
;    [79:13] j = 1
    mov qword[rsp-32], 1
;    var k: i64 @ qword[rsp-40]
;    [80:5] var k = baz(j)
;    [80:9] k = baz(j)
;    [80:13]  baz(j)
;    [80:13] baz(j)
;    [80:13] k = baz(j)
;    [80:13] baz(j)
;    baz(arg) : i64 res 
    baz_80_13:
;        alias res -> k
;        alias arg -> j
;        [62:5]  res = arg * 2
;        [62:11]  arg * 2
;        [62:11] arg * 2
;        [62:11] res = arg
;        alloc r15
        mov r15, qword[rsp-32]
        mov qword[rsp-40], r15
;        free r15
;        [62:17] res * 2
;        alloc r15
        mov r15, qword[rsp-40]
        imul r15, 2
        mov qword[rsp-40], r15
;        free r15
    baz_80_13_end:
;    [81:5] assert(k == 2)
;    alloc r15
;    [81:12] k == 2
;    [81:12] ? k == 2
;    [81:12] ? k == 2
    cmp_81_12:
    cmp qword[rsp-40], 2
    jne bool_false_81_12
    bool_true_81_12:  ; opt1
    mov r15, true
    jmp bool_end_81_12
    bool_false_81_12:
    mov r15, false
    bool_end_81_12:
;    assert(expr : bool) 
    assert_81_5:
;        alias expr -> r15
        if_20_8_81_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_81_5:
        cmp r15, false
        jne if_20_5_81_5_end
        if_20_8_81_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_81_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_81_5_end:
        if_20_5_81_5_end:
;        free r15
    assert_81_5_end:
;    [83:5] k = baz(1)
;    [83:9]  baz(1)
;    [83:9] baz(1)
;    [83:9] k = baz(1)
;    [83:9] baz(1)
;    baz(arg) : i64 res 
    baz_83_9:
;        alias res -> k
;        alias arg -> 1
;        [62:5]  res = arg * 2
;        [62:11]  arg * 2
;        [62:11] arg * 2
;        [62:11] res = arg
        mov qword[rsp-40], 1
;        [62:17] res * 2
;        alloc r15
        mov r15, qword[rsp-40]
        imul r15, 2
        mov qword[rsp-40], r15
;        free r15
    baz_83_9_end:
;    [84:5] assert(k == 2)
;    alloc r15
;    [84:12] k == 2
;    [84:12] ? k == 2
;    [84:12] ? k == 2
    cmp_84_12:
    cmp qword[rsp-40], 2
    jne bool_false_84_12
    bool_true_84_12:  ; opt1
    mov r15, true
    jmp bool_end_84_12
    bool_false_84_12:
    mov r15, false
    bool_end_84_12:
;    assert(expr : bool) 
    assert_84_5:
;        alias expr -> r15
        if_20_8_84_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_84_5:
        cmp r15, false
        jne if_20_5_84_5_end
        if_20_8_84_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_84_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_84_5_end:
        if_20_5_84_5_end:
;        free r15
    assert_84_5_end:
;    var p0: point @ qword[rsp-56]
;    [86:5] var p0 : point = {baz(2), 0}
;    [86:9] p0 : point = {baz(2), 0}
;    [86:22]  {baz(2), 0}
;    [86:22] {baz(2), 0}
;    [86:23] baz(2)
;    [86:23] baz(2)
;    [86:23] p0.x = baz(2)
;    [86:23] baz(2)
;    baz(arg) : i64 res 
    baz_86_23:
;        alias res -> p0.x
;        alias arg -> 2
;        [62:5]  res = arg * 2
;        [62:11]  arg * 2
;        [62:11] arg * 2
;        [62:11] res = arg
        mov qword[rsp-56], 2
;        [62:17] res * 2
;        alloc r15
        mov r15, qword[rsp-56]
        imul r15, 2
        mov qword[rsp-56], r15
;        free r15
    baz_86_23_end:
;    [86:31]  0
;    [86:31] 0
;    [86:31] p0.y = 0
    mov qword[rsp-48], 0
;    [87:5]  assert(p0.x == 4)
;    alloc r15
;    [87:12] p0.x == 4
;    [87:12] ? p0.x == 4
;    [87:12] ? p0.x == 4
    cmp_87_12:
    cmp qword[rsp-56], 4
    jne bool_false_87_12
    bool_true_87_12:  ; opt1
    mov r15, true
    jmp bool_end_87_12
    bool_false_87_12:
    mov r15, false
    bool_end_87_12:
;    assert(expr : bool) 
    assert_87_5:
;        alias expr -> r15
        if_20_8_87_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_87_5:
        cmp r15, false
        jne if_20_5_87_5_end
        if_20_8_87_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_87_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_87_5_end:
        if_20_5_87_5_end:
;        free r15
    assert_87_5_end:
;    var x: i64 @ qword[rsp-64]
;    [89:5] var x = 1
;    [89:9] x = 1
;    [89:13]  1
;    [89:13] 1
;    [89:13] x = 1
    mov qword[rsp-64], 1
;    var y: i64 @ qword[rsp-72]
;    [90:5] var y = 2
;    [90:9] y = 2
;    [90:13]  2
;    [90:13] 2
;    [90:13] y = 2
    mov qword[rsp-72], 2
;    var o1: object @ qword[rsp-92]
;    [92:5] var o1 : object = {{x * 10, y}, 0xff0000}
;    [92:9] o1 : object = {{x * 10, y}, 0xff0000}
;    [92:23]  {{x * 10, y}, 0xff0000}
;    [92:23] {{x * 10, y}, 0xff0000}
;        [92:24] {x * 10, y}
;        [92:25] x * 10
;        [92:25] x * 10
;        [92:25] o1.pos.x = x
;        alloc r15
        mov r15, qword[rsp-64]
        mov qword[rsp-92], r15
;        free r15
;        [92:29] o1.pos.x * 10
;        alloc r15
        mov r15, qword[rsp-92]
        imul r15, 10
        mov qword[rsp-92], r15
;        free r15
;        [92:33]  y
;        [92:33] y
;        [92:33] o1.pos.y = y
;        alloc r15
        mov r15, qword[rsp-72]
        mov qword[rsp-84], r15
;        free r15
;    [92:37]  0xff0000
;    [92:37] 0xff0000
;    [92:37] o1.color = 0xff0000
    mov dword[rsp-76], 0xff0000
;    [93:5]  assert(o1.pos.x == 10)
;    alloc r15
;    [93:12] o1.pos.x == 10
;    [93:12] ? o1.pos.x == 10
;    [93:12] ? o1.pos.x == 10
    cmp_93_12:
    cmp qword[rsp-92], 10
    jne bool_false_93_12
    bool_true_93_12:  ; opt1
    mov r15, true
    jmp bool_end_93_12
    bool_false_93_12:
    mov r15, false
    bool_end_93_12:
;    assert(expr : bool) 
    assert_93_5:
;        alias expr -> r15
        if_20_8_93_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_93_5:
        cmp r15, false
        jne if_20_5_93_5_end
        if_20_8_93_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_93_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_93_5_end:
        if_20_5_93_5_end:
;        free r15
    assert_93_5_end:
;    [94:5] assert(o1.pos.y == 2)
;    alloc r15
;    [94:12] o1.pos.y == 2
;    [94:12] ? o1.pos.y == 2
;    [94:12] ? o1.pos.y == 2
    cmp_94_12:
    cmp qword[rsp-84], 2
    jne bool_false_94_12
    bool_true_94_12:  ; opt1
    mov r15, true
    jmp bool_end_94_12
    bool_false_94_12:
    mov r15, false
    bool_end_94_12:
;    assert(expr : bool) 
    assert_94_5:
;        alias expr -> r15
        if_20_8_94_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_94_5:
        cmp r15, false
        jne if_20_5_94_5_end
        if_20_8_94_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_94_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_94_5_end:
        if_20_5_94_5_end:
;        free r15
    assert_94_5_end:
;    [95:5] assert(o1.color == 0xff0000)
;    alloc r15
;    [95:12] o1.color == 0xff0000
;    [95:12] ? o1.color == 0xff0000
;    [95:12] ? o1.color == 0xff0000
    cmp_95_12:
    cmp dword[rsp-76], 0xff0000
    jne bool_false_95_12
    bool_true_95_12:  ; opt1
    mov r15, true
    jmp bool_end_95_12
    bool_false_95_12:
    mov r15, false
    bool_end_95_12:
;    assert(expr : bool) 
    assert_95_5:
;        alias expr -> r15
        if_20_8_95_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_95_5:
        cmp r15, false
        jne if_20_5_95_5_end
        if_20_8_95_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_95_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_95_5_end:
        if_20_5_95_5_end:
;        free r15
    assert_95_5_end:
;    var p1: point @ qword[rsp-108]
;    [97:5] var p1 : point = {-x, -y}
;    [97:9] p1 : point = {-x, -y}
;    [97:22]  {-x, -y}
;    [97:22] {-x, -y}
;    [97:23] -x
;    [97:23] -x
;    [97:24] p1.x = -x
;    alloc r15
    mov r15, qword[rsp-64]
    mov qword[rsp-108], r15
;    free r15
    neg qword[rsp-108]
;    [97:27]  -y
;    [97:27] -y
;    [97:28] p1.y = -y
;    alloc r15
    mov r15, qword[rsp-72]
    mov qword[rsp-100], r15
;    free r15
    neg qword[rsp-100]
;    [98:5]  o1.pos = p1
;    [98:14]  p1
;    [98:14] p1
;    alloc r15
    mov r15, qword[rsp-108]
    mov qword[rsp-92], r15
;    free r15
;    alloc r15
    mov r15, qword[rsp-100]
    mov qword[rsp-84], r15
;    free r15
;    [99:5] assert(o1.pos.x == -1)
;    alloc r15
;    [99:12] o1.pos.x == -1
;    [99:12] ? o1.pos.x == -1
;    [99:12] ? o1.pos.x == -1
    cmp_99_12:
    cmp qword[rsp-92], -1
    jne bool_false_99_12
    bool_true_99_12:  ; opt1
    mov r15, true
    jmp bool_end_99_12
    bool_false_99_12:
    mov r15, false
    bool_end_99_12:
;    assert(expr : bool) 
    assert_99_5:
;        alias expr -> r15
        if_20_8_99_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_99_5:
        cmp r15, false
        jne if_20_5_99_5_end
        if_20_8_99_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_99_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_99_5_end:
        if_20_5_99_5_end:
;        free r15
    assert_99_5_end:
;    [100:5] assert(o1.pos.y == -2)
;    alloc r15
;    [100:12] o1.pos.y == -2
;    [100:12] ? o1.pos.y == -2
;    [100:12] ? o1.pos.y == -2
    cmp_100_12:
    cmp qword[rsp-84], -2
    jne bool_false_100_12
    bool_true_100_12:  ; opt1
    mov r15, true
    jmp bool_end_100_12
    bool_false_100_12:
    mov r15, false
    bool_end_100_12:
;    assert(expr : bool) 
    assert_100_5:
;        alias expr -> r15
        if_20_8_100_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_100_5:
        cmp r15, false
        jne if_20_5_100_5_end
        if_20_8_100_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_100_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_100_5_end:
        if_20_5_100_5_end:
;        free r15
    assert_100_5_end:
;    var o2: object @ qword[rsp-128]
;    [102:5] var o2 : object = o1
;    [102:9] o2 : object = o1
;    [102:23]  o1
;    [102:23] o1
;        [102:23] o1
;        alloc r15
        mov r15, qword[rsp-92]
        mov qword[rsp-128], r15
;        free r15
;        alloc r15
        mov r15, qword[rsp-84]
        mov qword[rsp-120], r15
;        free r15
;    alloc r15
    mov r15d, dword[rsp-76]
    mov dword[rsp-112], r15d
;    free r15
;    [103:5] assert(o2.pos.x == -1)
;    alloc r15
;    [103:12] o2.pos.x == -1
;    [103:12] ? o2.pos.x == -1
;    [103:12] ? o2.pos.x == -1
    cmp_103_12:
    cmp qword[rsp-128], -1
    jne bool_false_103_12
    bool_true_103_12:  ; opt1
    mov r15, true
    jmp bool_end_103_12
    bool_false_103_12:
    mov r15, false
    bool_end_103_12:
;    assert(expr : bool) 
    assert_103_5:
;        alias expr -> r15
        if_20_8_103_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_103_5:
        cmp r15, false
        jne if_20_5_103_5_end
        if_20_8_103_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_103_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_103_5_end:
        if_20_5_103_5_end:
;        free r15
    assert_103_5_end:
;    [104:5] assert(o2.pos.y == -2)
;    alloc r15
;    [104:12] o2.pos.y == -2
;    [104:12] ? o2.pos.y == -2
;    [104:12] ? o2.pos.y == -2
    cmp_104_12:
    cmp qword[rsp-120], -2
    jne bool_false_104_12
    bool_true_104_12:  ; opt1
    mov r15, true
    jmp bool_end_104_12
    bool_false_104_12:
    mov r15, false
    bool_end_104_12:
;    assert(expr : bool) 
    assert_104_5:
;        alias expr -> r15
        if_20_8_104_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_104_5:
        cmp r15, false
        jne if_20_5_104_5_end
        if_20_8_104_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_104_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_104_5_end:
        if_20_5_104_5_end:
;        free r15
    assert_104_5_end:
;    [105:5] assert(o2.color == 0xff0000)
;    alloc r15
;    [105:12] o2.color == 0xff0000
;    [105:12] ? o2.color == 0xff0000
;    [105:12] ? o2.color == 0xff0000
    cmp_105_12:
    cmp dword[rsp-112], 0xff0000
    jne bool_false_105_12
    bool_true_105_12:  ; opt1
    mov r15, true
    jmp bool_end_105_12
    bool_false_105_12:
    mov r15, false
    bool_end_105_12:
;    assert(expr : bool) 
    assert_105_5:
;        alias expr -> r15
        if_20_8_105_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_105_5:
        cmp r15, false
        jne if_20_5_105_5_end
        if_20_8_105_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_105_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_105_5_end:
        if_20_5_105_5_end:
;        free r15
    assert_105_5_end:
;    [107:5] counter = counter + 1
;    [107:15]  counter + 1
;    [107:15] counter + 1
;    [107:15] counter = counter
;    [107:25] counter + 1
    add qword[counter], 1
;    [108:5] assert(counter == 1)
;    alloc r15
;    [108:12] counter == 1
;    [108:12] ? counter == 1
;    [108:12] ? counter == 1
    cmp_108_12:
    cmp qword[counter], 1
    jne bool_false_108_12
    bool_true_108_12:  ; opt1
    mov r15, true
    jmp bool_end_108_12
    bool_false_108_12:
    mov r15, false
    bool_end_108_12:
;    assert(expr : bool) 
    assert_108_5:
;        alias expr -> r15
        if_20_8_108_5:
;        [20:8] ? not expr
;        [20:8] ? not expr
        cmp_20_8_108_5:
        cmp r15, false
        jne if_20_5_108_5_end
        if_20_8_108_5_code:  ; opt1
;            [20:17] exit(1)
;            alloc rdi
            mov rdi, 1
;            exit(v : reg_rdi) 
            exit_20_17_108_5:
;                alias v -> rdi
;                [14:5]  mov(rax, 60)
                mov rax, 60
;                [14:19] # exit system call
;                [15:5]  mov(rdi, v)
;                [15:19] # return code
;                [16:5]  syscall()
                syscall
;                free rdi
            exit_20_17_108_5_end:
        if_20_5_108_5_end:
;        free r15
    assert_108_5_end:
;    [110:5] print(hello.len, hello)
;    alloc rdx
    mov rdx, hello.len
;    alloc rsi
    mov rsi, hello
;    print(len : reg_rdx, ptr : reg_rsi) 
    print_110_5:
;        alias len -> rdx
;        alias ptr -> rsi
;        [24:5]  mov(rax, 1)
        mov rax, 1
;        [24:19] # write system call
;        [25:5]  mov(rdi, 1)
        mov rdi, 1
;        [25:19] # file descriptor for standard out
;        [26:5]  mov(rsi, ptr)
;        [26:19] # buffer address
;        [27:5]  mov(rdx, len)
;        [27:19] # buffer size
;        [28:5]  syscall()
        syscall
;        free rsi
;        free rdx
    print_110_5_end:
;    [111:5] loop
    loop_111_5:
;        [112:9]  print(prompt1.len, prompt1)
;        alloc rdx
        mov rdx, prompt1.len
;        alloc rsi
        mov rsi, prompt1
;        print(len : reg_rdx, ptr : reg_rsi) 
        print_112_9:
;            alias len -> rdx
;            alias ptr -> rsi
;            [24:5]  mov(rax, 1)
            mov rax, 1
;            [24:19] # write system call
;            [25:5]  mov(rdi, 1)
            mov rdi, 1
;            [25:19] # file descriptor for standard out
;            [26:5]  mov(rsi, ptr)
;            [26:19] # buffer address
;            [27:5]  mov(rdx, len)
;            [27:19] # buffer size
;            [28:5]  syscall()
            syscall
;            free rsi
;            free rdx
        print_112_9_end:
;        var len: i64 @ qword[rsp-136]
;        [113:9] var len = read(input.len, input) - 1
;        [113:13] len = read(input.len, input) - 1
;        [113:19]  read(input.len, input) - 1
;        [113:19] read(input.len, input) - 1
;        [113:19] len = read(input.len, input)
;        [113:19] read(input.len, input)
;        alloc rdx
        mov rdx, input.len
;        alloc rsi
        mov rsi, input
;        read(len : reg_rdx, ptr : reg_rsi) : i64 nbytes 
        read_113_19:
;            alias nbytes -> len
;            alias len -> rdx
;            alias ptr -> rsi
;            [32:5]  mov(rax, 0)
            mov rax, 0
;            [32:19] # read system call
;            [33:5]  mov(rdi, 0)
            mov rdi, 0
;            [33:19] # file descriptor for standard input
;            [34:5]  mov(rsi, ptr)
;            [34:19] # buffer address
;            [35:5]  mov(rdx, len)
;            [35:19] # buffer size
;            [36:5]  syscall()
            syscall
;            [37:5] mov(nbytes, rax)
            mov qword[rsp-136], rax
;            [37:22] # return value
;            free rsi
;            free rdx
        read_113_19_end:
;        [113:44] len - 1
        sub qword[rsp-136], 1
;        [113:49] # -1 don't include the '\n'
        if_114_12:
;        [114:12] ? len == 0
;        [114:12] ? len == 0
        cmp_114_12:
        cmp qword[rsp-136], 0
        jne if_116_19
        if_114_12_code:  ; opt1
;            [115:13]  break
            jmp loop_111_5_end
        jmp if_114_9_end
        if_116_19:
;        [116:19] ? len <= 4
;        [116:19] ? len <= 4
        cmp_116_19:
        cmp qword[rsp-136], 4
        jg if_else_114_9
        if_116_19_code:  ; opt1
;            [117:13]  print(prompt2.len, prompt2)
;            alloc rdx
            mov rdx, prompt2.len
;            alloc rsi
            mov rsi, prompt2
;            print(len : reg_rdx, ptr : reg_rsi) 
            print_117_13:
;                alias len -> rdx
;                alias ptr -> rsi
;                [24:5]  mov(rax, 1)
                mov rax, 1
;                [24:19] # write system call
;                [25:5]  mov(rdi, 1)
                mov rdi, 1
;                [25:19] # file descriptor for standard out
;                [26:5]  mov(rsi, ptr)
;                [26:19] # buffer address
;                [27:5]  mov(rdx, len)
;                [27:19] # buffer size
;                [28:5]  syscall()
                syscall
;                free rsi
;                free rdx
            print_117_13_end:
;            [118:13] continue
            jmp loop_111_5
        jmp if_114_9_end
        if_else_114_9:
;            [120:13]  print(prompt3.len, prompt3)
;            alloc rdx
            mov rdx, prompt3.len
;            alloc rsi
            mov rsi, prompt3
;            print(len : reg_rdx, ptr : reg_rsi) 
            print_120_13:
;                alias len -> rdx
;                alias ptr -> rsi
;                [24:5]  mov(rax, 1)
                mov rax, 1
;                [24:19] # write system call
;                [25:5]  mov(rdi, 1)
                mov rdi, 1
;                [25:19] # file descriptor for standard out
;                [26:5]  mov(rsi, ptr)
;                [26:19] # buffer address
;                [27:5]  mov(rdx, len)
;                [27:19] # buffer size
;                [28:5]  syscall()
                syscall
;                free rsi
;                free rdx
            print_120_13_end:
;            [121:13] print(len, input)
;            alloc rdx
            mov rdx, qword[rsp-136]
;            alloc rsi
            mov rsi, input
;            print(len : reg_rdx, ptr : reg_rsi) 
            print_121_13:
;                alias len -> rdx
;                alias ptr -> rsi
;                [24:5]  mov(rax, 1)
                mov rax, 1
;                [24:19] # write system call
;                [25:5]  mov(rdi, 1)
                mov rdi, 1
;                [25:19] # file descriptor for standard out
;                [26:5]  mov(rsi, ptr)
;                [26:19] # buffer address
;                [27:5]  mov(rdx, len)
;                [27:19] # buffer size
;                [28:5]  syscall()
                syscall
;                free rsi
;                free rdx
            print_121_13_end:
;            [122:13] print(dot.len, dot)
;            alloc rdx
            mov rdx, dot.len
;            alloc rsi
            mov rsi, dot
;            print(len : reg_rdx, ptr : reg_rsi) 
            print_122_13:
;                alias len -> rdx
;                alias ptr -> rsi
;                [24:5]  mov(rax, 1)
                mov rax, 1
;                [24:19] # write system call
;                [25:5]  mov(rdi, 1)
                mov rdi, 1
;                [25:19] # file descriptor for standard out
;                [26:5]  mov(rsi, ptr)
;                [26:19] # buffer address
;                [27:5]  mov(rdx, len)
;                [27:19] # buffer size
;                [28:5]  syscall()
                syscall
;                free rsi
;                free rdx
            print_122_13_end:
;            [123:13] print(nl.len, nl)
;            alloc rdx
            mov rdx, nl.len
;            alloc rsi
            mov rsi, nl
;            print(len : reg_rdx, ptr : reg_rsi) 
            print_123_13:
;                alias len -> rdx
;                alias ptr -> rsi
;                [24:5]  mov(rax, 1)
                mov rax, 1
;                [24:19] # write system call
;                [25:5]  mov(rdi, 1)
                mov rdi, 1
;                [25:19] # file descriptor for standard out
;                [26:5]  mov(rsi, ptr)
;                [26:19] # buffer address
;                [27:5]  mov(rdx, len)
;                [27:19] # buffer size
;                [28:5]  syscall()
                syscall
;                free rsi
;                free rdx
            print_123_13_end:
        if_114_9_end:
    jmp loop_111_5
    loop_111_5_end:
    ; system call: exit 0
    mov rax, 60
    mov rdi, 0
    syscall

; max scratch registers in use: 3
;            max frames in use: 9
;               max stack size: 136 B
```

