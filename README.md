# compiler-2: baz

Experimental compiler for a minimalistic, specialized language that targets NASM
x86_64 assembly on Linux.

## Intention

* minimalistic language
* gain experience writing compilers
* generate handwritten-like assembler compiled by NASM for x86_64
* super loop program with non-reentrant inlined functions

## Supports

* built-in integer types (64, 32, 16, 8 bit)
* built-in boolean type
* user defined types
* inlined functions
* keywords: `func`, `field`, `var`, `loop`, `if`, `else`, `continue`, `break`, `return`

## Howto

* to compile the compiler that compiles `prog.baz` and assembles the generated
code run `./make.sh`
* after that use `./run-baz.sh myprogram.baz` or `./run-baz.sh` to compile and
run `prog.baz`
* to run the tests `qa/coverage/run-tests.sh` and see coverage report in `qa/coverage/report/`

## Source

```text
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
C/C++ Header                    35            783            509           4274
C++                              1             51             64            385
-------------------------------------------------------------------------------
SUM:                            36            834            573           4659
-------------------------------------------------------------------------------
```

## Sample

```text
field   hello = "hello world from baz\n"
field   input = "............................................................"
field prompt1 = "enter name:\n"
field prompt2 = "that is not a name.\n"
field prompt3 = "hello "
field     dot = "."
field      nl = "\n"
field counter = 0

# all functions are inlined

# arguments can be placed in specified register using `reg_...` syntax
func exit(v : reg_rdi) {
    mov(rax, 60)  # exit system call
    mov(rdi, v)   # return code
    syscall()
}

func assert(expr : bool) {
    if not expr exit(1)
}

func print(len : reg_rdx, ptr : reg_rsi) {
    mov(rax, 1)   # write system call
    mov(rdi, 1)   # file descriptor for standard out
    mov(rsi, ptr) # buffer address 
    mov(rdx, len) # buffer size
    syscall()
}

func read(len : reg_rdx, ptr : reg_rsi) : i64 nbytes {
    mov(rax, 0)   # read system call
    mov(rdi, 0)   # file descriptor for standard input
    mov(rsi, ptr) # buffer address
    mov(rdx, len) # buffer size
    syscall()
    mov(nbytes, rax) # return value
}

# user types are defined using keyword `type`

# default type is `i64` and does not need to be specified
type point {x, y}

type object {pos : point, color : i32}

# function arguments are equivalent to mutable references
func foo(pt : point) {
    pt.x = 0b10    # binary value 2
    pt.y = 0xb     # hex value 11
}

# default argument type is `i64`
func bar(arg) {
    if arg == 0 return
    arg = 0xff
}

# return target is specified as a variable, in this case `res`
func baz(arg) : i64 res {
    res = arg * 2
}

func main() {
    var p : point = {0, 0}
    foo(p)
    assert(p.x == 2)
    assert(p.y == 0xb)

    var i = 0
    bar(i)
    assert(i == 0)

    i = 1
    bar(i)
    assert(i == 0xff)

    var j = 1
    var k = baz(j)
    assert(k == 2)

    k = baz(1)
    assert(k == 2)

    var p0 : point = {baz(2), 0}
    assert(p0.x == 4)

    var x = 1
    var y = 2

    var o1 : object = {{x * 10, y}, 0xff0000}
    assert(o1.pos.x == 10)
    assert(o1.pos.y == 2)
    assert(o1.color == 0xff0000)
    
    var p1 : point = {-x, -y}
    o1.pos = p1
    assert(o1.pos.x == -1)
    assert(o1.pos.y == -2)

    var o2 : object = o1
    assert(o2.pos.x == -1)
    assert(o2.pos.y == -2)
    assert(o2.color == 0xff0000)

    counter = counter + 1
    assert(counter == 1)

    print(hello.len, hello)
    loop {
        print(prompt1.len, prompt1)
        var len = read(input.len, input) - 1    # -1 don't include the '\n'
        if len == 0 {
            break
        } else if len <= 4 {
            print(prompt2.len, prompt2)
            continue
        } else {
            print(prompt3.len, prompt3)
            print(len, input)
            print(dot.len, dot)
            print(nl.len, nl)
        }
    }
}
```

## Generates

```text
; generated by baz

section .bss
stk resd 1024
stk.end:

true equ 1
false equ 0

section .data
;[1:1] field hello = "hello world from baz\n"
hello: db 'hello world from baz',10,''
hello.len equ $-hello
;[2:1] field input = "............................................................"
input: db '............................................................'
input.len equ $-input
;[3:1] field prompt1 = "enter name:\n"
prompt1: db 'enter name:',10,''
prompt1.len equ $-prompt1
;[4:1] field prompt2 = "that is not a name.\n"
prompt2: db 'that is not a name.',10,''
prompt2.len equ $-prompt2
;[5:1] field prompt3 = "hello "
prompt3: db 'hello '
prompt3.len equ $-prompt3
;[6:1] field dot = "."
dot: db '.'
dot.len equ $-dot
;[7:1] field nl = "\n"
nl: db '',10,''
nl.len equ $-nl
;[8:1] field counter = 0
counter: dq 0

section .text
bits 64
global _start
_start:
mov rsp,stk.end
; program
;[10:1] # all functions are inlined
;[12:1]  # arguments can be placed in specified register using `reg_...` syntax
;[40:1]  # user types are defined using keyword `type`
;[42:1]  # default type is `i64` and does not need to be specified
;[47:1]  # function arguments are equivalent to mutable references
;[53:1]  # default argument type is `i64`
;[59:1]  # return target is specified as a variable, in this case `res`
;  p: qword[rsp-16]
;  [65:5]  var p : point = {0, 0}
;  [65:9] p : point = {0, 0}
;  [65:21]  {0, 0}
;    [65:21] {0, 0}
;    [65:22] 0
;    [65:22] 0
;    [65:22] p.x = 0
     mov qword[rsp-16], 0
;    [65:25]  0
;    [65:25] 0
;    [65:25] p.y = 0
     mov qword[rsp-8], 0
;  [66:5]  foo(p)
;  foo(pt : point) 
;    inline: 66_5
;    alias pt -> p
;    [49:5]  pt.x = 0b10
;    [49:12]  0b10
;    [49:12] 0b10
;    [49:12] pt.x = 0b10
     mov qword[rsp-16], 0b10
;    [49:20] # binary value 2
;    [50:5]  pt.y = 0xb
;    [50:12]  0xb
;    [50:12] 0xb
;    [50:12] pt.y = 0xb
     mov qword[rsp-8], 0xb
;    [50:20] # hex value 11
   foo_66_5_end:
;  [67:5] assert(p.x == 2)
;  assert(expr : bool) 
;    inline: 67_5
;    alloc r15
;    [67:12] p.x == 2
;    [67:12] ? p.x == 2
;    [67:12] ? p.x == 2
     cmp_67_12:
     cmp qword[rsp-16], 2
     jne bool_false_67_12
     bool_true_67_12:  ; opt1
     mov r15, true
     jmp bool_end_67_12
     bool_false_67_12:
     mov r15, false
     bool_end_67_12:
;    alias expr -> r15
     if_20_8_67_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_67_5:
     cmp r15, 0
     jne if_20_5_67_5_end
     if_20_8_67_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_67_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_67_5_end:
     if_20_5_67_5_end:
;    free r15
   assert_67_5_end:
;  [68:5] assert(p.y == 0xb)
;  assert(expr : bool) 
;    inline: 68_5
;    alloc r15
;    [68:12] p.y == 0xb
;    [68:12] ? p.y == 0xb
;    [68:12] ? p.y == 0xb
     cmp_68_12:
     cmp qword[rsp-8], 0xb
     jne bool_false_68_12
     bool_true_68_12:  ; opt1
     mov r15, true
     jmp bool_end_68_12
     bool_false_68_12:
     mov r15, false
     bool_end_68_12:
;    alias expr -> r15
     if_20_8_68_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_68_5:
     cmp r15, 0
     jne if_20_5_68_5_end
     if_20_8_68_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_68_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_68_5_end:
     if_20_5_68_5_end:
;    free r15
   assert_68_5_end:
;  i: qword[rsp-24]
;  [70:5] var i = 0
;  [70:9] i = 0
;  [70:13]  0
;  [70:13] 0
;  [70:13] i = 0
   mov qword[rsp-24], 0
;  [71:5] bar(i)
;  bar(arg) 
;    inline: 71_5
;    alias arg -> i
     if_55_8_71_5:
;    [55:8] ? arg == 0
;    [55:8] ? arg == 0
     cmp_55_8_71_5:
     cmp qword[rsp-24], 0
     jne if_55_5_71_5_end
     if_55_8_71_5_code:  ; opt1
;      [55:17] return
       jmp bar_71_5_end
     if_55_5_71_5_end:
;    [56:5] arg = 0xff
;    [56:11]  0xff
;    [56:11] 0xff
;    [56:11] arg = 0xff
     mov qword[rsp-24], 0xff
   bar_71_5_end:
;  [72:5] assert(i == 0)
;  assert(expr : bool) 
;    inline: 72_5
;    alloc r15
;    [72:12] i == 0
;    [72:12] ? i == 0
;    [72:12] ? i == 0
     cmp_72_12:
     cmp qword[rsp-24], 0
     jne bool_false_72_12
     bool_true_72_12:  ; opt1
     mov r15, true
     jmp bool_end_72_12
     bool_false_72_12:
     mov r15, false
     bool_end_72_12:
;    alias expr -> r15
     if_20_8_72_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_72_5:
     cmp r15, 0
     jne if_20_5_72_5_end
     if_20_8_72_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_72_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_72_5_end:
     if_20_5_72_5_end:
;    free r15
   assert_72_5_end:
;  [74:5] i = 1
;  [74:9]  1
;  [74:9] 1
;  [74:9] i = 1
   mov qword[rsp-24], 1
;  [75:5] bar(i)
;  bar(arg) 
;    inline: 75_5
;    alias arg -> i
     if_55_8_75_5:
;    [55:8] ? arg == 0
;    [55:8] ? arg == 0
     cmp_55_8_75_5:
     cmp qword[rsp-24], 0
     jne if_55_5_75_5_end
     if_55_8_75_5_code:  ; opt1
;      [55:17] return
       jmp bar_75_5_end
     if_55_5_75_5_end:
;    [56:5] arg = 0xff
;    [56:11]  0xff
;    [56:11] 0xff
;    [56:11] arg = 0xff
     mov qword[rsp-24], 0xff
   bar_75_5_end:
;  [76:5] assert(i == 0xff)
;  assert(expr : bool) 
;    inline: 76_5
;    alloc r15
;    [76:12] i == 0xff
;    [76:12] ? i == 0xff
;    [76:12] ? i == 0xff
     cmp_76_12:
     cmp qword[rsp-24], 0xff
     jne bool_false_76_12
     bool_true_76_12:  ; opt1
     mov r15, true
     jmp bool_end_76_12
     bool_false_76_12:
     mov r15, false
     bool_end_76_12:
;    alias expr -> r15
     if_20_8_76_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_76_5:
     cmp r15, 0
     jne if_20_5_76_5_end
     if_20_8_76_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_76_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_76_5_end:
     if_20_5_76_5_end:
;    free r15
   assert_76_5_end:
;  j: qword[rsp-32]
;  [78:5] var j = 1
;  [78:9] j = 1
;  [78:13]  1
;  [78:13] 1
;  [78:13] j = 1
   mov qword[rsp-32], 1
;  k: qword[rsp-40]
;  [79:5] var k = baz(j)
;  [79:9] k = baz(j)
;  [79:13]  baz(j)
;  [79:13] baz(j)
;  [79:13] k = baz(j)
;  [79:13] baz(j)
;  baz(arg) : i64 res 
;    inline: 79_13
;    alias res -> k
;    alias arg -> j
;    [61:5]  res = arg * 2
;    [61:11]  arg * 2
;    [61:11] arg * 2
;    [61:11] res = arg
;    alloc r15
     mov r15, qword[rsp-32]
     mov qword[rsp-40], r15
;    free r15
;    [61:17] res * 2
;    alloc r15
     mov r15, qword[rsp-40]
     imul r15, 2
     mov qword[rsp-40], r15
;    free r15
   baz_79_13_end:
;  [80:5] assert(k == 2)
;  assert(expr : bool) 
;    inline: 80_5
;    alloc r15
;    [80:12] k == 2
;    [80:12] ? k == 2
;    [80:12] ? k == 2
     cmp_80_12:
     cmp qword[rsp-40], 2
     jne bool_false_80_12
     bool_true_80_12:  ; opt1
     mov r15, true
     jmp bool_end_80_12
     bool_false_80_12:
     mov r15, false
     bool_end_80_12:
;    alias expr -> r15
     if_20_8_80_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_80_5:
     cmp r15, 0
     jne if_20_5_80_5_end
     if_20_8_80_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_80_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_80_5_end:
     if_20_5_80_5_end:
;    free r15
   assert_80_5_end:
;  [82:5] k = baz(1)
;  [82:9]  baz(1)
;  [82:9] baz(1)
;  [82:9] k = baz(1)
;  [82:9] baz(1)
;  baz(arg) : i64 res 
;    inline: 82_9
;    alias res -> k
;    alias arg -> 1
;    [61:5]  res = arg * 2
;    [61:11]  arg * 2
;    [61:11] arg * 2
;    [61:11] res = arg
     mov qword[rsp-40], 1
;    [61:17] res * 2
;    alloc r15
     mov r15, qword[rsp-40]
     imul r15, 2
     mov qword[rsp-40], r15
;    free r15
   baz_82_9_end:
;  [83:5] assert(k == 2)
;  assert(expr : bool) 
;    inline: 83_5
;    alloc r15
;    [83:12] k == 2
;    [83:12] ? k == 2
;    [83:12] ? k == 2
     cmp_83_12:
     cmp qword[rsp-40], 2
     jne bool_false_83_12
     bool_true_83_12:  ; opt1
     mov r15, true
     jmp bool_end_83_12
     bool_false_83_12:
     mov r15, false
     bool_end_83_12:
;    alias expr -> r15
     if_20_8_83_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_83_5:
     cmp r15, 0
     jne if_20_5_83_5_end
     if_20_8_83_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_83_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_83_5_end:
     if_20_5_83_5_end:
;    free r15
   assert_83_5_end:
;  p0: qword[rsp-56]
;  [85:5] var p0 : point = {baz(2), 0}
;  [85:9] p0 : point = {baz(2), 0}
;  [85:22]  {baz(2), 0}
;    [85:22] {baz(2), 0}
;    [85:23] baz(2)
;    [85:23] baz(2)
;    [85:23] p0.x = baz(2)
;    [85:23] baz(2)
;    baz(arg) : i64 res 
;      inline: 85_23
;      alias res -> p0.x
;      alias arg -> 2
;      [61:5]  res = arg * 2
;      [61:11]  arg * 2
;      [61:11] arg * 2
;      [61:11] res = arg
       mov qword[rsp-56], 2
;      [61:17] res * 2
;      alloc r15
       mov r15, qword[rsp-56]
       imul r15, 2
       mov qword[rsp-56], r15
;      free r15
     baz_85_23_end:
;    [85:31]  0
;    [85:31] 0
;    [85:31] p0.y = 0
     mov qword[rsp-48], 0
;  [86:5]  assert(p0.x == 4)
;  assert(expr : bool) 
;    inline: 86_5
;    alloc r15
;    [86:12] p0.x == 4
;    [86:12] ? p0.x == 4
;    [86:12] ? p0.x == 4
     cmp_86_12:
     cmp qword[rsp-56], 4
     jne bool_false_86_12
     bool_true_86_12:  ; opt1
     mov r15, true
     jmp bool_end_86_12
     bool_false_86_12:
     mov r15, false
     bool_end_86_12:
;    alias expr -> r15
     if_20_8_86_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_86_5:
     cmp r15, 0
     jne if_20_5_86_5_end
     if_20_8_86_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_86_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_86_5_end:
     if_20_5_86_5_end:
;    free r15
   assert_86_5_end:
;  x: qword[rsp-64]
;  [88:5] var x = 1
;  [88:9] x = 1
;  [88:13]  1
;  [88:13] 1
;  [88:13] x = 1
   mov qword[rsp-64], 1
;  y: qword[rsp-72]
;  [89:5] var y = 2
;  [89:9] y = 2
;  [89:13]  2
;  [89:13] 2
;  [89:13] y = 2
   mov qword[rsp-72], 2
;  o1: qword[rsp-92]
;  [91:5] var o1 : object = {{x * 10, y}, 0xff0000}
;  [91:9] o1 : object = {{x * 10, y}, 0xff0000}
;  [91:23]  {{x * 10, y}, 0xff0000}
;    [91:23] {{x * 10, y}, 0xff0000}
;      [91:24] {x * 10, y}
;      [91:25] x * 10
;      [91:25] x * 10
;      [91:25] o1.pos.x = x
;      alloc r15
       mov r15, qword[rsp-64]
       mov qword[rsp-92], r15
;      free r15
;      [91:29] o1.pos.x * 10
;      alloc r15
       mov r15, qword[rsp-92]
       imul r15, 10
       mov qword[rsp-92], r15
;      free r15
;      [91:33]  y
;      [91:33] y
;      [91:33] o1.pos.y = y
;      alloc r15
       mov r15, qword[rsp-72]
       mov qword[rsp-84], r15
;      free r15
;    [91:37]  0xff0000
;    [91:37] 0xff0000
;    [91:37] o1.color = 0xff0000
     mov dword[rsp-76], 0xff0000
;  [92:5]  assert(o1.pos.x == 10)
;  assert(expr : bool) 
;    inline: 92_5
;    alloc r15
;    [92:12] o1.pos.x == 10
;    [92:12] ? o1.pos.x == 10
;    [92:12] ? o1.pos.x == 10
     cmp_92_12:
     cmp qword[rsp-92], 10
     jne bool_false_92_12
     bool_true_92_12:  ; opt1
     mov r15, true
     jmp bool_end_92_12
     bool_false_92_12:
     mov r15, false
     bool_end_92_12:
;    alias expr -> r15
     if_20_8_92_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_92_5:
     cmp r15, 0
     jne if_20_5_92_5_end
     if_20_8_92_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_92_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_92_5_end:
     if_20_5_92_5_end:
;    free r15
   assert_92_5_end:
;  [93:5] assert(o1.pos.y == 2)
;  assert(expr : bool) 
;    inline: 93_5
;    alloc r15
;    [93:12] o1.pos.y == 2
;    [93:12] ? o1.pos.y == 2
;    [93:12] ? o1.pos.y == 2
     cmp_93_12:
     cmp qword[rsp-84], 2
     jne bool_false_93_12
     bool_true_93_12:  ; opt1
     mov r15, true
     jmp bool_end_93_12
     bool_false_93_12:
     mov r15, false
     bool_end_93_12:
;    alias expr -> r15
     if_20_8_93_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_93_5:
     cmp r15, 0
     jne if_20_5_93_5_end
     if_20_8_93_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_93_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_93_5_end:
     if_20_5_93_5_end:
;    free r15
   assert_93_5_end:
;  [94:5] assert(o1.color == 0xff0000)
;  assert(expr : bool) 
;    inline: 94_5
;    alloc r15
;    [94:12] o1.color == 0xff0000
;    [94:12] ? o1.color == 0xff0000
;    [94:12] ? o1.color == 0xff0000
     cmp_94_12:
     cmp dword[rsp-76], 0xff0000
     jne bool_false_94_12
     bool_true_94_12:  ; opt1
     mov r15, true
     jmp bool_end_94_12
     bool_false_94_12:
     mov r15, false
     bool_end_94_12:
;    alias expr -> r15
     if_20_8_94_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_94_5:
     cmp r15, 0
     jne if_20_5_94_5_end
     if_20_8_94_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_94_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_94_5_end:
     if_20_5_94_5_end:
;    free r15
   assert_94_5_end:
;  p1: qword[rsp-108]
;  [96:5] var p1 : point = {-x, -y}
;  [96:9] p1 : point = {-x, -y}
;  [96:22]  {-x, -y}
;    [96:22] {-x, -y}
;    [96:23] -x
;    [96:23] -x
;    [96:24] p1.x = -x
;    alloc r15
     mov r15, qword[rsp-64]
     mov qword[rsp-108], r15
;    free r15
     neg qword[rsp-108]
;    [96:27]  -y
;    [96:27] -y
;    [96:28] p1.y = -y
;    alloc r15
     mov r15, qword[rsp-72]
     mov qword[rsp-100], r15
;    free r15
     neg qword[rsp-100]
;  [97:5]  o1.pos = p1
;  [97:14]  p1
;    [97:14] p1
;    alloc r15
     mov r15, qword[rsp-108]
     mov qword[rsp-92], r15
;    free r15
;    alloc r15
     mov r15, qword[rsp-100]
     mov qword[rsp-84], r15
;    free r15
;  [98:5] assert(o1.pos.x == -1)
;  assert(expr : bool) 
;    inline: 98_5
;    alloc r15
;    [98:12] o1.pos.x == -1
;    [98:12] ? o1.pos.x == -1
;    [98:12] ? o1.pos.x == -1
     cmp_98_12:
     cmp qword[rsp-92], -1
     jne bool_false_98_12
     bool_true_98_12:  ; opt1
     mov r15, true
     jmp bool_end_98_12
     bool_false_98_12:
     mov r15, false
     bool_end_98_12:
;    alias expr -> r15
     if_20_8_98_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_98_5:
     cmp r15, 0
     jne if_20_5_98_5_end
     if_20_8_98_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_98_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_98_5_end:
     if_20_5_98_5_end:
;    free r15
   assert_98_5_end:
;  [99:5] assert(o1.pos.y == -2)
;  assert(expr : bool) 
;    inline: 99_5
;    alloc r15
;    [99:12] o1.pos.y == -2
;    [99:12] ? o1.pos.y == -2
;    [99:12] ? o1.pos.y == -2
     cmp_99_12:
     cmp qword[rsp-84], -2
     jne bool_false_99_12
     bool_true_99_12:  ; opt1
     mov r15, true
     jmp bool_end_99_12
     bool_false_99_12:
     mov r15, false
     bool_end_99_12:
;    alias expr -> r15
     if_20_8_99_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_99_5:
     cmp r15, 0
     jne if_20_5_99_5_end
     if_20_8_99_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_99_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_99_5_end:
     if_20_5_99_5_end:
;    free r15
   assert_99_5_end:
;  o2: qword[rsp-128]
;  [101:5] var o2 : object = o1
;  [101:9] o2 : object = o1
;  [101:23]  o1
;    [101:23] o1
;      [101:23] o1
;      alloc r15
       mov r15, qword[rsp-92]
       mov qword[rsp-128], r15
;      free r15
;      alloc r15
       mov r15, qword[rsp-84]
       mov qword[rsp-120], r15
;      free r15
;    alloc r15
     mov r15d, dword[rsp-76]
     mov dword[rsp-112], r15d
;    free r15
;  [102:5] assert(o2.pos.x == -1)
;  assert(expr : bool) 
;    inline: 102_5
;    alloc r15
;    [102:12] o2.pos.x == -1
;    [102:12] ? o2.pos.x == -1
;    [102:12] ? o2.pos.x == -1
     cmp_102_12:
     cmp qword[rsp-128], -1
     jne bool_false_102_12
     bool_true_102_12:  ; opt1
     mov r15, true
     jmp bool_end_102_12
     bool_false_102_12:
     mov r15, false
     bool_end_102_12:
;    alias expr -> r15
     if_20_8_102_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_102_5:
     cmp r15, 0
     jne if_20_5_102_5_end
     if_20_8_102_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_102_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_102_5_end:
     if_20_5_102_5_end:
;    free r15
   assert_102_5_end:
;  [103:5] assert(o2.pos.y == -2)
;  assert(expr : bool) 
;    inline: 103_5
;    alloc r15
;    [103:12] o2.pos.y == -2
;    [103:12] ? o2.pos.y == -2
;    [103:12] ? o2.pos.y == -2
     cmp_103_12:
     cmp qword[rsp-120], -2
     jne bool_false_103_12
     bool_true_103_12:  ; opt1
     mov r15, true
     jmp bool_end_103_12
     bool_false_103_12:
     mov r15, false
     bool_end_103_12:
;    alias expr -> r15
     if_20_8_103_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_103_5:
     cmp r15, 0
     jne if_20_5_103_5_end
     if_20_8_103_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_103_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_103_5_end:
     if_20_5_103_5_end:
;    free r15
   assert_103_5_end:
;  [104:5] assert(o2.color == 0xff0000)
;  assert(expr : bool) 
;    inline: 104_5
;    alloc r15
;    [104:12] o2.color == 0xff0000
;    [104:12] ? o2.color == 0xff0000
;    [104:12] ? o2.color == 0xff0000
     cmp_104_12:
     cmp dword[rsp-112], 0xff0000
     jne bool_false_104_12
     bool_true_104_12:  ; opt1
     mov r15, true
     jmp bool_end_104_12
     bool_false_104_12:
     mov r15, false
     bool_end_104_12:
;    alias expr -> r15
     if_20_8_104_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_104_5:
     cmp r15, 0
     jne if_20_5_104_5_end
     if_20_8_104_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_104_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_104_5_end:
     if_20_5_104_5_end:
;    free r15
   assert_104_5_end:
;  [106:5] counter = counter + 1
;  [106:15]  counter + 1
;  [106:15] counter + 1
;  [106:15] counter = counter
;  [106:25] counter + 1
   add qword[counter], 1
;  [107:5] assert(counter == 1)
;  assert(expr : bool) 
;    inline: 107_5
;    alloc r15
;    [107:12] counter == 1
;    [107:12] ? counter == 1
;    [107:12] ? counter == 1
     cmp_107_12:
     cmp qword[counter], 1
     jne bool_false_107_12
     bool_true_107_12:  ; opt1
     mov r15, true
     jmp bool_end_107_12
     bool_false_107_12:
     mov r15, false
     bool_end_107_12:
;    alias expr -> r15
     if_20_8_107_5:
;    [20:8] ? not expr
;    [20:8] ? not expr
     cmp_20_8_107_5:
     cmp r15, 0
     jne if_20_5_107_5_end
     if_20_8_107_5_code:  ; opt1
;      [20:17] exit(1)
;      exit(v : reg_rdi) 
;        inline: 20_17_107_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [14:5]  mov(rax, 60)
         mov rax, 60
;        [14:19] # exit system call
;        [15:5]  mov(rdi, v)
;        [15:19] # return code
;        [16:5]  syscall()
         syscall
;        free rdi
       exit_20_17_107_5_end:
     if_20_5_107_5_end:
;    free r15
   assert_107_5_end:
;  [109:5] print(hello.len, hello)
;  print(len : reg_rdx, ptr : reg_rsi) 
;    inline: 109_5
;    alloc rdx
;    alias len -> rdx
     mov rdx, hello.len
;    alloc rsi
;    alias ptr -> rsi
     mov rsi, hello
;    [24:5]  mov(rax, 1)
     mov rax, 1
;    [24:19] # write system call
;    [25:5]  mov(rdi, 1)
     mov rdi, 1
;    [25:19] # file descriptor for standard out
;    [26:5]  mov(rsi, ptr)
;    [26:19] # buffer address
;    [27:5]  mov(rdx, len)
;    [27:19] # buffer size
;    [28:5]  syscall()
     syscall
;    free rsi
;    free rdx
   print_109_5_end:
;  [110:5] loop
   loop_110_5:
;    [111:9]  print(prompt1.len, prompt1)
;    print(len : reg_rdx, ptr : reg_rsi) 
;      inline: 111_9
;      alloc rdx
;      alias len -> rdx
       mov rdx, prompt1.len
;      alloc rsi
;      alias ptr -> rsi
       mov rsi, prompt1
;      [24:5]  mov(rax, 1)
       mov rax, 1
;      [24:19] # write system call
;      [25:5]  mov(rdi, 1)
       mov rdi, 1
;      [25:19] # file descriptor for standard out
;      [26:5]  mov(rsi, ptr)
;      [26:19] # buffer address
;      [27:5]  mov(rdx, len)
;      [27:19] # buffer size
;      [28:5]  syscall()
       syscall
;      free rsi
;      free rdx
     print_111_9_end:
;    len: qword[rsp-136]
;    [112:9] var len = read(input.len, input) - 1
;    [112:13] len = read(input.len, input) - 1
;    [112:19]  read(input.len, input) - 1
;    [112:19] read(input.len, input) - 1
;    [112:19] len = read(input.len, input)
;    [112:19] read(input.len, input)
;    read(len : reg_rdx, ptr : reg_rsi) : i64 nbytes 
;      inline: 112_19
;      alias nbytes -> len
;      alloc rdx
;      alias len -> rdx
       mov rdx, input.len
;      alloc rsi
;      alias ptr -> rsi
       mov rsi, input
;      [32:5]  mov(rax, 0)
       mov rax, 0
;      [32:19] # read system call
;      [33:5]  mov(rdi, 0)
       mov rdi, 0
;      [33:19] # file descriptor for standard input
;      [34:5]  mov(rsi, ptr)
;      [34:19] # buffer address
;      [35:5]  mov(rdx, len)
;      [35:19] # buffer size
;      [36:5]  syscall()
       syscall
;      [37:5] mov(nbytes, rax)
       mov qword[rsp-136], rax
;      [37:22] # return value
;      free rsi
;      free rdx
     read_112_19_end:
;    [112:44] len - 1
     sub qword[rsp-136], 1
;    [112:49] # -1 don't include the '\n'
     if_113_12:
;    [113:12] ? len == 0
;    [113:12] ? len == 0
     cmp_113_12:
     cmp qword[rsp-136], 0
     jne if_115_19
     if_113_12_code:  ; opt1
;      [114:13]  break
       jmp loop_110_5_end
     jmp if_113_9_end
     if_115_19:
;    [115:19] ? len <= 4
;    [115:19] ? len <= 4
     cmp_115_19:
     cmp qword[rsp-136], 4
     jg if_else_113_9
     if_115_19_code:  ; opt1
;      [116:13]  print(prompt2.len, prompt2)
;      print(len : reg_rdx, ptr : reg_rsi) 
;        inline: 116_13
;        alloc rdx
;        alias len -> rdx
         mov rdx, prompt2.len
;        alloc rsi
;        alias ptr -> rsi
         mov rsi, prompt2
;        [24:5]  mov(rax, 1)
         mov rax, 1
;        [24:19] # write system call
;        [25:5]  mov(rdi, 1)
         mov rdi, 1
;        [25:19] # file descriptor for standard out
;        [26:5]  mov(rsi, ptr)
;        [26:19] # buffer address
;        [27:5]  mov(rdx, len)
;        [27:19] # buffer size
;        [28:5]  syscall()
         syscall
;        free rsi
;        free rdx
       print_116_13_end:
;      [117:13] continue
       jmp loop_110_5
     jmp if_113_9_end
     if_else_113_9:
;        [119:13]  print(prompt3.len, prompt3)
;        print(len : reg_rdx, ptr : reg_rsi) 
;          inline: 119_13
;          alloc rdx
;          alias len -> rdx
           mov rdx, prompt3.len
;          alloc rsi
;          alias ptr -> rsi
           mov rsi, prompt3
;          [24:5]  mov(rax, 1)
           mov rax, 1
;          [24:19] # write system call
;          [25:5]  mov(rdi, 1)
           mov rdi, 1
;          [25:19] # file descriptor for standard out
;          [26:5]  mov(rsi, ptr)
;          [26:19] # buffer address
;          [27:5]  mov(rdx, len)
;          [27:19] # buffer size
;          [28:5]  syscall()
           syscall
;          free rsi
;          free rdx
         print_119_13_end:
;        [120:13] print(len, input)
;        print(len : reg_rdx, ptr : reg_rsi) 
;          inline: 120_13
;          alloc rdx
;          alias len -> rdx
           mov rdx, qword[rsp-136]
;          alloc rsi
;          alias ptr -> rsi
           mov rsi, input
;          [24:5]  mov(rax, 1)
           mov rax, 1
;          [24:19] # write system call
;          [25:5]  mov(rdi, 1)
           mov rdi, 1
;          [25:19] # file descriptor for standard out
;          [26:5]  mov(rsi, ptr)
;          [26:19] # buffer address
;          [27:5]  mov(rdx, len)
;          [27:19] # buffer size
;          [28:5]  syscall()
           syscall
;          free rsi
;          free rdx
         print_120_13_end:
;        [121:13] print(dot.len, dot)
;        print(len : reg_rdx, ptr : reg_rsi) 
;          inline: 121_13
;          alloc rdx
;          alias len -> rdx
           mov rdx, dot.len
;          alloc rsi
;          alias ptr -> rsi
           mov rsi, dot
;          [24:5]  mov(rax, 1)
           mov rax, 1
;          [24:19] # write system call
;          [25:5]  mov(rdi, 1)
           mov rdi, 1
;          [25:19] # file descriptor for standard out
;          [26:5]  mov(rsi, ptr)
;          [26:19] # buffer address
;          [27:5]  mov(rdx, len)
;          [27:19] # buffer size
;          [28:5]  syscall()
           syscall
;          free rsi
;          free rdx
         print_121_13_end:
;        [122:13] print(nl.len, nl)
;        print(len : reg_rdx, ptr : reg_rsi) 
;          inline: 122_13
;          alloc rdx
;          alias len -> rdx
           mov rdx, nl.len
;          alloc rsi
;          alias ptr -> rsi
           mov rsi, nl
;          [24:5]  mov(rax, 1)
           mov rax, 1
;          [24:19] # write system call
;          [25:5]  mov(rdi, 1)
           mov rdi, 1
;          [25:19] # file descriptor for standard out
;          [26:5]  mov(rsi, ptr)
;          [26:19] # buffer address
;          [27:5]  mov(rdx, len)
;          [27:19] # buffer size
;          [28:5]  syscall()
           syscall
;          free rsi
;          free rdx
         print_122_13_end:
     if_113_9_end:
   jmp loop_110_5
   loop_110_5_end:
; system call: exit 0
mov rax, 60
mov rdi, 0
syscall

; max scratch registers in use: 3
;            max frames in use: 7
;               max stack size: 136 B
```

