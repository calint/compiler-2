# compiler-2: baz

Experimental compiler for a minimalistic, specialized language that targets NASM
x86_64 assembly on Linux.

## Intention

* minimalistic language
* gain experience writing compilers
* generate handwritten-like assembler compiled by NASM for x86_64
* super loop program with non-reentrant inlined functions

## Supports

* built-in integer types (64, 32, 16, 8 bit)
* built-in boolean type
* user defined types
* inlined functions
* keywords: `func`, `field`, `var`, `loop`, `if`, `else`, `continue`, `break`, `return`

## Howto

* to compile the compiler that compiles `prog.baz` and assembles the generated
code run `./make.sh`
* after that use `./run-baz.sh myprogram.baz` or `./run-baz.sh` to compile and
run `prog.baz`
* to run the tests `qa/coverage/run-tests.sh` and see coverage report in `qa/coverage/report/`

## Sample

```text
field   hello = "hello world from baz\n"
field   input = "............................................................"
field prompt1 = "enter name:\n"
field prompt2 = "that is not a name.\n"
field prompt3 = "hello "
field     dot = "."
field      nl = "\n"

# all functions are inlined

# arguments can be placed in specified register using `reg_...` syntax 
func exit(v : reg_rdi) {
    mov(rax, 60)  # exit system call
    mov(rdi, v)   # return code
    syscall()
}

func print(len : reg_rdx, ptr : reg_rsi) {
    mov(rax, 1)   # write system call
    mov(rdi, 1)   # file descriptor for standard out
    mov(rsi, ptr) # buffer address 
    mov(rdx, len) # buffer size
    syscall()
}

func read(len : reg_rdx, ptr : reg_rsi) : i64 nbytes {
    mov(rax, 0)   # read system call
    mov(rdi, 0)   # file descriptor for standard input
    mov(rsi, ptr) # buffer address
    mov(rdx, len) # buffer size
    syscall()
    mov(nbytes, rax) # return value
}

func assert(expr : bool) {
    if not expr exit(1)
}

# user types are defined using keyword `type`

# default type is `i64` and does not need to be specified
type point {x, y}

type object {pos : point, color : i32}

# function arguments are equivalent to mutable references
func foo(p : point) {
    p.x = 0b10    # binary value 2
    p.y = 0xb     # hex value 11
}

# default argument type is `i64`
func bar(arg) {
    if arg == 0 return
    arg = 0xff
}

# return target is specified as a variable, in this case `res`
func baz(arg) : i64 res {
    res = arg * 2
}

func main() {
    var p : point = {0, 0}
    foo(p)
    assert(p.x == 2)
    assert(p.y == 0xb)

    var i = 0
    bar(i)
    assert(i == 0)

    i = 1
    bar(i)
    assert(i == 0xff)

    var j = 1
    var k = baz(j)
    assert(k == 2)

    var x = 1
    var y = 2

    var o1 : object = {{x * 10, y}, 0xff0000}
    assert(o1.pos.x == 10)
    assert(o1.pos.y == 2)
    assert(o1.color == 0xff0000)

    var p1 : point = {-x, -y}
    o1.pos = p1
    assert(o1.pos.x == -1)
    assert(o1.pos.y == -2)

    var o2 : object = o1
    assert(o2.pos.x == -1)
    assert(o2.pos.y == -2)
    assert(o2.color == 0xff0000)

    print(hello.len, hello)
    loop {
        print(prompt1.len, prompt1)
        var len = read(input.len, input) - 1    # -1 don't include the '\n'
        if len == 0 {
            break
        } else if len <= 4 {
            print(prompt2.len, prompt2)
            continue
        } else {
            print(prompt3.len, prompt3)
            print(len, input)
            print(dot.len, dot)
            print(nl.len, nl)
        }
    }
}
```

## Generates

```text
; generated by baz

true equ 1
false equ 0

section .data
align 4
;[1:1] field hello = "hello world from baz\n" 
hello: db 'hello world from baz',10,''
hello.len equ $-hello
;[2:1] field input = "............................................................" 
input: db '............................................................'
input.len equ $-input
;[3:1] field prompt1 = "enter name:\n" 
prompt1: db 'enter name:',10,''
prompt1.len equ $-prompt1
;[4:1] field prompt2 = "that is not a name.\n" 
prompt2: db 'that is not a name.',10,''
prompt2.len equ $-prompt2
;[5:1] field prompt3 = "hello " 
prompt3: db 'hello '
prompt3.len equ $-prompt3
;[6:1] field dot = "." 
dot: db '.'
dot.len equ $-dot
;[7:1] field nl = "\n" 
nl: db '',10,''
nl.len equ $-nl

section .bss
align 4
stk resd 1024
stk.end:

section .text
align 4
bits 64
global _start
_start:
mov rsp,stk.end
mov rbp,rsp
jmp main

;[9:1] # all functions are inlined 
;[11:1] # arguments can be placed in specified register using `reg_...` syntax 
;[39:1] # user types are defined using keyword `type` 
;[41:1] # default type is `i64` and does not need to be specified 
;[46:1] # function arguments are equivalent to mutable references 
;[52:1] # default argument type is `i64` 
;[58:1] # return target is specified as a variable, in this case `res` 
main:
;  p: qword[rbp-16]
;  [64:5] var p : point = {0, 0}
;  [64:9] p : point = {0, 0}
;  [64:21] {0, 0}
;    [64:21] {0, 0}
;    [64:22] 0
;    [64:22] 0
;    [64:22] p.x = 0
     mov qword[rbp-16], 0
;    [64:25] 0
;    [64:25] 0
;    [64:25] p.y = 0
     mov qword[rbp-8], 0
;  [65:5] foo(p) 
;  foo(p : point) 
;    inline: 65_5
;    alias p -> p
;    [48:5] p.x = 0b10 
;    [48:11] 0b10 
;    [48:11] 0b10 
;    [48:11] p.x = 0b10 
     mov qword[rbp-16], 0b10
;    [48:19] # binary value 2 
;    [49:5] p.y = 0xb 
;    [49:11] 0xb 
;    [49:11] 0xb 
;    [49:11] p.y = 0xb 
     mov qword[rbp-8], 0xb
;    [49:19] # hex value 11 
   foo_65_5_end:
;  [66:5] assert(p.x == 2) 
;  assert(expr : bool) 
;    inline: 66_5
;    alloc r15
;    [66:12] p.x == 2
;    [66:12] ? p.x == 2
;    [66:12] ? p.x == 2
     cmp_66_12:
     cmp qword[rbp-16], 2
     jne bool_false_66_12
     bool_true_66_12:  ; opt1
     mov r15, true
     jmp bool_end_66_12
     bool_false_66_12:
     mov r15, false
     bool_end_66_12:
;    alias expr -> r15
     if_36_8_66_5:
;    [36:8] ? not expr 
;    [36:8] ? not expr 
     cmp_36_8_66_5:
     cmp r15, 0
     jne if_36_5_66_5_end
     if_36_8_66_5_code:  ; opt1
;      [36:17] exit(1) 
;      exit(v : reg_rdi) 
;        inline: 36_17_66_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [13:5] mov(rax, 60) 
         mov rax, 60
;        [13:19] # exit system call 
;        [14:5] mov(rdi, v) 
;        [14:19] # return code 
;        [15:5] syscall() 
         syscall
;        free rdi
       exit_36_17_66_5_end:
     if_36_5_66_5_end:
;    free r15
   assert_66_5_end:
;  [67:5] assert(p.y == 0xb) 
;  assert(expr : bool) 
;    inline: 67_5
;    alloc r15
;    [67:12] p.y == 0xb
;    [67:12] ? p.y == 0xb
;    [67:12] ? p.y == 0xb
     cmp_67_12:
     cmp qword[rbp-8], 0xb
     jne bool_false_67_12
     bool_true_67_12:  ; opt1
     mov r15, true
     jmp bool_end_67_12
     bool_false_67_12:
     mov r15, false
     bool_end_67_12:
;    alias expr -> r15
     if_36_8_67_5:
;    [36:8] ? not expr 
;    [36:8] ? not expr 
     cmp_36_8_67_5:
     cmp r15, 0
     jne if_36_5_67_5_end
     if_36_8_67_5_code:  ; opt1
;      [36:17] exit(1) 
;      exit(v : reg_rdi) 
;        inline: 36_17_67_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [13:5] mov(rax, 60) 
         mov rax, 60
;        [13:19] # exit system call 
;        [14:5] mov(rdi, v) 
;        [14:19] # return code 
;        [15:5] syscall() 
         syscall
;        free rdi
       exit_36_17_67_5_end:
     if_36_5_67_5_end:
;    free r15
   assert_67_5_end:
;  i: qword[rbp-24]
;  [69:5] var i = 0 
;  [69:9] i = 0 
;  [69:13] 0 
;  [69:13] 0 
;  [69:13] i = 0 
   mov qword[rbp-24], 0
;  [70:5] bar(i) 
;  bar(arg) 
;    inline: 70_5
;    alias arg -> i
     if_54_8_70_5:
;    [54:8] ? arg == 0 
;    [54:8] ? arg == 0 
     cmp_54_8_70_5:
     cmp qword[rbp-24], 0
     jne if_54_5_70_5_end
     if_54_8_70_5_code:  ; opt1
;      [54:17] return 
       jmp bar_70_5_end
     if_54_5_70_5_end:
;    [55:5] arg = 0xff 
;    [55:11] 0xff 
;    [55:11] 0xff 
;    [55:11] arg = 0xff 
     mov qword[rbp-24], 0xff
   bar_70_5_end:
;  [71:5] assert(i == 0) 
;  assert(expr : bool) 
;    inline: 71_5
;    alloc r15
;    [71:12] i == 0
;    [71:12] ? i == 0
;    [71:12] ? i == 0
     cmp_71_12:
     cmp qword[rbp-24], 0
     jne bool_false_71_12
     bool_true_71_12:  ; opt1
     mov r15, true
     jmp bool_end_71_12
     bool_false_71_12:
     mov r15, false
     bool_end_71_12:
;    alias expr -> r15
     if_36_8_71_5:
;    [36:8] ? not expr 
;    [36:8] ? not expr 
     cmp_36_8_71_5:
     cmp r15, 0
     jne if_36_5_71_5_end
     if_36_8_71_5_code:  ; opt1
;      [36:17] exit(1) 
;      exit(v : reg_rdi) 
;        inline: 36_17_71_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [13:5] mov(rax, 60) 
         mov rax, 60
;        [13:19] # exit system call 
;        [14:5] mov(rdi, v) 
;        [14:19] # return code 
;        [15:5] syscall() 
         syscall
;        free rdi
       exit_36_17_71_5_end:
     if_36_5_71_5_end:
;    free r15
   assert_71_5_end:
;  [73:5] i = 1 
;  [73:9] 1 
;  [73:9] 1 
;  [73:9] i = 1 
   mov qword[rbp-24], 1
;  [74:5] bar(i) 
;  bar(arg) 
;    inline: 74_5
;    alias arg -> i
     if_54_8_74_5:
;    [54:8] ? arg == 0 
;    [54:8] ? arg == 0 
     cmp_54_8_74_5:
     cmp qword[rbp-24], 0
     jne if_54_5_74_5_end
     if_54_8_74_5_code:  ; opt1
;      [54:17] return 
       jmp bar_74_5_end
     if_54_5_74_5_end:
;    [55:5] arg = 0xff 
;    [55:11] 0xff 
;    [55:11] 0xff 
;    [55:11] arg = 0xff 
     mov qword[rbp-24], 0xff
   bar_74_5_end:
;  [75:5] assert(i == 0xff) 
;  assert(expr : bool) 
;    inline: 75_5
;    alloc r15
;    [75:12] i == 0xff
;    [75:12] ? i == 0xff
;    [75:12] ? i == 0xff
     cmp_75_12:
     cmp qword[rbp-24], 0xff
     jne bool_false_75_12
     bool_true_75_12:  ; opt1
     mov r15, true
     jmp bool_end_75_12
     bool_false_75_12:
     mov r15, false
     bool_end_75_12:
;    alias expr -> r15
     if_36_8_75_5:
;    [36:8] ? not expr 
;    [36:8] ? not expr 
     cmp_36_8_75_5:
     cmp r15, 0
     jne if_36_5_75_5_end
     if_36_8_75_5_code:  ; opt1
;      [36:17] exit(1) 
;      exit(v : reg_rdi) 
;        inline: 36_17_75_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [13:5] mov(rax, 60) 
         mov rax, 60
;        [13:19] # exit system call 
;        [14:5] mov(rdi, v) 
;        [14:19] # return code 
;        [15:5] syscall() 
         syscall
;        free rdi
       exit_36_17_75_5_end:
     if_36_5_75_5_end:
;    free r15
   assert_75_5_end:
;  j: qword[rbp-32]
;  [77:5] var j = 1 
;  [77:9] j = 1 
;  [77:13] 1 
;  [77:13] 1 
;  [77:13] j = 1 
   mov qword[rbp-32], 1
;  k: qword[rbp-40]
;  [78:5] var k = baz(j) 
;  [78:9] k = baz(j) 
;  [78:13] baz(j) 
;  [78:13] baz(j) 
;  [78:13] k = baz(j) 
;  [78:13] baz(j) 
;  baz(arg) : i64 res 
;    inline: 78_13
;    alias res -> k
;    alias arg -> j
;    [60:5] res = arg * 2 
;    [60:11] arg * 2 
;    alloc r15
;    [60:11] arg * 2 
;    [60:11] r15 = arg 
     mov r15, qword[rbp-32]
;    [60:17] r15 * 2 
     imul r15, 2
     mov qword[rbp-40], r15
;    free r15
   baz_78_13_end:
;  [79:5] assert(k == 2) 
;  assert(expr : bool) 
;    inline: 79_5
;    alloc r15
;    [79:12] k == 2
;    [79:12] ? k == 2
;    [79:12] ? k == 2
     cmp_79_12:
     cmp qword[rbp-40], 2
     jne bool_false_79_12
     bool_true_79_12:  ; opt1
     mov r15, true
     jmp bool_end_79_12
     bool_false_79_12:
     mov r15, false
     bool_end_79_12:
;    alias expr -> r15
     if_36_8_79_5:
;    [36:8] ? not expr 
;    [36:8] ? not expr 
     cmp_36_8_79_5:
     cmp r15, 0
     jne if_36_5_79_5_end
     if_36_8_79_5_code:  ; opt1
;      [36:17] exit(1) 
;      exit(v : reg_rdi) 
;        inline: 36_17_79_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [13:5] mov(rax, 60) 
         mov rax, 60
;        [13:19] # exit system call 
;        [14:5] mov(rdi, v) 
;        [14:19] # return code 
;        [15:5] syscall() 
         syscall
;        free rdi
       exit_36_17_79_5_end:
     if_36_5_79_5_end:
;    free r15
   assert_79_5_end:
;  x: qword[rbp-48]
;  [81:5] var x = 1 
;  [81:9] x = 1 
;  [81:13] 1 
;  [81:13] 1 
;  [81:13] x = 1 
   mov qword[rbp-48], 1
;  y: qword[rbp-56]
;  [82:5] var y = 2 
;  [82:9] y = 2 
;  [82:13] 2 
;  [82:13] 2 
;  [82:13] y = 2 
   mov qword[rbp-56], 2
;  o1: qword[rbp-76]
;  [84:5] var o1 : object = {{x * 10, y}, 0xff0000}
;  [84:9] o1 : object = {{x * 10, y}, 0xff0000}
;  [84:23] {{x * 10, y}, 0xff0000}
;    [84:23] {{x * 10, y}, 0xff0000}
;      [84:24] {x * 10, y}
;      [84:25] x * 10
;      alloc r15
;      [84:25] x * 10
;      [84:25] r15 = x 
       mov r15, qword[rbp-48]
;      [84:29] r15 * 10
       imul r15, 10
       mov qword[rbp-76], r15
;      free r15
;      [84:33] y
;      [84:33] y
;      [84:33] o1.pos.y = y
;      alloc r15
       mov r15, qword[rbp-56]
       mov qword[rbp-68], r15
;      free r15
;    [84:37] 0xff0000
;    [84:37] 0xff0000
;    [84:37] o1.color = 0xff0000
     mov dword[rbp-60], 0xff0000
;  [85:5] assert(o1.pos.x == 10) 
;  assert(expr : bool) 
;    inline: 85_5
;    alloc r15
;    [85:12] o1.pos.x == 10
;    [85:12] ? o1.pos.x == 10
;    [85:12] ? o1.pos.x == 10
     cmp_85_12:
     cmp qword[rbp-76], 10
     jne bool_false_85_12
     bool_true_85_12:  ; opt1
     mov r15, true
     jmp bool_end_85_12
     bool_false_85_12:
     mov r15, false
     bool_end_85_12:
;    alias expr -> r15
     if_36_8_85_5:
;    [36:8] ? not expr 
;    [36:8] ? not expr 
     cmp_36_8_85_5:
     cmp r15, 0
     jne if_36_5_85_5_end
     if_36_8_85_5_code:  ; opt1
;      [36:17] exit(1) 
;      exit(v : reg_rdi) 
;        inline: 36_17_85_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [13:5] mov(rax, 60) 
         mov rax, 60
;        [13:19] # exit system call 
;        [14:5] mov(rdi, v) 
;        [14:19] # return code 
;        [15:5] syscall() 
         syscall
;        free rdi
       exit_36_17_85_5_end:
     if_36_5_85_5_end:
;    free r15
   assert_85_5_end:
;  [86:5] assert(o1.pos.y == 2) 
;  assert(expr : bool) 
;    inline: 86_5
;    alloc r15
;    [86:12] o1.pos.y == 2
;    [86:12] ? o1.pos.y == 2
;    [86:12] ? o1.pos.y == 2
     cmp_86_12:
     cmp qword[rbp-68], 2
     jne bool_false_86_12
     bool_true_86_12:  ; opt1
     mov r15, true
     jmp bool_end_86_12
     bool_false_86_12:
     mov r15, false
     bool_end_86_12:
;    alias expr -> r15
     if_36_8_86_5:
;    [36:8] ? not expr 
;    [36:8] ? not expr 
     cmp_36_8_86_5:
     cmp r15, 0
     jne if_36_5_86_5_end
     if_36_8_86_5_code:  ; opt1
;      [36:17] exit(1) 
;      exit(v : reg_rdi) 
;        inline: 36_17_86_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [13:5] mov(rax, 60) 
         mov rax, 60
;        [13:19] # exit system call 
;        [14:5] mov(rdi, v) 
;        [14:19] # return code 
;        [15:5] syscall() 
         syscall
;        free rdi
       exit_36_17_86_5_end:
     if_36_5_86_5_end:
;    free r15
   assert_86_5_end:
;  [87:5] assert(o1.color == 0xff0000) 
;  assert(expr : bool) 
;    inline: 87_5
;    alloc r15
;    [87:12] o1.color == 0xff0000
;    [87:12] ? o1.color == 0xff0000
;    [87:12] ? o1.color == 0xff0000
     cmp_87_12:
     cmp dword[rbp-60], 0xff0000
     jne bool_false_87_12
     bool_true_87_12:  ; opt1
     mov r15, true
     jmp bool_end_87_12
     bool_false_87_12:
     mov r15, false
     bool_end_87_12:
;    alias expr -> r15
     if_36_8_87_5:
;    [36:8] ? not expr 
;    [36:8] ? not expr 
     cmp_36_8_87_5:
     cmp r15, 0
     jne if_36_5_87_5_end
     if_36_8_87_5_code:  ; opt1
;      [36:17] exit(1) 
;      exit(v : reg_rdi) 
;        inline: 36_17_87_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [13:5] mov(rax, 60) 
         mov rax, 60
;        [13:19] # exit system call 
;        [14:5] mov(rdi, v) 
;        [14:19] # return code 
;        [15:5] syscall() 
         syscall
;        free rdi
       exit_36_17_87_5_end:
     if_36_5_87_5_end:
;    free r15
   assert_87_5_end:
;  p1: qword[rbp-92]
;  [89:5] var p1 : point = {-x, -y}
;  [89:9] p1 : point = {-x, -y}
;  [89:22] {-x, -y}
;    [89:22] {-x, -y}
;    [89:23] -x
;    [89:23] -x
;    [89:24] p1.x = -x
;    alloc r15
     mov r15, qword[rbp-48]
     mov qword[rbp-92], r15
;    free r15
     neg qword[rbp-92]
;    [89:27] -y
;    [89:27] -y
;    [89:28] p1.y = -y
;    alloc r15
     mov r15, qword[rbp-56]
     mov qword[rbp-84], r15
;    free r15
     neg qword[rbp-84]
;  [90:5] o1.pos = p1 
;  [90:14] p1 
;    [90:14] p1 
;    alloc r15
     mov r15, qword[rbp-92]
     mov qword[rbp-76], r15
;    free r15
;    alloc r15
     mov r15, qword[rbp-84]
     mov qword[rbp-68], r15
;    free r15
;  [91:5] assert(o1.pos.x == -1) 
;  assert(expr : bool) 
;    inline: 91_5
;    alloc r15
;    [91:12] o1.pos.x == -1
;    [91:12] ? o1.pos.x == -1
;    [91:12] ? o1.pos.x == -1
     cmp_91_12:
     cmp qword[rbp-76], -1
     jne bool_false_91_12
     bool_true_91_12:  ; opt1
     mov r15, true
     jmp bool_end_91_12
     bool_false_91_12:
     mov r15, false
     bool_end_91_12:
;    alias expr -> r15
     if_36_8_91_5:
;    [36:8] ? not expr 
;    [36:8] ? not expr 
     cmp_36_8_91_5:
     cmp r15, 0
     jne if_36_5_91_5_end
     if_36_8_91_5_code:  ; opt1
;      [36:17] exit(1) 
;      exit(v : reg_rdi) 
;        inline: 36_17_91_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [13:5] mov(rax, 60) 
         mov rax, 60
;        [13:19] # exit system call 
;        [14:5] mov(rdi, v) 
;        [14:19] # return code 
;        [15:5] syscall() 
         syscall
;        free rdi
       exit_36_17_91_5_end:
     if_36_5_91_5_end:
;    free r15
   assert_91_5_end:
;  [92:5] assert(o1.pos.y == -2) 
;  assert(expr : bool) 
;    inline: 92_5
;    alloc r15
;    [92:12] o1.pos.y == -2
;    [92:12] ? o1.pos.y == -2
;    [92:12] ? o1.pos.y == -2
     cmp_92_12:
     cmp qword[rbp-68], -2
     jne bool_false_92_12
     bool_true_92_12:  ; opt1
     mov r15, true
     jmp bool_end_92_12
     bool_false_92_12:
     mov r15, false
     bool_end_92_12:
;    alias expr -> r15
     if_36_8_92_5:
;    [36:8] ? not expr 
;    [36:8] ? not expr 
     cmp_36_8_92_5:
     cmp r15, 0
     jne if_36_5_92_5_end
     if_36_8_92_5_code:  ; opt1
;      [36:17] exit(1) 
;      exit(v : reg_rdi) 
;        inline: 36_17_92_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [13:5] mov(rax, 60) 
         mov rax, 60
;        [13:19] # exit system call 
;        [14:5] mov(rdi, v) 
;        [14:19] # return code 
;        [15:5] syscall() 
         syscall
;        free rdi
       exit_36_17_92_5_end:
     if_36_5_92_5_end:
;    free r15
   assert_92_5_end:
;  o2: qword[rbp-112]
;  [94:5] var o2 : object = o1 
;  [94:9] o2 : object = o1 
;  [94:23] o1 
;    [94:23] o1 
;      [94:23] o1 
;      alloc r15
       mov r15, qword[rbp-76]
       mov qword[rbp-112], r15
;      free r15
;      alloc r15
       mov r15, qword[rbp-68]
       mov qword[rbp-104], r15
;      free r15
;    alloc r15
     mov r15d, dword[rbp-60]
     mov dword[rbp-96], r15d
;    free r15
;  [95:5] assert(o2.pos.x == -1) 
;  assert(expr : bool) 
;    inline: 95_5
;    alloc r15
;    [95:12] o2.pos.x == -1
;    [95:12] ? o2.pos.x == -1
;    [95:12] ? o2.pos.x == -1
     cmp_95_12:
     cmp qword[rbp-112], -1
     jne bool_false_95_12
     bool_true_95_12:  ; opt1
     mov r15, true
     jmp bool_end_95_12
     bool_false_95_12:
     mov r15, false
     bool_end_95_12:
;    alias expr -> r15
     if_36_8_95_5:
;    [36:8] ? not expr 
;    [36:8] ? not expr 
     cmp_36_8_95_5:
     cmp r15, 0
     jne if_36_5_95_5_end
     if_36_8_95_5_code:  ; opt1
;      [36:17] exit(1) 
;      exit(v : reg_rdi) 
;        inline: 36_17_95_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [13:5] mov(rax, 60) 
         mov rax, 60
;        [13:19] # exit system call 
;        [14:5] mov(rdi, v) 
;        [14:19] # return code 
;        [15:5] syscall() 
         syscall
;        free rdi
       exit_36_17_95_5_end:
     if_36_5_95_5_end:
;    free r15
   assert_95_5_end:
;  [96:5] assert(o2.pos.y == -2) 
;  assert(expr : bool) 
;    inline: 96_5
;    alloc r15
;    [96:12] o2.pos.y == -2
;    [96:12] ? o2.pos.y == -2
;    [96:12] ? o2.pos.y == -2
     cmp_96_12:
     cmp qword[rbp-104], -2
     jne bool_false_96_12
     bool_true_96_12:  ; opt1
     mov r15, true
     jmp bool_end_96_12
     bool_false_96_12:
     mov r15, false
     bool_end_96_12:
;    alias expr -> r15
     if_36_8_96_5:
;    [36:8] ? not expr 
;    [36:8] ? not expr 
     cmp_36_8_96_5:
     cmp r15, 0
     jne if_36_5_96_5_end
     if_36_8_96_5_code:  ; opt1
;      [36:17] exit(1) 
;      exit(v : reg_rdi) 
;        inline: 36_17_96_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [13:5] mov(rax, 60) 
         mov rax, 60
;        [13:19] # exit system call 
;        [14:5] mov(rdi, v) 
;        [14:19] # return code 
;        [15:5] syscall() 
         syscall
;        free rdi
       exit_36_17_96_5_end:
     if_36_5_96_5_end:
;    free r15
   assert_96_5_end:
;  [97:5] assert(o2.color == 0xff0000) 
;  assert(expr : bool) 
;    inline: 97_5
;    alloc r15
;    [97:12] o2.color == 0xff0000
;    [97:12] ? o2.color == 0xff0000
;    [97:12] ? o2.color == 0xff0000
     cmp_97_12:
     cmp dword[rbp-96], 0xff0000
     jne bool_false_97_12
     bool_true_97_12:  ; opt1
     mov r15, true
     jmp bool_end_97_12
     bool_false_97_12:
     mov r15, false
     bool_end_97_12:
;    alias expr -> r15
     if_36_8_97_5:
;    [36:8] ? not expr 
;    [36:8] ? not expr 
     cmp_36_8_97_5:
     cmp r15, 0
     jne if_36_5_97_5_end
     if_36_8_97_5_code:  ; opt1
;      [36:17] exit(1) 
;      exit(v : reg_rdi) 
;        inline: 36_17_97_5
;        alloc rdi
;        alias v -> rdi
         mov rdi, 1
;        [13:5] mov(rax, 60) 
         mov rax, 60
;        [13:19] # exit system call 
;        [14:5] mov(rdi, v) 
;        [14:19] # return code 
;        [15:5] syscall() 
         syscall
;        free rdi
       exit_36_17_97_5_end:
     if_36_5_97_5_end:
;    free r15
   assert_97_5_end:
;  [99:5] print(hello.len, hello) 
;  print(len : reg_rdx, ptr : reg_rsi) 
;    inline: 99_5
;    alloc rdx
;    alias len -> rdx
     mov rdx, hello.len
;    alloc rsi
;    alias ptr -> rsi
     mov rsi, hello
;    [19:5] mov(rax, 1) 
     mov rax, 1
;    [19:19] # write system call 
;    [20:5] mov(rdi, 1) 
     mov rdi, 1
;    [20:19] # file descriptor for standard out 
;    [21:5] mov(rsi, ptr) 
;    [21:19] # buffer address 
;    [22:5] mov(rdx, len) 
;    [22:19] # buffer size 
;    [23:5] syscall() 
     syscall
;    free rsi
;    free rdx
   print_99_5_end:
;  [100:5] loop
   loop_100_5:
;    [101:9] print(prompt1.len, prompt1) 
;    print(len : reg_rdx, ptr : reg_rsi) 
;      inline: 101_9
;      alloc rdx
;      alias len -> rdx
       mov rdx, prompt1.len
;      alloc rsi
;      alias ptr -> rsi
       mov rsi, prompt1
;      [19:5] mov(rax, 1) 
       mov rax, 1
;      [19:19] # write system call 
;      [20:5] mov(rdi, 1) 
       mov rdi, 1
;      [20:19] # file descriptor for standard out 
;      [21:5] mov(rsi, ptr) 
;      [21:19] # buffer address 
;      [22:5] mov(rdx, len) 
;      [22:19] # buffer size 
;      [23:5] syscall() 
       syscall
;      free rsi
;      free rdx
     print_101_9_end:
;    len: qword[rbp-120]
;    [102:9] var len = read(input.len, input) - 1 
;    [102:13] len = read(input.len, input) - 1 
;    [102:19] read(input.len, input) - 1 
;    [102:19] read(input.len, input) - 1 
;    [102:19] len = read(input.len, input) 
;    [102:19] read(input.len, input) 
;    read(len : reg_rdx, ptr : reg_rsi) : i64 nbytes 
;      inline: 102_19
;      alias nbytes -> len
;      alloc rdx
;      alias len -> rdx
       mov rdx, input.len
;      alloc rsi
;      alias ptr -> rsi
       mov rsi, input
;      [27:5] mov(rax, 0) 
       mov rax, 0
;      [27:19] # read system call 
;      [28:5] mov(rdi, 0) 
       mov rdi, 0
;      [28:19] # file descriptor for standard input 
;      [29:5] mov(rsi, ptr) 
;      [29:19] # buffer address 
;      [30:5] mov(rdx, len) 
;      [30:19] # buffer size 
;      [31:5] syscall() 
       syscall
;      [32:5] mov(nbytes, rax) 
       mov qword[rbp-120], rax
;      [32:22] # return value 
;      free rsi
;      free rdx
     read_102_19_end:
;    [102:44] len - 1 
     sub qword[rbp-120], 1
;    [102:49] # -1 don't include the '\n' 
     if_103_12:
;    [103:12] ? len == 0 
;    [103:12] ? len == 0 
     cmp_103_12:
     cmp qword[rbp-120], 0
     jne if_105_19
     if_103_12_code:  ; opt1
;      [104:13] break 
       jmp loop_100_5_end
     jmp if_103_9_end
     if_105_19:
;    [105:19] ? len <= 4 
;    [105:19] ? len <= 4 
     cmp_105_19:
     cmp qword[rbp-120], 4
     jg if_else_103_9
     if_105_19_code:  ; opt1
;      [106:13] print(prompt2.len, prompt2) 
;      print(len : reg_rdx, ptr : reg_rsi) 
;        inline: 106_13
;        alloc rdx
;        alias len -> rdx
         mov rdx, prompt2.len
;        alloc rsi
;        alias ptr -> rsi
         mov rsi, prompt2
;        [19:5] mov(rax, 1) 
         mov rax, 1
;        [19:19] # write system call 
;        [20:5] mov(rdi, 1) 
         mov rdi, 1
;        [20:19] # file descriptor for standard out 
;        [21:5] mov(rsi, ptr) 
;        [21:19] # buffer address 
;        [22:5] mov(rdx, len) 
;        [22:19] # buffer size 
;        [23:5] syscall() 
         syscall
;        free rsi
;        free rdx
       print_106_13_end:
;      [107:13] continue 
       jmp loop_100_5
     jmp if_103_9_end
     if_else_103_9:
;        [109:13] print(prompt3.len, prompt3) 
;        print(len : reg_rdx, ptr : reg_rsi) 
;          inline: 109_13
;          alloc rdx
;          alias len -> rdx
           mov rdx, prompt3.len
;          alloc rsi
;          alias ptr -> rsi
           mov rsi, prompt3
;          [19:5] mov(rax, 1) 
           mov rax, 1
;          [19:19] # write system call 
;          [20:5] mov(rdi, 1) 
           mov rdi, 1
;          [20:19] # file descriptor for standard out 
;          [21:5] mov(rsi, ptr) 
;          [21:19] # buffer address 
;          [22:5] mov(rdx, len) 
;          [22:19] # buffer size 
;          [23:5] syscall() 
           syscall
;          free rsi
;          free rdx
         print_109_13_end:
;        [110:13] print(len, input) 
;        print(len : reg_rdx, ptr : reg_rsi) 
;          inline: 110_13
;          alloc rdx
;          alias len -> rdx
           mov rdx, qword[rbp-120]
;          alloc rsi
;          alias ptr -> rsi
           mov rsi, input
;          [19:5] mov(rax, 1) 
           mov rax, 1
;          [19:19] # write system call 
;          [20:5] mov(rdi, 1) 
           mov rdi, 1
;          [20:19] # file descriptor for standard out 
;          [21:5] mov(rsi, ptr) 
;          [21:19] # buffer address 
;          [22:5] mov(rdx, len) 
;          [22:19] # buffer size 
;          [23:5] syscall() 
           syscall
;          free rsi
;          free rdx
         print_110_13_end:
;        [111:13] print(dot.len, dot) 
;        print(len : reg_rdx, ptr : reg_rsi) 
;          inline: 111_13
;          alloc rdx
;          alias len -> rdx
           mov rdx, dot.len
;          alloc rsi
;          alias ptr -> rsi
           mov rsi, dot
;          [19:5] mov(rax, 1) 
           mov rax, 1
;          [19:19] # write system call 
;          [20:5] mov(rdi, 1) 
           mov rdi, 1
;          [20:19] # file descriptor for standard out 
;          [21:5] mov(rsi, ptr) 
;          [21:19] # buffer address 
;          [22:5] mov(rdx, len) 
;          [22:19] # buffer size 
;          [23:5] syscall() 
           syscall
;          free rsi
;          free rdx
         print_111_13_end:
;        [112:13] print(nl.len, nl) 
;        print(len : reg_rdx, ptr : reg_rsi) 
;          inline: 112_13
;          alloc rdx
;          alias len -> rdx
           mov rdx, nl.len
;          alloc rsi
;          alias ptr -> rsi
           mov rsi, nl
;          [19:5] mov(rax, 1) 
           mov rax, 1
;          [19:19] # write system call 
;          [20:5] mov(rdi, 1) 
           mov rdi, 1
;          [20:19] # file descriptor for standard out 
;          [21:5] mov(rsi, ptr) 
;          [21:19] # buffer address 
;          [22:5] mov(rdx, len) 
;          [22:19] # buffer size 
;          [23:5] syscall() 
           syscall
;          free rsi
;          free rdx
         print_112_13_end:
     if_103_9_end:
   jmp loop_100_5
   loop_100_5_end:
; main end

; system call: exit 0
mov rax, 60
mov rdi, 0
syscall

; max scratch registers in use: 1
;            max frames in use: 7
;        max inline stack size: 120 B
```

