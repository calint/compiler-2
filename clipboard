	static void replaceSubstring(string& original_string,const string& substring_to_replace,const string& replacement_string){
		size_t start_pos=original_string.find(substring_to_replace);
		if(start_pos!=string::npos){
			original_string.replace(start_pos,substring_to_replace.length(),replacement_string);
		}
	}


TAG=2023-04-23--4--checkpoint && git tag $TAG && git push origin $TAG

git reset --hard HEAD

   ; sign extended mov
   movsx rax,byte[rbp-8]
   movsx rax,word[rbp-8]
   movsx rax,dword[rbp-8]

   push rax
   push ax

   push qword[rax]
   push word[rax]

   push byte 1
   push word 1
   push dword 1
   push qword 1


--------------------------
extern printf

section .text
global main
main:
   mov rsi,42
   mov rdi,fmt
   xor rax,rax
   call printf
   ret

section .data
fmt db 'di: %d',10,0
fmt.len equ $-fmt

section .note.GNU-stack noexec
-----------------------------
nasm -f elf64 gen-m.s && gcc -no-pie -o gen-m gen-m.o && ./gen-m


const token&
----------------
copy constructor
constructor
copy constructor
constructor
constructor
move constructor

token move
----------------
constructor
move constructor
move constructor
move constructor
constructor
constructor
move constructor

token copy
----------------
constructor
copy constructor
copy constructor
copy constructor
constructor
constructor
move constructor


#include <iostream>
#include <regex>
#include <string>

int main() {
  std::string str = "This is a test string [more or less].";
  std::regex re("\\[(.*?)\\]");
  std::smatch match;

  if (std::regex_search(str, match, re)) {
    std::cout << match[1] << std::endl;
  }
  return 0;
}


std::regex regexPattern(R"(^\s*jmp\s?(.?)\s*$)");

int main() {
   std::string date_string = "2023-03-17";
   std::regex date_regex{ R"((\d{4})-(\d{2})-(\d{2}))" };
   std::smatch match;
   if (std::regex_search(date_string, match, date_regex)) {
      std::cout << "Year: " << match[1].str() << std::endl;
      std::cout << "Month: " << match[2].str() << std::endl;
      std::cout << "Day: " << match[3].str() << std::endl;
   } else {
      std::cout << "No match found" << std::endl;
   }
   return 0;
}


To rewrite the expression "not (a=1 and b=2)" without the "not", 
use De Morgan's laws, which state that "not (A and B)" is the same as
"(not A) or (not B)" and "not (A or B)" is the same as "(not A) and (not B)".
Applying this to the given expression, we get:
"not (a=1 and b=2)" is the same as "(not a=1) or (not b=2)"
