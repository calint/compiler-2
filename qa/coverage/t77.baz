# note: A.I. generated by Claude 4.5 with minor change

# Complex type tests for object and point types

type point {x, y}
type object {pos : point, color : i32}

func exit(v : reg_rdi) {
    mov(rax, 60)
    mov(rdi, v)
    syscall()
}

func assert(expr : bool) {
    if not expr exit(1)
}

func double(x) : i64 ret {
    ret = x * 2
}

func triple(x) : i64 ret {
    ret = x * 3
}

func add(a, b) : i64 res {
    res = a + b
}

func subtract(a, b) : i64 res {
    res = a - b
}

func multiply(x, y) : i64 result {
    result = x * y
}

func negate(v) : i64 neg {
    neg = -v
}

func compute_color(r : i32, g : i32, b : i32) : i32 color {
    color = (r * 0x10000) + (g * 0x100) + b
}

func square(n) : i64 sq {
    sq = n * n
}

func cube(n) : i64 cb {
    cb = n * n * n
}

func increment(n) : i64 inc {
    inc = n + 1
}

func decrement(n) : i64 dec {
    dec = n - 1
}

func halve(n) : i64 half {
    half = n / 2
}

func max(a, b) : i64 result {
    if a > b {
        result = a
    } else {
        result = b
    }
}

func min(a, b) : i64 result {
    if a < b {
        result = a
    } else {
        result = b
    }
}

func abs(v) : i64 result {
    if v < 0 {
        result = -v
    } else {
        result = v
    }
}

func main() {
    # Test 1: Nested function calls with arithmetic
    # add(double(5), triple(2)) = add(10, 6) = 16
    # multiply(increment(3), decrement(5)) = multiply(4, 4) = 16
    var p1 : point = {add(double(5), triple(2)), multiply(increment(3), decrement(5))}
    assert(p1.x == 16)
    assert(p1.y == 16)
    
    # Test 2: Complex nested calls with negation
    # negate(add(10, double(5))) = negate(add(10, 10)) = negate(20) = -20
    # subtract(square(5), triple(3)) = subtract(25, 9) = 16
    var p2 : point = {negate(add(10, double(5))), subtract(square(5), triple(3))}
    assert(p2.x == -20)
    assert(p2.y == 16)
    
    # Test 3: Deep nesting with multiple operations
    # halve(add(double(10), square(4))) = halve(add(20, 16)) = halve(36) = 18
    # multiply(halve(8), increment(double(2))) = multiply(4, increment(4)) = multiply(4, 5) = 20
    var p3 : point = {halve(add(double(10), square(4))), multiply(halve(8), increment(double(2)))}
    assert(p3.x == 18)
    assert(p3.y == 20)
    
    # Test 4: Arithmetic between nested function calls
    # square(3) + cube(2) = 9 + 8 = 17
    # double(4) * triple(2) - 10 = 8 * 6 - 10 = 48 - 10 = 38
    var a = 3
    var bb = 4
    var p4 : point = {square(a) + cube(2), double(bb) * triple(2) - 10}
    assert(p4.x == 17)
    assert(p4.y == 38)
    
    # Test 5: Object with deeply nested point initialization
    # add(multiply(2, 3), double(square(2))) = add(6, double(4)) = add(6, 8) = 14
    # subtract(triple(10), halve(20)) = subtract(30, 10) = 20
    var o1 : object = {{add(multiply(2, 3), double(square(2))), subtract(triple(10), halve(20))}, compute_color(0xff, 0, 0)}
    assert(o1.pos.x == 14)
    assert(o1.pos.y == 20)
    assert(o1.color == 0xff0000)
    
    # Test 6: Max and min with nested calls
    # max(double(5), triple(3)) = max(10, 9) = 10
    # min(square(4), cube(2)) = min(16, 8) = 8
    var p5 : point = {max(double(5), triple(3)), min(square(4), cube(2))}
    assert(p5.x == 10)
    assert(p5.y == 8)
    
    # Test 7: Absolute value with nested negations
    # abs(negate(add(5, 10))) = abs(negate(15)) = abs(-15) = 15
    # abs(subtract(5, 20)) = abs(-15) = 15
    var p6 : point = {abs(negate(add(5, 10))), abs(subtract(5, 20))}
    assert(p6.x == 15)
    assert(p6.y == 15)
    
    # Test 8: Complex object with arithmetic between function calls
    # double(5) + triple(3) - increment(2) = 10 + 9 - 3 = 16
    # multiply(square(5), 2) / halve(10) = multiply(25, 2) / 5 = 50 / 5 = 10
    var x = 5
    var y = 3
    var o2 : object = {{double(x) + triple(y) - increment(2), multiply(square(x), 2) / halve(10)}, compute_color(increment(0xfe), 0, 0)}
    assert(o2.pos.x == 16)
    assert(o2.pos.y == 10)
    assert(o2.color == 0xff0000)
    
    # Test 9: Chained operations with multiple nesting levels
    # add(double(add(3, 2)), multiply(2, increment(4))) = add(double(5), multiply(2, 5)) = add(10, 10) = 20
    # subtract(square(add(2, 3)), double(triple(2))) = subtract(square(5), double(6)) = subtract(25, 12) = 13
    var p7 : point = {add(double(add(3, 2)), multiply(2, increment(4))), subtract(square(add(2, 3)), double(triple(2)))}
    assert(p7.x == 20)
    assert(p7.y == 13)
    
    # Test 10: Object field updates with complex nested calls
    # add(multiply(double(3), triple(2)), subtract(20, halve(10))) = add(multiply(6, 6), subtract(20, 5)) = add(36, 15) = 51
    # multiply(increment(square(3)), decrement(cube(2))) = multiply(increment(9), decrement(8)) = multiply(10, 7) = 70
    var o3 : object = {{0, 0}, 0}
    o3.pos.x = add(multiply(double(3), triple(2)), subtract(20, halve(10)))
    o3.pos.y = multiply(increment(square(3)), decrement(cube(2)))
    assert(o3.pos.x == 51)
    assert(o3.pos.y == 70)
    
    # Test 11: Point with extreme nesting
    # halve(double(triple(square(2)))) = halve(double(triple(4))) = halve(double(12)) = halve(24) = 12
    # add(increment(double(5)), decrement(triple(4))) = add(increment(10), decrement(12)) = add(11, 11) = 22
    var p8 : point = {halve(double(triple(square(2)))), add(increment(double(5)), decrement(triple(4)))}
    assert(p8.x == 12)
    assert(p8.y == 22)
    
    # Test 12: Mixing max/min with arithmetic
    # max(add(5, 10), multiply(3, 4)) + 5 = max(15, 12) + 5 = 15 + 5 = 20
    # min(square(5), double(10)) * 2 = min(25, 20) * 2 = 20 * 2 = 40
    var p9 : point = {max(add(5, 10), multiply(3, 4)) + 5, min(square(5), double(10)) * 2}
    assert(p9.x == 20)
    assert(p9.y == 40)
    
    # Test 13: Object with color computation using nested calls
    # compute_color(halve(128), double(64), triple(32)) = compute_color(64, 128, 96) = 0x408060
    var r = 128
    var g = 64
    var b = 32
    var o4 : object = {{add(r, g), subtract(r, b)}, compute_color(halve(r), double(g), triple(b))}
    assert(o4.pos.x == 192)
    assert(o4.pos.y == 96)
    assert(o4.color == 0x408060)
    
    # Test 14: Complex arithmetic between deeply nested calls
    # double(add(triple(2), square(3))) - halve(increment(19)) = double(add(6, 9)) - halve(20) = double(15) - 10 = 30 - 10 = 20
    # multiply(halve(double(8)), add(3, square(2))) = multiply(halve(16), add(3, 4)) = multiply(8, 7) = 56
    var p10 : point = {double(add(triple(2), square(3))) - halve(increment(19)), multiply(halve(double(8)), add(3, square(2)))}
    assert(p10.x == 20)
    assert(p10.y == 56)
    
    # Test 15: Nested calls with all operations combined
    # add(multiply(square(2), cube(3)), subtract(double(10), triple(2))) = add(multiply(4, 27), subtract(20, 6)) = add(108, 14) = 122
    # max(halve(100), min(square(8), triple(20))) = max(50, min(64, 60)) = max(50, 60) = 60
    var m = 2
    var n = 3
    var p11 : point = {add(multiply(square(m), cube(n)), subtract(double(10), triple(2))), max(halve(100), min(square(8), triple(20)))}
    assert(p11.x == 122)
    assert(p11.y == 60)
    
    # Test 16: Object with complex nested initialization
    # halve(add(double(square(5)), triple(cube(2)))) = halve(add(double(25), triple(8))) = halve(add(50, 24)) = halve(74) = 37
    # increment(multiply(decrement(10), halve(8))) = increment(multiply(9, 4)) = increment(36) = 37
    var o5 : object = {{halve(add(double(square(5)), triple(cube(2)))), increment(multiply(decrement(10), halve(8)))}, 0xabcdef}
    assert(o5.pos.x == 37)
    assert(o5.pos.y == 37)
    
    # Test 17: Absolute values with complex expressions
    # abs(subtract(multiply(2, 3), square(4))) = abs(subtract(6, 16)) = abs(-10) = 10
    # abs(negate(add(double(5), triple(3)))) = abs(negate(add(10, 9))) = abs(negate(19)) = abs(-19) = 19
    var p12 : point = {abs(subtract(multiply(2, 3), square(4))), abs(negate(add(double(5), triple(3))))}
    assert(p12.x == 10)
    assert(p12.y == 19)
    
    # Test 18: Cascading function calls with arithmetic
    # (add(5, double(3)) * increment(2)) - halve(20) = (add(5, 6) * 3) - 10 = (11 * 3) - 10 = 33 - 10 = 23
    # triple(square(2)) + multiply(decrement(5), 3) = triple(4) + multiply(4, 3) = 12 + 12 = 24
    var p13 : point = {add(5, double(3)) * increment(2) - halve(20), triple(square(2)) + multiply(decrement(5), 3)}
    assert(p13.x == 23)
    assert(p13.y == 24)
    
    # Test 19: Object modification with nested function arithmetic
    # multiply(add(double(3), triple(2)), halve(increment(3))) = multiply(add(6, 6), halve(4)) = multiply(12, 2) = 24
    # subtract(square(increment(5)), double(halve(10))) = subtract(square(6), double(5)) = subtract(36, 10) = 26
    var o6 : object = {{10, 20}, compute_color(0xff, 0xff, 0xff)}
    o6.pos.x = multiply(add(double(3), triple(2)), halve(increment(3)))
    o6.pos.y = subtract(square(increment(5)), double(halve(10)))
    assert(o6.pos.x == 24)
    assert(o6.pos.y == 26)
    
    # Test 20: Triple nesting with mixed operations
    # double(halve(add(square(4), triple(double(3))))) = double(halve(add(16, triple(6)))) = double(halve(add(16, 18))) = double(halve(34)) = double(17) = 34
    # triple(halve(subtract(cube(3), double(square(2))))) = triple(halve(subtract(27, double(4)))) = triple(halve(subtract(27, 8))) = triple(halve(19)) = triple(9) = 27
    var p14 : point = {double(halve(add(square(4), triple(double(3))))), triple(halve(subtract(cube(3), double(square(2)))))}
    assert(p14.x == 34)
    assert(p14.y == 27)
    
    # Test 21: Max/min chains with nested arithmetic
    # min(max(double(5), triple(3)), add(square(3), 10)) = min(max(10, 9), add(9, 10)) = min(10, 19) = 10
    # max(min(cube(2), square(4)), halve(30)) = max(min(8, 16), 15) = max(8, 15) = 15
    var p15 : point = {min(max(double(5), triple(3)), add(square(3), 10)), max(min(cube(2), square(4)), halve(30))}
    assert(p15.x == 10)
    assert(p15.y == 15)
    
    # Test 22: Object with all helper functions used
    # add(abs(negate(5)), max(double(3), 4)) = add(abs(-5), max(6, 4)) = add(5, 6) = 11
    # multiply(min(triple(2), 10), increment(halve(6))) = multiply(min(6, 10), increment(3)) = multiply(6, 4) = 24
    var o7 : object = {{add(abs(negate(5)), max(double(3), 4)), multiply(min(triple(2), 10), increment(halve(6)))}, compute_color(0x12, 0x34, 0x56)}
    assert(o7.pos.x == 11)
    assert(o7.pos.y == 24)
    
    # Test 23: Deep nesting stress test
    # add(multiply(double(triple(2)), halve(square(4))), subtract(cube(2), increment(5))) = add(multiply(double(6), halve(16)), subtract(8, 6)) = add(multiply(12, 8), 2) = add(96, 2) = 98
    # double(add(square(2), multiply(triple(1), halve(6)))) = double(add(4, multiply(3, 3))) = double(add(4, 9)) = double(13) = 26
    var p16 : point = {add(multiply(double(triple(2)), halve(square(4))), subtract(cube(2), increment(5))), double(add(square(2), multiply(triple(1), halve(6))))}
    assert(p16.x == 98)
    assert(p16.y == 26)
    
    # Test 24: Object point replacement with complex expressions
    # subtract(multiply(square(3), 2), double(triple(2))) = subtract(multiply(9, 2), double(6)) = subtract(18, 12) = 6
    # add(halve(triple(20)), increment(decrement(10))) = add(halve(60), 10) = add(30, 10) = 40
    var replacement : point = {subtract(multiply(square(3), 2), double(triple(2))), add(halve(triple(20)), increment(decrement(10)))}
    var o8 : object = {{0, 0}, 0xff00ff}
    o8.pos = replacement
    assert(o8.pos.x == 6)
    assert(o8.pos.y == 40)
    
    # Test 25: Final complex test with all operations
    # add(multiply(max(double(4), triple(2)), min(3, halve(10))), abs(negate(square(2)))) = add(multiply(max(8, 6), min(3, 5)), abs(negate(4))) = add(multiply(8, 3), abs(-4)) = add(24, 4) = 28
    # subtract(cube(increment(2)), multiply(halve(double(6)), decrement(triple(2)))) = subtract(cube(3), multiply(halve(12), decrement(6))) = subtract(27, multiply(6, 5)) = subtract(27, 30) = -3
    var final_x = add(multiply(max(double(4), triple(2)), min(3, halve(10))), abs(negate(square(2))))
    var final_y = subtract(cube(increment(2)), multiply(halve(double(6)), decrement(triple(2))))
    var p17 : point = {final_x, final_y}
    assert(p17.x == 28)
    assert(p17.y == -3)
}
