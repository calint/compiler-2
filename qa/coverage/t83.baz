# generated by Claude Sonnet 4.5

func exit(v : reg_rdi) {
    mov(rax, 60)  # exit system call
    mov(rdi, v)   # return code
    syscall()
}

func assert(expr : bool) {
    if not expr exit(1)
}

# Define increasingly complex nested types
type vec3 {x, y, z}
type point {x, y}
type color_rgba {r : i8, g : i8, b : i8, a : i8}
type object {pos : point, color : i32, id : i64}
type cluster {objs: object[10], flags : i8}
type particle {vel : vec3, pos : vec3, mass : i32, active : bool}
type physics_grid {particles : particle[5], timestamp : i64}
type scene_layer {clusters : cluster[3], grid : physics_grid, name : i64}
type mega_structure {layers : scene_layer[4], colors : color_rgba[8], metadata : i64[16]}

func main() {
    # Test 1: Basic nested array access
    var cr : cluster[7]
    cr[1].objs[2].pos.y = 8
    assert(cr[1].objs[2].pos.y == 8)
    cr[2].flags = ~2
    assert(cr[2].flags == ~2)
    
    # Test 2: Expression-based indexing
    var ix : i32 = 4
    cr[ix + 1].objs[ix - 1].color = ~2
    assert(cr[ix + 1].objs[ix - 1].color == ~2)
    
    # Test 3: Multiple array indices in same expression
    var a : i32 = 2
    var b : i32 = 3
    cr[a].objs[b].pos.x = 42
    cr[a].objs[b].pos.y = 99
    assert(cr[a].objs[b].pos.x == 42)
    assert(cr[a].objs[b].pos.y == 99)
    
    # Test 4: Deep nesting with particles
    var pg : physics_grid[3]
    pg[0].particles[0].vel.x = 100
    pg[0].particles[0].vel.y = 200
    pg[0].particles[0].vel.z = 300
    assert(pg[0].particles[0].vel.x == 100)
    assert(pg[0].particles[0].vel.y == 200)
    assert(pg[0].particles[0].vel.z == 300)
    
    # Test 5: Complex expression indexing
    var i : i32 = 1
    var j : i32 = 2
    pg[i + j - 2].particles[i * 2].mass = 777
    assert(pg[i + j - 2].particles[i * 2].mass == 777)
    
    # Test 6: Boolean fields in nested structures
    pg[1].particles[3].active = true
    assert(pg[1].particles[3].active == true)
    pg[1].particles[4].active = false
    assert(pg[1].particles[4].active == false)
    
    # Test 7: Scene layers - very deep nesting
    var scene : scene_layer[2]
    scene[0].clusters[1].objs[5].pos.x = 123
    scene[0].clusters[1].objs[5].pos.y = 456
    scene[0].clusters[1].objs[5].color = 0x7F00FF
    assert(scene[0].clusters[1].objs[5].pos.x == 123)
    assert(scene[0].clusters[1].objs[5].pos.y == 456)
    assert(scene[0].clusters[1].objs[5].color == 0x7F00FF)
    
    # Test 8: Grid within scene layer
    scene[1].grid.particles[2].pos.x = 10
    scene[1].grid.particles[2].pos.y = 20
    scene[1].grid.particles[2].pos.z = 30
    assert(scene[1].grid.particles[2].pos.x == 10)
    assert(scene[1].grid.particles[2].pos.y == 20)
    assert(scene[1].grid.particles[2].pos.z == 30)
    
    # Test 9: Color array with byte fields
    var colors : color_rgba[10]
    colors[5].r = 127
    colors[5].g = 100
    colors[5].b = 64
    colors[5].a = 32
    assert(colors[5].r == 127)
    assert(colors[5].g == 100)
    assert(colors[5].b == 64)
    assert(colors[5].a == 32)
    
    # Test 10: The mega structure - ultimate nesting test
    var mega : mega_structure[1]
    mega[0].layers[2].clusters[1].objs[7].pos.x = 9999
    assert(mega[0].layers[2].clusters[1].objs[7].pos.x == 9999)
    
    mega[0].layers[3].grid.particles[4].vel.z = ~123
    assert(mega[0].layers[3].grid.particles[4].vel.z == ~123)
    
    mega[0].colors[6].r = 120
    mega[0].colors[6].g = 100
    assert(mega[0].colors[6].r == 120)
    assert(mega[0].colors[6].g == 100)
    
    mega[0].metadata[15] = 0x7EADBEEF
    assert(mega[0].metadata[15] == 0x7EADBEEF)
    
    # Test 11: All variable indices
    var idx1 : i32 = 1
    var idx2 : i32 = 2
    var idx3 : i32 = 3
    mega.layers[idx1].clusters[idx2].objs[idx3].id = 0x12345678
    assert(mega.layers[idx1].clusters[idx2].objs[idx3].id == 0x12345678)
    
    # Test 12: Chained expression indices
    var base : i32 = 1
    mega[0].layers[base].clusters[base + 1].objs[base * 2].color = 0x7BCDEF
    assert(mega[0].layers[base].clusters[base + 1].objs[base * 2].color == 0x7BCDEF)
    
    # Test 13: Array at every level
    var m2 : mega_structure[2]
    m2[0].layers[1].clusters[0].objs[3].pos.y = 555
    m2[1].layers[2].clusters[1].objs[4].color = 0x7AFEBABE
    assert(m2[0].layers[1].clusters[0].objs[3].pos.y == 555)
    assert(m2[1].layers[2].clusters[1].objs[4].color == 0x7AFEBABE)
    
    # Test 14: Timestamp in deeply nested grid
    m2[1].layers[0].grid.timestamp = 0x12345678
    assert(m2[1].layers[0].grid.timestamp == 0x12345678)
    
    # Test 15: Edge case - first and last indices
    var edges : object[8]
    edges[0].pos.x = 111
    edges[7].pos.y = 222
    assert(edges[0].pos.x == 111)
    assert(edges[7].pos.y == 222)
    
    # Test 16: Sequential writes to same deep path
    var seq : scene_layer[1]
    seq[0].clusters[2].objs[9].pos.x = 1
    seq[0].clusters[2].objs[9].pos.x = 2
    seq[0].clusters[2].objs[9].pos.x = 3
    assert(seq[0].clusters[2].objs[9].pos.x == 3)
    
    # Test 17: Different sizes - i8, i32, i64 mixed
    var mix : cluster[1]
    mix[0].objs[5].id = 0x11223344
    mix[0].objs[5].color = 0x11223344
    mix[0].flags = 0x11
    assert(mix[0].objs[5].id == 0x11223344)
    assert(mix[0].objs[5].color == 0x11223344)
    assert(mix[0].flags == 0x11)
    
    # Test 18: Complex arithmetic in all indices
    var x : i32 = 2
    var y : i32 = 3
    # x - 2 = 0, y - 2 = 1, x - 1 = 1, y + x - 4 = 1
    m2[0].layers[1].clusters[1].objs[1].pos.x = 888
    assert(m2[0].layers[1].clusters[1].objs[1].pos.x == 888)
    
    # Test 19: Back-to-back array access on same base
    scene[0].clusters[0].flags = 1
    scene[0].clusters[1].flags = 2
    scene[0].clusters[2].flags = 3
    assert(scene[0].clusters[0].flags == 1)
    assert(scene[0].clusters[1].flags == 2)
    assert(scene[0].clusters[2].flags == 3)
    
    # Test 20: Maximum depth chain
    var deep : mega_structure[2]
    deep[1].layers[3].clusters[2].objs[9].pos.x = 0x7FFFFFFF
    deep[1].layers[3].clusters[2].objs[9].pos.y = ~0x7FFFFFFF
    assert(deep[1].layers[3].clusters[2].objs[9].pos.x == 0x7FFFFFFF)
    assert(deep[1].layers[3].clusters[2].objs[9].pos.y == ~0x7FFFFFFF)
    
    # SUCCESS! All tests passed
    exit(0)
}
