func exit(v : reg_rdi) {
    mov(rax, 60)
    mov(rdi, v)
    syscall()
}

func assert(expr : bool) {
    if not expr exit(1)
}

type vec3 { x : i32, y : i32, z : i32 }
type color { r : i32, g : i32, b : i32, a : i32 }

type vertex {
    pos : vec3,
    col : color,
    uv_x : i32,
    uv_y : i32
}

type mesh {
    vertices : vertex[16],
    indices : i32[24],
    id : i32
}

type scene {
    meshes : mesh[4],
    active : i32
}

type world {
    scenes : scene[3],
    metadata : i8[32]
}

func init_vertex(v : vertex, idx : i32) {
    v.pos.x = idx * 11
    v.pos.y = idx * 22
    v.pos.z = idx * 33
    v.col.r = idx * 2
    v.col.g = idx * 3
    v.col.b = idx * 4
    v.col.a = idx * 5
    v.uv_x = idx
    v.uv_y = idx * 2
}

func verify_vertex(v : vertex, idx : i32) {
    assert(v.pos.x == idx * 11)
    assert(v.pos.y == idx * 22)
    assert(v.pos.z == idx * 33)
    assert(v.col.r == idx * 2)
    assert(v.col.g == idx * 3)
    assert(v.col.b == idx * 4)
    assert(v.col.a == idx * 5)
    assert(v.uv_x == idx)
    assert(v.uv_y == idx * 2)
}

func init_mesh(m : mesh, id_val : i32) {
    m.id = id_val
    
    var i = 0
    loop {
        init_vertex(m.vertices[i], i)
        i = i + 1
        if i == 16 break
    }
    
    i = 0
    loop {
        m.indices[i] = i * 2
        i = i + 1
        if i == 24 break
    }
}

func verify_mesh(m : mesh, id_val : i32) {
    assert(m.id == id_val)
    
    var i = 0
    loop {
        verify_vertex(m.vertices[i], i)
        i = i + 1
        if i == 16 break
    }
    
    i = 0
    loop {
        assert(m.indices[i] == i * 2)
        i = i + 1
        if i == 24 break
    }
}

func scale_vertices(s : scene, scale_factor : i32) {
    var i = 0
    loop {
        var j = 0
        loop {
            s.meshes[i].vertices[j].pos.x = s.meshes[i].vertices[j].pos.x * scale_factor
            s.meshes[i].vertices[j].pos.y = s.meshes[i].vertices[j].pos.y * scale_factor
            s.meshes[i].vertices[j].pos.z = s.meshes[i].vertices[j].pos.z * scale_factor
            j = j + 1
            if j == 16 break
        }
        i = i + 1
        if i == 4 break
    }
}

func shift_colors(s : scene, shift_val : i32) {
    var i = 0
    loop {
        var j = 0
        loop {
            s.meshes[i].vertices[j].col.r = s.meshes[i].vertices[j].col.r + shift_val
            s.meshes[i].vertices[j].col.g = s.meshes[i].vertices[j].col.g + shift_val
            s.meshes[i].vertices[j].col.b = s.meshes[i].vertices[j].col.b + shift_val
            j = j + 1
            if j == 16 break
        }
        i = i + 1
        if i == 4 break
    }
}

func p(len : reg_rdx, ptr : reg_rsi) {
    mov(rax, 1)   # write system call
    mov(rdi, 1)   # file descriptor for standard out
    mov(rsi, ptr) # buffer address 
    mov(rdx, len) # buffer size
    syscall()
}

field nl_str = "\n"

func nl() p(nl_str.len, nl_str)

func pn(num) {
    var buf : i8[20]
    var n = num
    var is_negative : bool = false
    
    if n < 0 {
        is_negative = true
        n = -n
    }
    
    var i = 20
    loop {
        i = i - 1
        buf[i] = 48 + (n % 10)
        n = n / 10
        if n == 0 break
    }
    
    if is_negative {
        i = i - 1
        buf[i] = 45
    }
    
    var write_pos = 0
    loop {
        buf[write_pos] = buf[i]
        write_pos = write_pos + 1
        i = i + 1
        if i == 20 break
    }
    
    p(write_pos, address_of(buf))
}

func main() {
    var w : world[2]
    
    # TEST 1: Deep nested struct array initialization and verification
    var i = 0
    loop {
        var j = 0
        loop {
            var k = 0
            loop {
                init_mesh(w[0].scenes[j].meshes[k], j * 100 + k)
                k = k + 1
                if k == 4 break
            }
            j = j + 1
            if j == 3 break
        }
        i = i + 1
        if i == 1 break
    }
    
    # Verify all initialized correctly
    verify_mesh(w[0].scenes[0].meshes[0], 0)
    verify_mesh(w[0].scenes[0].meshes[3], 3)
    verify_mesh(w[0].scenes[1].meshes[2], 102)
    verify_mesh(w[0].scenes[2].meshes[3], 203)
    
    # TEST 2: Complex nested field modification
    w[0].scenes[1].meshes[2].vertices[7].pos.x = 0xdead
    w[0].scenes[1].meshes[2].vertices[7].pos.y = 0xbeef
    w[0].scenes[1].meshes[2].vertices[7].col.r = 0xff
    w[0].scenes[1].meshes[2].vertices[7].col.a = 0xaa
    
    assert(w[0].scenes[1].meshes[2].vertices[7].pos.x == 0xdead)
    assert(w[0].scenes[1].meshes[2].vertices[7].pos.y == 0xbeef)
    assert(w[0].scenes[1].meshes[2].vertices[7].col.r == 0xff)
    assert(w[0].scenes[1].meshes[2].vertices[7].col.a == 0xaa)
    
    # TEST 3: array_copy with deeply nested struct arrays
    array_copy(
        w[0].scenes[0].meshes,
        w[1].scenes[2].meshes,
        array_size_of(w[0].scenes[0].meshes)
    )
    
    # Verify copy
    verify_mesh(w[1].scenes[2].meshes[0], 0)
    verify_mesh(w[1].scenes[2].meshes[3], 3)
    
    # TEST 4: arrays_equal on complex nested vertex arrays
    var eq1 : bool = arrays_equal(
        w[0].scenes[0].meshes[2].vertices,
        w[1].scenes[2].meshes[2].vertices,
        array_size_of(w[0].scenes[0].meshes[2].vertices)
    )
    assert(eq1)
    
    # TEST 5: Partial array_copy on nested mesh indices
    array_copy(
        w[0].scenes[1].meshes[1].indices,
        w[0].scenes[2].meshes[0].indices,
        12
    )
    
    var idx = 0
    loop {
        assert(w[0].scenes[2].meshes[0].indices[idx] == idx * 2)
        idx = idx + 1
        if idx == 12 break
    }
    
    # TEST 6: Multiple levels of array indexing with arithmetic
    var mesh_idx = 1
    var vertex_idx = 5
    w[0].scenes[0].meshes[mesh_idx].vertices[vertex_idx].pos.z = 0x1234
    assert(w[0].scenes[0].meshes[1].vertices[5].pos.z == 0x1234)

    pn(w[1].scenes[0].meshes[1].vertices[3].pos.y) nl()

    # TEST 7: Function modification of nested struct arrays
    
    array_copy(w[0], w[1], 1)

    var scale : i32 = 2
    scale_vertices(w[1].scenes[0], scale)
    
    # After scaling by 2:
    # vertex[0]: pos originally {0,0,0}, stays {0,0,0}
    # vertex[3]: pos originally {33,66,99}, becomes {66,132,198}
    # vertex[7]: pos originally {77,154,231}, becomes {154,308,462}
    
    assert(w[1].scenes[0].meshes[0].vertices[0].pos.x == 0)
    assert(w[1].scenes[0].meshes[1].vertices[3].pos.y == 132)
    assert(w[1].scenes[0].meshes[2].vertices[7].pos.z == 462)
    
    # TEST 8: Nested struct array copy after modification
    shift_colors(w[1].scenes[1], 10)
    
    array_copy(
        w[1].scenes[1].meshes,
        w[0].scenes[2].meshes,
        array_size_of(w[1].scenes[1].meshes)
    )
    
    # Verify colors were shifted and copied
    # Original vertex[5] color.r for mesh 0: 5*2=10, after shift: 20
    assert(w[0].scenes[2].meshes[0].vertices[5].col.r == 20)
    assert(w[0].scenes[2].meshes[1].vertices[8].col.g == 34)  # 8*3+10=34

    # TEST 9: Initialize standalone mesh array and copy to nested
    var standalone_meshes : mesh[4]
    var m = 0
    loop {
        init_mesh(standalone_meshes[m], 1000 + m)
        m = m + 1
        if m == 4 break
    }
    
    array_copy(
        standalone_meshes,
        w[1].scenes[2].meshes,
        array_size_of(standalone_meshes)
    )
    
    verify_mesh(w[1].scenes[2].meshes[0], 1000)
    verify_mesh(w[1].scenes[2].meshes[3], 1003)
    
    # TEST 10: Cross-scene mesh swapping via temporary
    var temp_mesh_indices : i32[24]
    array_copy(
        w[0].scenes[0].meshes[1].indices,
        temp_mesh_indices,
        array_size_of(temp_mesh_indices)
    )
    
    array_copy(
        w[0].scenes[1].meshes[2].indices,
        w[0].scenes[0].meshes[1].indices,
        array_size_of(w[0].scenes[0].meshes[1].indices)
    )
    
    array_copy(
        temp_mesh_indices,
        w[0].scenes[1].meshes[2].indices,
        array_size_of(temp_mesh_indices)
    )
    
    # Verify swap: meshes[1] of scene[0] should now have scene[1]'s indices
    var verify_swap = 0
    loop {
        assert(w[0].scenes[0].meshes[1].indices[verify_swap] == verify_swap * 2)
        verify_swap = verify_swap + 1
        if verify_swap == 24 break
    }
}
