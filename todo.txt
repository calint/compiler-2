[x] negated expression
[x]   support for negated expr_ops_list. i.e. a=-(1+2)
[ ]   review
[ ] compile error when i.e.:
      var a=-1
      var b=-b-(-a) # b is used before initiated
[ ] post processing optmization for: var b=-(-a*-a)
      mov r15,qword[rbp-8]
      neg r15
      neg r15
      mov qword[rbp-16],r15
[ ] character type
[ ] string type
[ ] var str="hello world"
[ ] var len=str.len
[ ] def table{x,y,z}
[ ] pointers?
[ ] bitwise logical ops: & | ^ ~
[ ] op shift left and right
[ ] implement division op
[ ] bool type
[ ] inlined function call: if a named register is not available: push/pop?
[ ] short-hand boolean expression i.e. if a or b
[ ] decouple by using cpp implementation files for block and call, remove decouple.hpp
[ ] toc.add_var(...) check if name shadows
[ ] stmt_call: enable nested use of named registers
      example: f(x+1,x) where x is argument that was passed through register and the
      first argument to f is the same register then the second argument is clobbered
[ ]   non-inlined
[ ]   inlined
[ ] optimize return pattern:
       mov qword[rbp-8],r15
       mov rax,qword[rbp-8]
       pop rbp
       ret
    to
       mov rax,r15
       pop rbp
       ret
[ ] optimize stack adjustment between calls
      call bar
      add rsp,40
      sub rsp,24
      call foo
[ ] fix 'cmp' two constants case
[ ] toc.allocate_named_register_or_break: if allocated then tell where
[ ] toc.add_field: if defined tell where
[ ] toc.add_function: if defined tell where
[ ] toc.add_var: if defined tell where
[ ] multiple return values assignment: var a,b=foo()  a,b=foo()
[ ] examine expression, expr_ops_list, stmt_call relation
[ ] token.compile assumes is_str is field
[ ]   review fragile implementation
[ ] negated subexpression. i.e. 'not (a=1 and b=2)'
[ ] why is the binary so big although in-line is turned off in make.sh?
[ ] tokenizer to keep track of line-number instead of counting it at every call
[ ] make sub lists taking in account precedence of 'and' over 'or'
      i.e. 'a or b and c or d' -> 'a or (b and c) or d'
[ ] type size{value} var s=size{1} s=2
[ ] type point{x,y} var p=point{1,2} p.x=1 p=2
[ ] var points=point[10] where points contains length of array and a pointer
[ ] clang-format everything for less dess code?
[ ] compile for pczero task
-------------------------------------------------------------------------------
[x] review fragile optimze_jumps_x
[-] stmt_if_branch.code_ can be value instead of unique_ptr
    -> circular reference?
[x] statement.parent can be removed
[x] experiments with linking to the standard c library and using printf
[x] review stmt_call
[x] when calling non-inlined functions the allocated register is pushed and popped
    although it hasn't been assigned. keep track of that in toc and optimize away
    the push/pop
[x] all allocated registers pushed before a call not necessary
[x] registers get clobbered in non-inlined functions
[x] rax gets clobbered in recursive functions
[x] non-inlined function calls
[x]   review
[-]     rbp=rsp before pushing arguments and at the beginning of functions
          can be optimized if nasm ident not hard-coded [rbp+...]
        example: "rbp" or "rsp" as argument to toc.nasm_ident(ident,"rbp",displacement)
          where displacement is used when pushing arguments to compensate for the moving rsp
[x] keyword 'inline'. func inline foo()...
[x] fix generated code of "if (a=1 and b=2) or (c=3 and d=4)"
        jne cmp_14_26
        jmp if_14_8_code
        cmp_14_26:
     possibly with a post processor of nasm file
        je if_14_8_code
        cmp_14_26:
[ ]   review fragile implementation
[x] fix generated code
        jmp cmp_13_26
        cmp_13_26:
[x] review the ugly 'if' code
[x] variant instead of stmt_if_bool_op_list extends stmt_if_bool_op
[x] assembler 64 bit code
[x] return statement for in-lined
[x] optimize:
        mov edi,dword[ebp+16]
        sub edi,1
        mov dword[ebp+16],edi
      to
        sub dword[ebp+16],1
[x] optimize: r=a+b+c+d
     ;  [12:11] r=a
        mov edi,dword[ebp+0]
        mov dword[ebp+16],edi
     ;  [12:13] r+b
        mov edi,dword[ebp+4]
        add dword[ebp+16],edi
     ;  [12:15] r+c
        mov edi,dword[ebp+8]
        add dword[ebp+16],edi
     ;  [12:17] r+d 
        mov edi,dword[ebp+12]
        add dword[ebp+16],edi
[x] stmt_assign_var.compile
      -> try evaluation with scratch register and evaluation without scratch register
         select the one that generates fewest instructions
