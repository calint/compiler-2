[ ] token.compile assumes is_str is field
[x] fix generated code of "if (a=1 and b=2) or (c=3 and d=4)"
        jne cmp_14_26
        jmp if_14_8_code
        cmp_14_26:
     possibly with a post processor of nasm file
        je if_14_8_code
        cmp_14_26:
[ ]   review fragile implementation
[x] fix generated code
        jmp cmp_13_26
        cmp_13_26:
[ ]   review fragile implementation
[ ] short-hand boolean expression i.e. if a or b
[x] review the ugly 'if' code
[x] variant instead of stmt_if_bool_op_list extends stmt_if_bool_op
[ ] negated subexpression. i.e. 'not (a=1 and b=2)'
[ ] non-inlined function calls
[ ] why is the binary so big although in-line is turned off in make.sh?
[ ] tokenizer to keep track of line-number instead of counting it at every call
[ ] implement division op
[ ] assembler 64 bit code
[ ] make sub lists taking in account precedence of 'and' over 'or'
      i.e. 'a or b and c or d' -> 'a or (b and c) or d'
[ ] return statement
[ ] op shift left and right
[x] optimize:
        mov edi,dword[ebp+16]
        sub edi,1
        mov dword[ebp+16],edi
      to
        sub dword[ebp+16],1
[x] optimize: r=a+b+c+d
     ;  [12:11] r=a
        mov edi,dword[ebp+0]
        mov dword[ebp+16],edi
     ;  [12:13] r+b
        mov edi,dword[ebp+4]
        add dword[ebp+16],edi
     ;  [12:15] r+c
        mov edi,dword[ebp+8]
        add dword[ebp+16],edi
     ;  [12:17] r+d 
        mov edi,dword[ebp+12]
        add dword[ebp+16],edi
[x] stmt_assign_var.compile see comments -> try both and select the one that generates fewest instructions
[ ] type point{x,y} var p=point{1,2} p.x=1
[ ] compile for pczero task
[ ] var points=point[10] where points contains length of array and a pointer
