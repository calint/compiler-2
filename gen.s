;
; generated by baz
;

DEFAULT REL

section .bss
stk resd 131072
stk.end:

true equ 1
false equ 0

section .data

section .text
bits 64
global _start
_start:
mov rsp,stk.end
; program
;[22:1] # size: 4320
main:
;   [43:5] var worlds : world[2]
;   [43:9] worlds: world[2] @ qword [rsp - 8640]
;   [43:9] clear array 2 * 4320 B = 8640 B
;   [43:5] allocate named register 'rdi'
;   [43:5] allocate named register 'rcx'
;   [43:5] allocate named register 'rax'
    lea rdi, [rsp - 8640]
    mov rcx, 8640
    xor rax, rax
    rep stosb
;   [43:5] free named register 'rax'
;   [43:5] free named register 'rcx'
;   [43:5] free named register 'rdi'
;   [44:5] baz(worlds)
;   [38:6] baz(wld : world[]) 
    baz_44_5:
;       [44:5] alias wld -> worlds  (lea: , len: 0)
;       [39:5] bar(wld[1].locations)
;       [39:9] allocate scratch register -> r15
        lea r15, [rsp - 8640]
;       [39:9] allocate scratch register -> r14
;       [39:13] set array index
;       [39:13] 1
;       [39:13] 1
;       [39:13] r14 = 1
        mov r14, 1
;       [39:13] bounds check
        cmp r14, 2
;       [39:13] allocate scratch register -> r13
;       [39:13] line number
        mov r13, 39
        cmovge rbp, r13
;       [39:13] free scratch register 'r13'
        jge panic_bounds
        imul r14, 4320
        add r15, r14
;       [39:9] free scratch register 'r14'
        add r15, 8
;       [34:6] bar(locs : location[]) 
        bar_39_5_44_5:
;           [39:5] alias locs -> wld.locations  (lea: r15, len: 7)
;           [35:5] foo(locs[2].links[1])
;           [35:9] allocate scratch register -> r14
            lea r14, [rsp - 8632]
;           [35:9] allocate scratch register -> r13
;           [35:14] set array index
;           [35:14] 2
;           [35:14] 2
;           [35:14] r13 = 2
            mov r13, 2
;           [35:14] bounds check
            cmp r13, 7
;           [35:14] allocate scratch register -> r12
;           [35:14] line number
            mov r12, 35
            cmovge rbp, r12
;           [35:14] free scratch register 'r12'
            jge panic_bounds
            imul r13, 616
            add r14, r13
;           [35:9] free scratch register 'r13'
;           [35:9] allocate scratch register -> r13
;           [35:23] set array index
;           [35:23] 1
;           [35:23] 1
;           [35:23] r13 = 1
            mov r13, 1
;           [35:23] bounds check
            cmp r13, 8
;           [35:23] allocate scratch register -> r12
;           [35:23] line number
            mov r12, 35
            cmovge rbp, r12
;           [35:23] free scratch register 'r12'
            jge panic_bounds
            imul r13, 69
            add r14, r13
;           [35:9] free scratch register 'r13'
            add r14, 64
;           [28:6] foo(lnk : link) 
            foo_35_5_39_5_44_5:
;               [35:5] alias lnk -> locs.links  (lea: r14, len: 8)
;               [29:5] lnk.loc = 2
;               [29:15] 2
;               [29:15] 2
;               [29:15] dword [r14 + 65] = 2
                mov dword [r14 + 65], 2
;               [30:5] lnk.name_len = 1
;               [30:20] 1
;               [30:20] 1
;               [30:20] byte [r14 + 64] = 1
                mov byte [r14 + 64], 1
;               [31:5] lnk.name[0] = 0x61
;               [31:5] allocate scratch register -> r13
;               [31:14] set array index
;               [31:14] 0
;               [31:14] 0
;               [31:14] r13 = 0
                mov r13, 0
;               [31:14] bounds check
                cmp r13, 64
;               [31:14] allocate scratch register -> r12
;               [31:14] line number
                mov r12, 31
                cmovge rbp, r12
;               [31:14] free scratch register 'r12'
                jge panic_bounds
;               [31:19] 0x61
;               [31:19] 0x61
;               [31:19] byte [rsp + r13 - 8568] = 0x61
                mov byte [rsp + r13 - 8568], 0x61
;               [31:5] free scratch register 'r13'
;               [31:24] # 'a'
;               [35:5] free scratch register 'r14'
            foo_35_5_39_5_44_5_end:
;           [39:5] free scratch register 'r15'
        bar_39_5_44_5_end:
    baz_44_5_end:
    ; system call: exit 0
    mov rax, 60
    mov rdi, 0
    syscall

panic_bounds:
;   print message to stderr
    mov rax, 1
    mov rdi, 2
    lea rsi, [msg_panic]
    mov rdx, msg_panic_len
    syscall
;   line number is in `rbp`
    mov rax, rbp
;   convert to string
    lea rdi, [num_buffer + 19]
    mov byte [rdi], 10
    dec rdi
    mov rcx, 10
.convert_loop:
    xor rdx, rdx
    div rcx
    add dl, '0'
    mov [rdi], dl
    dec rdi
    test rax, rax
    jnz .convert_loop
    inc rdi
;   print line number to stderr
    mov rax, 1
    mov rsi, rdi
    lea rdx, [num_buffer + 20]
    sub rdx, rdi
    mov rdi, 2
    syscall
;   exit with error code 255
    mov rax, 60
    mov rdi, 255
    syscall
section .rodata
    msg_panic: db 'panic: bounds at line '
    msg_panic_len equ $ - msg_panic
section .bss
    num_buffer: resb 21

; max scratch registers in use: 4
;            max frames in use: 8
;               max stack size: 8640 B
