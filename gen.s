;
; generated by baz
;

DEFAULT REL

section .bss
stk resd 131072
stk.end:

true equ 1
false equ 0

section .data
;[1:1] field nl_str = "\n"
nl_str: db '', 10,''
nl_str.len equ $ - nl_str

section .text
bits 64
global _start
_start:
mov rsp,stk.end
;
; program
;
;[56:1] str : 128 B    fields: 
;[56:1]       name :  size :  offset :  array? : array size
;[56:1]       size :     1 :       0 :      no :           
;[56:1]      chars :   127 :       1 :     yes :        127

;[61:1] world : 256 B    fields: 
;[61:1]       name :  size :  offset :  array? : array size
;[61:1]       name :   128 :       0 :      no :           
;[61:1]       note :   128 :     128 :      no :           

main:
;   [71:5] var wlds : world[2]
;   [71:9] wlds: world[2] @ byte [rsp - 512]
;   [71:9] clear array 2 * 256 B = 512 B
;   [71:5] allocate named register 'rdi'
;   [71:5] allocate named register 'rcx'
;   [71:5] allocate named register 'rax'
    lea rdi, [rsp - 512]
    mov rcx, 512
    xor rax, rax
    rep stosb
;   [71:5] free named register 'rax'
;   [71:5] free named register 'rcx'
;   [71:5] free named register 'rdi'
;   [72:5] wlds[0].note.size = 1
;   [72:5] allocate scratch register -> r15
    lea r15, [rsp - 512]
;   [72:5] allocate scratch register -> r14
;   [72:10] set array index
;   [72:10] 0
;   [72:10] 0
;   [72:10] 0
    mov r14, 0
;   [72:10] bounds check
    cmp r14, 2
;   [72:10] allocate scratch register -> r13
;   [72:10] line number
    mov r13, 72
    cmovge rbp, r13
;   [72:10] free scratch register 'r13'
    jge panic_bounds
    shl r14, 8
    add r15, r14
;   [72:5] free scratch register 'r14'
;   [72:25] 1
;   [72:25] 1
;   [72:25] 1
    mov byte [r15 + 128], 1
;   [72:5] free scratch register 'r15'
;   [73:5] wlds[1].note.size = 2
;   [73:5] allocate scratch register -> r15
    lea r15, [rsp - 512]
;   [73:5] allocate scratch register -> r14
;   [73:10] set array index
;   [73:10] 1
;   [73:10] 1
;   [73:10] 1
    mov r14, 1
;   [73:10] bounds check
    cmp r14, 2
;   [73:10] allocate scratch register -> r13
;   [73:10] line number
    mov r13, 73
    cmovge rbp, r13
;   [73:10] free scratch register 'r13'
    jge panic_bounds
    shl r14, 8
    add r15, r14
;   [73:5] free scratch register 'r14'
;   [73:25] 2
;   [73:25] 2
;   [73:25] 2
    mov byte [r15 + 128], 2
;   [73:5] free scratch register 'r15'
;   [75:5] foo(wlds[0], wlds[1])
;   [75:9] allocate scratch register -> r15
    lea r15, [rsp - 512]
;   [75:9] allocate scratch register -> r14
;   [75:14] set array index
;   [75:14] 0
;   [75:14] 0
;   [75:14] 0
    mov r14, 0
;   [75:14] bounds check
    cmp r14, 2
;   [75:14] allocate scratch register -> r13
;   [75:14] line number
    mov r13, 75
    cmovge rbp, r13
;   [75:14] free scratch register 'r13'
    jge panic_bounds
    shl r14, 8
    add r15, r14
;   [75:9] free scratch register 'r14'
;   [75:18] allocate scratch register -> r14
    lea r14, [rsp - 512]
;   [75:18] allocate scratch register -> r13
;   [75:23] set array index
;   [75:23] 1
;   [75:23] 1
;   [75:23] 1
    mov r13, 1
;   [75:23] bounds check
    cmp r13, 2
;   [75:23] allocate scratch register -> r12
;   [75:23] line number
    mov r12, 75
    cmovge rbp, r12
;   [75:23] free scratch register 'r12'
    jge panic_bounds
    shl r13, 8
    add r14, r13
;   [75:18] free scratch register 'r13'
;   [66:6] foo(w1 : world, w2 : world) 
    foo_75_5:
;       [75:5] alias w1 -> wlds  (lea: r15, len: 2)
;       [75:5] alias w2 -> wlds  (lea: r14, len: 2)
;       [67:5] assert(w1.note.size + w2.note.size == 3)
;       [67:12] allocate scratch register -> r13
;       [67:12] w1.note.size + w2.note.size == 3
;       [67:12] ? w1.note.size + w2.note.size == 3
;       [67:12] ? w1.note.size + w2.note.size == 3
        cmp_67_12_75_5:
;       [67:12] allocate scratch register -> r12
;           [67:12] w1.note.size + w2.note.size
;           [67:12] w1.note.size
;           [67:12] allocate scratch register -> r11
            mov r11, r15
            movsx r12, byte [r11 + 128]
;           [67:12] free scratch register 'r11'
;           [67:27] r12 + w2.note.size
;           [67:27] allocate scratch register -> r11
;           [67:27] w2.note.size
;           [67:27] allocate scratch register -> r10
            mov r10, r14
            movsx r11, byte [r10 + 128]
;           [67:27] free scratch register 'r10'
            add r12, r11
;           [67:27] free scratch register 'r11'
        cmp r12, 3
;       [67:12] free scratch register 'r12'
        jne bool_false_67_12_75_5
        jmp bool_true_67_12_75_5
        bool_true_67_12_75_5:
        mov r13, true
        jmp bool_end_67_12_75_5
        bool_false_67_12_75_5:
        mov r13, false
        bool_end_67_12_75_5:
;       [9:6] assert(expr : bool) 
        assert_67_5_75_5:
;           [67:5] alias expr -> r13  (lea: , len: 0)
            if_9_29_67_5_75_5:
;           [9:29] ? not expr
;           [9:29] ? not expr
            cmp_9_29_67_5_75_5:
            test r13, r13
            jne if_9_26_67_5_75_5_end
            jmp if_9_29_67_5_75_5_code
            if_9_29_67_5_75_5_code:
;               [9:38] exit(1)
;               [9:43] allocate named register 'rdi'
                mov rdi, 1
;               [3:6] exit(v : reg_rdi) 
                exit_9_38_67_5_75_5:
;                   [9:38] alias v -> rdi  (lea: , len: 0)
;                   [4:5] mov(rax, 60)
                    mov rax, 60
;                   [4:19] # exit system call
;                   [5:5] mov(rdi, v)
;                   [5:19] # return code
;                   [6:5] syscall()
                    syscall
;                   [9:38] free named register 'rdi'
                exit_9_38_67_5_75_5_end:
            if_9_26_67_5_75_5_end:
;           [67:5] free scratch register 'r13'
        assert_67_5_75_5_end:
;       [75:5] free scratch register 'r14'
;       [75:5] free scratch register 'r15'
    foo_75_5_end:
    ; system call: exit 0
    mov rax, 60
    mov rdi, 0
    syscall

panic_bounds:
;   print message to stderr
    mov rax, 1
    mov rdi, 2
    lea rsi, [msg_panic]
    mov rdx, msg_panic_len
    syscall
;   line number is in `rbp`
    mov rax, rbp
;   convert to string
    lea rdi, [num_buffer + 19]
    mov byte [rdi], 10
    dec rdi
    mov rcx, 10
.convert_loop:
    xor rdx, rdx
    div rcx
    add dl, '0'
    mov [rdi], dl
    dec rdi
    test rax, rax
    jnz .convert_loop
    inc rdi
;   print line number to stderr
    mov rax, 1
    mov rsi, rdi
    lea rdx, [num_buffer + 20]
    sub rdx, rdi
    mov rdi, 2
    syscall
;   exit with error code 255
    mov rax, 60
    mov rdi, 255
    syscall
section .rodata
    msg_panic: db 'panic: bounds at line '
    msg_panic_len equ $ - msg_panic
section .bss
    num_buffer: resb 21

; max scratch registers in use: 6
;            max frames in use: 9
;               max stack size: 512 B
