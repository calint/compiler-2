;
; generated by baz
;

DEFAULT REL

section .bss
stk resd 131072
stk.end:

true equ 1
false equ 0

section .data

section .text
bits 64
global _start
_start:
mov rsp,stk.end
; program
main:
;   [29:5] var worlds : world[2]
;   [29:9] worlds: world[2] @ qword [rsp - 80]
;   [29:9] clear array 2 * 40 B = 80 B
;   [29:5] allocate named register 'rdi'
;   [29:5] allocate named register 'rcx'
;   [29:5] allocate named register 'rax'
    lea rdi, [rsp - 80]
    mov rcx, 80
    xor rax, rax
    rep stosb
;   [29:5] free named register 'rax'
;   [29:5] free named register 'rcx'
;   [29:5] free named register 'rdi'
;   [30:5] foo(worlds[1].flgs[2].data)
;   [30:9] allocate scratch register -> r15
;   [30:9] worlds[1].flgs[2].data
;   [30:9] worlds[1].flgs[2].data
;   [30:9] r15 = worlds[1].flgs[2].data
;   [30:9] worlds[1].flgs[2].data
;   [30:9] allocate scratch register -> r14
    lea r14, [rsp - 80]
;   [30:9] allocate scratch register -> r13
;   [30:16] set array index
;   [30:16] 1
;   [30:16] 1
;   [30:16] r13 = 1
    mov r13, 1
;   [30:16] bounds check
    cmp r13, 2
;   [30:16] allocate scratch register -> r12
;   [30:16] line number
    mov r12, 30
    cmovge rbp, r12
;   [30:16] free scratch register 'r12'
    jge panic_bounds
    imul r13, 40
    add r14, r13
;   [30:9] free scratch register 'r13'
;   [30:9] allocate scratch register -> r13
;   [30:24] set array index
;   [30:24] 2
;   [30:24] 2
;   [30:24] r13 = 2
    mov r13, 2
;   [30:24] bounds check
    cmp r13, 4
;   [30:24] allocate scratch register -> r12
;   [30:24] line number
    mov r12, 30
    cmovge rbp, r12
;   [30:24] free scratch register 'r12'
    jge panic_bounds
    shl r13, 3
    add r14, r13
;   [30:9] free scratch register 'r13'
    add r14, 8
    movsx r15, byte [r14]
;   [30:9] free scratch register 'r14'
;   [20:6] foo(data : i8[]) 
    foo_30_5:
;       [30:5] alias data -> r15  (lea: , len: 0)
;       [21:5] data[2] = 0x10
;       [21:5] allocate scratch register -> r14
;       [21:10] set array index
;       [21:10] 2
;       [21:10] 2
;       [21:10] r14 = 2
        mov r14, 2
;       [21:10] bounds check
        cmp r14, 0
;       [21:10] allocate scratch register -> r13
;       [21:10] line number
        mov r13, 21
        cmovge rbp, r13
;       [21:10] free scratch register 'r13'
        jge panic_bounds
;       [21:15] 0x10
;       [21:15] 0x10
;       [21:15] qword [rsp + r14 * 8 - 0] = 0x10
        mov qword [rsp + r14 * 8 - 0], 0x10
;       [21:5] free scratch register 'r14'
;       [30:5] free scratch register 'r15'
    foo_30_5_end:
;   [31:5] bar(worlds[1].flgs[1])
;   [31:9] allocate scratch register -> r15
    lea r15, [rsp - 80]
;   [31:9] allocate scratch register -> r14
;   [31:16] set array index
;   [31:16] 1
;   [31:16] 1
;   [31:16] r14 = 1
    mov r14, 1
;   [31:16] bounds check
    cmp r14, 2
;   [31:16] allocate scratch register -> r13
;   [31:16] line number
    mov r13, 31
    cmovge rbp, r13
;   [31:16] free scratch register 'r13'
    jge panic_bounds
    imul r14, 40
    add r15, r14
;   [31:9] free scratch register 'r14'
;   [31:9] allocate scratch register -> r14
;   [31:24] set array index
;   [31:24] 1
;   [31:24] 1
;   [31:24] r14 = 1
    mov r14, 1
;   [31:24] bounds check
    cmp r14, 4
;   [31:24] allocate scratch register -> r13
;   [31:24] line number
    mov r13, 31
    cmovge rbp, r13
;   [31:24] free scratch register 'r13'
    jge panic_bounds
;   [24:6] bar(flg : flags) 
    bar_31_5:
;       [31:5] alias flg -> worlds.flgs  (lea: r15 + r14 * 8 + 8, len: 4)
;       [25:5] flg.data[2] = 0x10
;       [25:5] allocate scratch register -> r13
        lea r13, [r15 + r14 * 8 + 8]
;       [25:5] allocate scratch register -> r12
;       [25:14] set array index
;       [25:14] 2
;       [25:14] 2
;       [25:14] r12 = 2
        mov r12, 2
;       [25:14] bounds check
        cmp r12, 8
;       [25:14] allocate scratch register -> r11
;       [25:14] line number
        mov r11, 25
        cmovge rbp, r11
;       [25:14] free scratch register 'r11'
        jge panic_bounds
;       [25:19] 0x10
;       [25:19] 0x10
;       [25:19] byte [r13 + r12 + 0] = 0x10
        mov byte [r13 + r12 + 0], 0x10
;       [25:5] free scratch register 'r12'
;       [25:5] free scratch register 'r13'
;       [31:5] free scratch register 'r14'
;       [31:5] free scratch register 'r15'
    bar_31_5_end:
    ; system call: exit 0
    mov rax, 60
    mov rdi, 0
    syscall

panic_bounds:
;   print message to stderr
    mov rax, 1
    mov rdi, 2
    lea rsi, [msg_panic]
    mov rdx, msg_panic_len
    syscall
;   line number is in `rbp`
    mov rax, rbp
;   convert to string
    lea rdi, [num_buffer + 19]
    mov byte [rdi], 10
    dec rdi
    mov rcx, 10
.convert_loop:
    xor rdx, rdx
    div rcx
    add dl, '0'
    mov [rdi], dl
    dec rdi
    test rax, rax
    jnz .convert_loop
    inc rdi
;   print line number to stderr
    mov rax, 1
    mov rsi, rdi
    lea rdx, [num_buffer + 20]
    sub rdx, rdi
    mov rdi, 2
    syscall
;   exit with error code 255
    mov rax, 60
    mov rdi, 255
    syscall
section .rodata
    msg_panic: db 'panic: bounds at line '
    msg_panic_len equ $ - msg_panic
section .bss
    num_buffer: resb 21

; max scratch registers in use: 5
;            max frames in use: 4
;               max stack size: 80 B
