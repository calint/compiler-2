;
; generated by baz
;

DEFAULT REL

section .bss
stk resd 131072
stk.end:

true equ 1
false equ 0

section .data

section .text
bits 64
global _start
_start:
mov rsp,stk.end
;
; program
;
;[10:1] point : 16 B    fields: 
;[10:1]       name :  offset :    size :  array? : array size
;[10:1]          x :       0 :       8 :      no :           
;[10:1]          y :       8 :       8 :      no :           

;[11:1] object : 20 B    fields: 
;[11:1]       name :  offset :    size :  array? : array size
;[11:1]        pos :       0 :      16 :      no :           
;[11:1]      color :      16 :       4 :      no :           

main:
;   [14:5] var o1 : object = {{0xe, 0xd}, 0xff0000}
;   [14:9] o1: object (20 B @ qword [rsp - 20])
;   [14:9] o1 ={{0xe, 0xd}, 0xff0000}
    mov qword [rsp - 20], 0xe
    mov qword [rsp - 12], 0xd
    mov dword [rsp - 4], 0xff0000
;   [15:5] var o2 : object = {{0, 0}, 0}
;   [15:9] o2: object (20 B @ qword [rsp - 40])
;   [15:9] o2 ={{0, 0}, 0}
    mov qword [rsp - 40], 0
    mov qword [rsp - 32], 0
    mov dword [rsp - 24], 0
;   [16:5] o2 = o1
;   [16:10] allocate named register 'rsi'
;   [16:10] allocate named register 'rdi'
;   [16:10] allocate named register 'rcx'
    lea rsi, [rsp - 20]
    lea rdi, [rsp - 40]
    mov rcx, 20
    rep movsb
;   [16:10] free named register 'rcx'
;   [16:10] free named register 'rdi'
;   [16:10] free named register 'rsi'
;   [17:5] assert(o2.pos.x == 0xe)
;   [17:12] allocate scratch register -> r15
;   [17:12] o2.pos.x == 0xe
;   [17:12] ? o2.pos.x == 0xe
;   [17:12] ? o2.pos.x == 0xe
    cmp_17_12:
    cmp qword [rsp - 40], 0xe
    jne bool_false_17_12
    jmp bool_true_17_12
    bool_true_17_12:
    mov r15, true
    jmp bool_end_17_12
    bool_false_17_12:
    mov r15, false
    bool_end_17_12:
;   [7:6] assert(expr : bool) 
    assert_17_5:
;       [17:5] alias expr -> r15  (lea: , len: 0)
        if_8_8_17_5:
;       [8:8] ? not expr
;       [8:8] ? not expr
        cmp_8_8_17_5:
        test r15, r15
        jne if_8_5_17_5_end
        jmp if_8_8_17_5_code
        if_8_8_17_5_code:
;           [8:17] exit(1)
;           [8:22] allocate named register 'rdi'
            mov rdi, 1
;           [1:6] exit(v : reg_rdi) 
            exit_8_17_17_5:
;               [8:17] alias v -> rdi  (lea: , len: 0)
;               [2:5] mov(rax, 60)
;                   [2:14] 60
;                   [2:14] 60
;                   [2:14] 60
                    mov rax, 60
;               [2:19] # exit system call
;               [3:5] mov(rdi, v)
;                   [3:14] v
;                   [3:14] v
;                   [3:14] v
;               [3:19] # return code
;               [4:5] syscall()
                syscall
;               [8:17] free named register 'rdi'
            exit_8_17_17_5_end:
        if_8_5_17_5_end:
;       [17:5] free scratch register 'r15'
    assert_17_5_end:
;   [18:5] assert(o2.pos.y == 0xd)
;   [18:12] allocate scratch register -> r15
;   [18:12] o2.pos.y == 0xd
;   [18:12] ? o2.pos.y == 0xd
;   [18:12] ? o2.pos.y == 0xd
    cmp_18_12:
    cmp qword [rsp - 32], 0xd
    jne bool_false_18_12
    jmp bool_true_18_12
    bool_true_18_12:
    mov r15, true
    jmp bool_end_18_12
    bool_false_18_12:
    mov r15, false
    bool_end_18_12:
;   [7:6] assert(expr : bool) 
    assert_18_5:
;       [18:5] alias expr -> r15  (lea: , len: 0)
        if_8_8_18_5:
;       [8:8] ? not expr
;       [8:8] ? not expr
        cmp_8_8_18_5:
        test r15, r15
        jne if_8_5_18_5_end
        jmp if_8_8_18_5_code
        if_8_8_18_5_code:
;           [8:17] exit(1)
;           [8:22] allocate named register 'rdi'
            mov rdi, 1
;           [1:6] exit(v : reg_rdi) 
            exit_8_17_18_5:
;               [8:17] alias v -> rdi  (lea: , len: 0)
;               [2:5] mov(rax, 60)
;                   [2:14] 60
;                   [2:14] 60
;                   [2:14] 60
                    mov rax, 60
;               [2:19] # exit system call
;               [3:5] mov(rdi, v)
;                   [3:14] v
;                   [3:14] v
;                   [3:14] v
;               [3:19] # return code
;               [4:5] syscall()
                syscall
;               [8:17] free named register 'rdi'
            exit_8_17_18_5_end:
        if_8_5_18_5_end:
;       [18:5] free scratch register 'r15'
    assert_18_5_end:
;   [19:5] assert(o2.color == 0xff0000)
;   [19:12] allocate scratch register -> r15
;   [19:12] o2.color == 0xff0000
;   [19:12] ? o2.color == 0xff0000
;   [19:12] ? o2.color == 0xff0000
    cmp_19_12:
    cmp dword [rsp - 24], 0xff0000
    jne bool_false_19_12
    jmp bool_true_19_12
    bool_true_19_12:
    mov r15, true
    jmp bool_end_19_12
    bool_false_19_12:
    mov r15, false
    bool_end_19_12:
;   [7:6] assert(expr : bool) 
    assert_19_5:
;       [19:5] alias expr -> r15  (lea: , len: 0)
        if_8_8_19_5:
;       [8:8] ? not expr
;       [8:8] ? not expr
        cmp_8_8_19_5:
        test r15, r15
        jne if_8_5_19_5_end
        jmp if_8_8_19_5_code
        if_8_8_19_5_code:
;           [8:17] exit(1)
;           [8:22] allocate named register 'rdi'
            mov rdi, 1
;           [1:6] exit(v : reg_rdi) 
            exit_8_17_19_5:
;               [8:17] alias v -> rdi  (lea: , len: 0)
;               [2:5] mov(rax, 60)
;                   [2:14] 60
;                   [2:14] 60
;                   [2:14] 60
                    mov rax, 60
;               [2:19] # exit system call
;               [3:5] mov(rdi, v)
;                   [3:14] v
;                   [3:14] v
;                   [3:14] v
;               [3:19] # return code
;               [4:5] syscall()
                syscall
;               [8:17] free named register 'rdi'
            exit_8_17_19_5_end:
        if_8_5_19_5_end:
;       [19:5] free scratch register 'r15'
    assert_19_5_end:
;   [21:5] var pt : point = { 0xab, 0xba }
;   [21:9] pt: point (16 B @ qword [rsp - 56])
;   [21:9] pt ={ 0xab, 0xba }
    mov qword [rsp - 56], 0xab
    mov qword [rsp - 48], 0xba
;   [22:5] o2.pos = pt
;   [22:14] allocate named register 'rsi'
;   [22:14] allocate named register 'rdi'
;   [22:14] allocate named register 'rcx'
    lea rsi, [rsp - 56]
    lea rdi, [rsp - 40]
    mov rcx, 2
    rep movsq
;   [22:14] free named register 'rcx'
;   [22:14] free named register 'rdi'
;   [22:14] free named register 'rsi'
;   [23:5] assert(o2.pos.x == 0xab)
;   [23:12] allocate scratch register -> r15
;   [23:12] o2.pos.x == 0xab
;   [23:12] ? o2.pos.x == 0xab
;   [23:12] ? o2.pos.x == 0xab
    cmp_23_12:
    cmp qword [rsp - 40], 0xab
    jne bool_false_23_12
    jmp bool_true_23_12
    bool_true_23_12:
    mov r15, true
    jmp bool_end_23_12
    bool_false_23_12:
    mov r15, false
    bool_end_23_12:
;   [7:6] assert(expr : bool) 
    assert_23_5:
;       [23:5] alias expr -> r15  (lea: , len: 0)
        if_8_8_23_5:
;       [8:8] ? not expr
;       [8:8] ? not expr
        cmp_8_8_23_5:
        test r15, r15
        jne if_8_5_23_5_end
        jmp if_8_8_23_5_code
        if_8_8_23_5_code:
;           [8:17] exit(1)
;           [8:22] allocate named register 'rdi'
            mov rdi, 1
;           [1:6] exit(v : reg_rdi) 
            exit_8_17_23_5:
;               [8:17] alias v -> rdi  (lea: , len: 0)
;               [2:5] mov(rax, 60)
;                   [2:14] 60
;                   [2:14] 60
;                   [2:14] 60
                    mov rax, 60
;               [2:19] # exit system call
;               [3:5] mov(rdi, v)
;                   [3:14] v
;                   [3:14] v
;                   [3:14] v
;               [3:19] # return code
;               [4:5] syscall()
                syscall
;               [8:17] free named register 'rdi'
            exit_8_17_23_5_end:
        if_8_5_23_5_end:
;       [23:5] free scratch register 'r15'
    assert_23_5_end:
;   [24:5] assert(o2.pos.y == 0xba)
;   [24:12] allocate scratch register -> r15
;   [24:12] o2.pos.y == 0xba
;   [24:12] ? o2.pos.y == 0xba
;   [24:12] ? o2.pos.y == 0xba
    cmp_24_12:
    cmp qword [rsp - 32], 0xba
    jne bool_false_24_12
    jmp bool_true_24_12
    bool_true_24_12:
    mov r15, true
    jmp bool_end_24_12
    bool_false_24_12:
    mov r15, false
    bool_end_24_12:
;   [7:6] assert(expr : bool) 
    assert_24_5:
;       [24:5] alias expr -> r15  (lea: , len: 0)
        if_8_8_24_5:
;       [8:8] ? not expr
;       [8:8] ? not expr
        cmp_8_8_24_5:
        test r15, r15
        jne if_8_5_24_5_end
        jmp if_8_8_24_5_code
        if_8_8_24_5_code:
;           [8:17] exit(1)
;           [8:22] allocate named register 'rdi'
            mov rdi, 1
;           [1:6] exit(v : reg_rdi) 
            exit_8_17_24_5:
;               [8:17] alias v -> rdi  (lea: , len: 0)
;               [2:5] mov(rax, 60)
;                   [2:14] 60
;                   [2:14] 60
;                   [2:14] 60
                    mov rax, 60
;               [2:19] # exit system call
;               [3:5] mov(rdi, v)
;                   [3:14] v
;                   [3:14] v
;                   [3:14] v
;               [3:19] # return code
;               [4:5] syscall()
                syscall
;               [8:17] free named register 'rdi'
            exit_8_17_24_5_end:
        if_8_5_24_5_end:
;       [24:5] free scratch register 'r15'
    assert_24_5_end:
;   [26:5] var objs : object[10]
;   [26:9] objs: object[10] (20 B @ qword [rsp - 256])
;   [26:9] clear 10 * 20 B = 200 B
;   [26:5] allocate named register 'rcx'
;   [26:5] allocate named register 'rdi'
;   [26:5] allocate named register 'rax'
    mov rcx, 25
    lea rdi, [rsp - 256]
    xor rax, rax
    rep stosq
;   [26:5] free named register 'rax'
;   [26:5] free named register 'rdi'
;   [26:5] free named register 'rcx'
;   [27:5] objs[1].pos.y = 0xab
;   [27:5] allocate scratch register -> r15
    lea r15, [rsp - 256]
;   [27:5] allocate scratch register -> r14
;   [27:10] set array index
;   [27:10] 1
;   [27:10] 1
;   [27:10] 1
    mov r14, 1
;   [27:10] bounds check
;   [27:10] allocate scratch register -> r13
;   [27:10] line number
    mov r13, 27
    test r14, r14
    cmovs rbp, r13
    js panic_bounds
    cmp r14, 10
    cmovge rbp, r13
    jge panic_bounds
;   [27:10] free scratch register 'r13'
    imul r14, 20
    add r15, r14
;   [27:5] free scratch register 'r14'
;   [27:21] 0xab
;   [27:21] 0xab
;   [27:21] 0xab
    mov qword [r15 + 8], 0xab
;   [27:5] free scratch register 'r15'
;   [29:5] objs[2] = objs[1]
;   [29:5] allocate scratch register -> r15
    lea r15, [rsp - 256]
;   [29:5] allocate scratch register -> r14
;   [29:10] set array index
;   [29:10] 2
;   [29:10] 2
;   [29:10] 2
    mov r14, 2
;   [29:10] bounds check
;   [29:10] allocate scratch register -> r13
;   [29:10] line number
    mov r13, 29
    test r14, r14
    cmovs rbp, r13
    js panic_bounds
    cmp r14, 10
    cmovge rbp, r13
    jge panic_bounds
;   [29:10] free scratch register 'r13'
    imul r14, 20
    add r15, r14
;   [29:5] free scratch register 'r14'
;   [29:15] allocate scratch register -> r14
    lea r14, [rsp - 256]
;   [29:15] allocate scratch register -> r13
;   [29:20] set array index
;   [29:20] 1
;   [29:20] 1
;   [29:20] 1
    mov r13, 1
;   [29:20] bounds check
;   [29:20] allocate scratch register -> r12
;   [29:20] line number
    mov r12, 29
    test r13, r13
    cmovs rbp, r12
    js panic_bounds
    cmp r13, 10
    cmovge rbp, r12
    jge panic_bounds
;   [29:20] free scratch register 'r12'
    imul r13, 20
    add r14, r13
;   [29:15] free scratch register 'r13'
;   [29:15] allocate named register 'rsi'
;   [29:15] allocate named register 'rdi'
;   [29:15] allocate named register 'rcx'
    lea rsi, [r14]
    lea rdi, [r15]
    mov rcx, 20
    rep movsb
;   [29:15] free named register 'rcx'
;   [29:15] free named register 'rdi'
;   [29:15] free named register 'rsi'
;   [29:15] free scratch register 'r14'
;   [29:5] free scratch register 'r15'
;   [30:5] assert(objs[2].pos.y == objs[1].pos.y)
;   [30:12] allocate scratch register -> r15
;   [30:12] objs[2].pos.y == objs[1].pos.y
;   [30:12] ? objs[2].pos.y == objs[1].pos.y
;   [30:12] ? objs[2].pos.y == objs[1].pos.y
    cmp_30_12:
;   [30:12] allocate scratch register -> r14
;       [30:12] objs[2].pos.y
;       [30:12] objs[2].pos.y
;       [30:12] allocate scratch register -> r13
        lea r13, [rsp - 256]
;       [30:12] allocate scratch register -> r12
;       [30:17] set array index
;       [30:17] 2
;       [30:17] 2
;       [30:17] 2
        mov r12, 2
;       [30:17] bounds check
;       [30:17] allocate scratch register -> r11
;       [30:17] line number
        mov r11, 30
        test r12, r12
        cmovs rbp, r11
        js panic_bounds
        cmp r12, 10
        cmovge rbp, r11
        jge panic_bounds
;       [30:17] free scratch register 'r11'
        imul r12, 20
        add r13, r12
;       [30:12] free scratch register 'r12'
        mov r14, qword [r13 + 8]
;       [30:12] free scratch register 'r13'
;   [30:29] allocate scratch register -> r13
;       [30:29] objs[1].pos.y
;       [30:29] objs[1].pos.y
;       [30:29] allocate scratch register -> r12
        lea r12, [rsp - 256]
;       [30:29] allocate scratch register -> r11
;       [30:34] set array index
;       [30:34] 1
;       [30:34] 1
;       [30:34] 1
        mov r11, 1
;       [30:34] bounds check
;       [30:34] allocate scratch register -> r10
;       [30:34] line number
        mov r10, 30
        test r11, r11
        cmovs rbp, r10
        js panic_bounds
        cmp r11, 10
        cmovge rbp, r10
        jge panic_bounds
;       [30:34] free scratch register 'r10'
        imul r11, 20
        add r12, r11
;       [30:29] free scratch register 'r11'
        mov r13, qword [r12 + 8]
;       [30:29] free scratch register 'r12'
    cmp r14, r13
;   [30:12] free scratch register 'r13'
;   [30:12] free scratch register 'r14'
    jne bool_false_30_12
    jmp bool_true_30_12
    bool_true_30_12:
    mov r15, true
    jmp bool_end_30_12
    bool_false_30_12:
    mov r15, false
    bool_end_30_12:
;   [7:6] assert(expr : bool) 
    assert_30_5:
;       [30:5] alias expr -> r15  (lea: , len: 0)
        if_8_8_30_5:
;       [8:8] ? not expr
;       [8:8] ? not expr
        cmp_8_8_30_5:
        test r15, r15
        jne if_8_5_30_5_end
        jmp if_8_8_30_5_code
        if_8_8_30_5_code:
;           [8:17] exit(1)
;           [8:22] allocate named register 'rdi'
            mov rdi, 1
;           [1:6] exit(v : reg_rdi) 
            exit_8_17_30_5:
;               [8:17] alias v -> rdi  (lea: , len: 0)
;               [2:5] mov(rax, 60)
;                   [2:14] 60
;                   [2:14] 60
;                   [2:14] 60
                    mov rax, 60
;               [2:19] # exit system call
;               [3:5] mov(rdi, v)
;                   [3:14] v
;                   [3:14] v
;                   [3:14] v
;               [3:19] # return code
;               [4:5] syscall()
                syscall
;               [8:17] free named register 'rdi'
            exit_8_17_30_5_end:
        if_8_5_30_5_end:
;       [30:5] free scratch register 'r15'
    assert_30_5_end:
    ; system call: exit 0
    mov rax, 60
    mov rdi, 0
    syscall

panic_bounds:
;   print message to stderr
    mov rax, 1
    mov rdi, 2
    lea rsi, [msg_panic]
    mov rdx, msg_panic_len
    syscall
;   line number is in `rbp`
    mov rax, rbp
;   convert to string
    lea rdi, [num_buffer + 19]
    mov byte [rdi], 10
    dec rdi
    mov rcx, 10
.convert_loop:
    xor rdx, rdx
    div rcx
    add dl, '0'
    mov [rdi], dl
    dec rdi
    test rax, rax
    jnz .convert_loop
    inc rdi
;   print line number to stderr
    mov rax, 1
    mov rsi, rdi
    lea rdx, [num_buffer + 20]
    sub rdx, rdi
    mov rdi, 2
    syscall
;   exit with error code 255
    mov rax, 60
    mov rdi, 255
    syscall
section .rodata
    msg_panic: db 'panic: bounds at line '
    msg_panic_len equ $ - msg_panic
section .bss
    num_buffer: resb 21

; max scratch registers in use: 6
;            max frames in use: 7
;               max stack size: 256 B
