;
; generated by baz
;

DEFAULT REL

section .bss
stk resd 131072
stk.end:

true equ 1
false equ 0

section .data
;[1:1] field hello = "hello world from baz\n"
hello: db 'hello world from baz', 10,''
hello.len equ $ - hello
;[2:1] field prompt1 = "enter name:\n"
prompt1: db 'enter name:', 10,''
prompt1.len equ $ - prompt1
;[3:1] field prompt2 = "that is not a name.\n"
prompt2: db 'that is not a name.', 10,''
prompt2.len equ $ - prompt2
;[4:1] field prompt3 = "hello "
prompt3: db 'hello '
prompt3.len equ $ - prompt3
;[5:1] field dot = "."
dot: db '.'
dot.len equ $ - dot
;[6:1] field nl = "\n"
nl: db '', 10,''
nl.len equ $ - nl

section .text
bits 64
global _start
_start:
mov rsp,stk.end
;
; program
;
;[8:1] # all functions are inlined
;[10:1] # arguments can be placed in specified register using `reg_...` syntax
;[18:1] # single statement blocks can ommit { ... }
;[39:1] # user types are defined using keyword `type`
;[41:1] # default type is `i64` and does not need to be specified
;[43:1] point : 16 B    fields: 
;[43:1]       name :  offset :    size :  array? : array size
;[43:1]          x :       0 :       8 :      no :           
;[43:1]          y :       8 :       8 :      no :           

;[45:1] object : 20 B    fields: 
;[45:1]       name :  offset :    size :  array? : array size
;[45:1]        pos :       0 :      16 :      no :           
;[45:1]      color :      16 :       4 :      no :           

;[47:1] world : 64 B    fields: 
;[47:1]       name :  offset :    size :  array? : array size
;[47:1]  locations :       0 :      64 :     yes :          8

;[49:1] # function arguments are equivalent to mutable references
;[56:1] # default argument type is `i64`
;[63:1] # return target is specified as a variable, in this case `res`
;[73:1] # array arguments are declared with type and []
main:
;   [80:5] var arr : i32[4]
;   [80:9] arr: i32[4] @ dword [rsp - 16]
;   [80:9] clear array 4 * 4 B = 16 B
;   [80:5] allocate named register 'rdi'
;   [80:5] allocate named register 'rcx'
;   [80:5] allocate named register 'rax'
    lea rdi, [rsp - 16]
    mov rcx, 16
    xor rax, rax
    rep stosb
;   [80:5] free named register 'rax'
;   [80:5] free named register 'rcx'
;   [80:5] free named register 'rdi'
;   [81:5] # arrays are initialized to 0
;   [83:5] var ix = 1
;   [83:9] ix: i64 @ qword [rsp - 24]
;   [83:9] ix =1
;   [83:14] 1
;   [83:14] 1
;   [83:14] 1
    mov qword [rsp - 24], 1
;   [85:5] arr[ix] = 2
;   [85:5] allocate scratch register -> r15
;   [85:9] set array index
;   [85:9] ix
;   [85:9] ix
;   [85:9] ix
    mov r15, qword [rsp - 24]
;   [85:9] bounds check
;   [85:9] allocate scratch register -> r14
;   [85:9] line number
    mov r14, 85
    test r15, r15
    cmovs rbp, r14
    js panic_bounds
    cmp r15, 4
    cmovge rbp, r14
    jge panic_bounds
;   [85:9] free scratch register 'r14'
;   [85:15] 2
;   [85:15] 2
;   [85:15] 2
    mov dword [rsp + r15 * 4 - 16], 2
;   [85:5] free scratch register 'r15'
;   [86:5] arr[ix + 1] = arr[ix]
;   [86:5] allocate scratch register -> r15
;   [86:9] set array index
;   [86:9] ix + 1
;   [86:9] ix + 1
;   [86:9] ix
    mov r15, qword [rsp - 24]
;   [86:14] r15 + 1
    add r15, 1
;   [86:9] bounds check
;   [86:9] allocate scratch register -> r14
;   [86:9] line number
    mov r14, 86
    test r15, r15
    cmovs rbp, r14
    js panic_bounds
    cmp r15, 4
    cmovge rbp, r14
    jge panic_bounds
;   [86:9] free scratch register 'r14'
;   [86:19] arr[ix]
;   [86:19] arr[ix]
;   [86:19] arr[ix]
;   [86:19] allocate scratch register -> r14
;   [86:23] set array index
;   [86:23] ix
;   [86:23] ix
;   [86:23] ix
    mov r14, qword [rsp - 24]
;   [86:23] bounds check
;   [86:23] allocate scratch register -> r13
;   [86:23] line number
    mov r13, 86
    test r14, r14
    cmovs rbp, r13
    js panic_bounds
    cmp r14, 4
    cmovge rbp, r13
    jge panic_bounds
;   [86:23] free scratch register 'r13'
;   [86:19] allocate scratch register -> r13
    mov r13d, dword [rsp + r14 * 4 - 16]
    mov dword [rsp + r15 * 4 - 16], r13d
;   [86:19] free scratch register 'r13'
;   [86:19] free scratch register 'r14'
;   [86:5] free scratch register 'r15'
;   [87:5] assert(arr[1] == 2)
;   [87:12] allocate scratch register -> r15
;   [87:12] arr[1] == 2
;   [87:12] ? arr[1] == 2
;   [87:12] ? arr[1] == 2
    cmp_87_12:
;   [87:12] allocate scratch register -> r14
;       [87:12] arr[1]
;       [87:12] arr[1]
;       [87:12] allocate scratch register -> r13
;       [87:16] set array index
;       [87:16] 1
;       [87:16] 1
;       [87:16] 1
        mov r13, 1
;       [87:16] bounds check
;       [87:16] allocate scratch register -> r12
;       [87:16] line number
        mov r12, 87
        test r13, r13
        cmovs rbp, r12
        js panic_bounds
        cmp r13, 4
        cmovge rbp, r12
        jge panic_bounds
;       [87:16] free scratch register 'r12'
        movsx r14, dword [rsp + r13 * 4 - 16]
;       [87:12] free scratch register 'r13'
    cmp r14, 2
;   [87:12] free scratch register 'r14'
    jne bool_false_87_12
    jmp bool_true_87_12
    bool_true_87_12:
    mov r15, true
    jmp bool_end_87_12
    bool_false_87_12:
    mov r15, false
    bool_end_87_12:
;   [20:6] assert(expr : bool) 
    assert_87_5:
;       [87:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_87_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_87_5:
        test r15, r15
        jne if_20_26_87_5_end
        jmp if_20_29_87_5_code
        if_20_29_87_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_87_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_87_5_end:
        if_20_26_87_5_end:
;       [87:5] free scratch register 'r15'
    assert_87_5_end:
;   [88:5] assert(arr[2] == 2)
;   [88:12] allocate scratch register -> r15
;   [88:12] arr[2] == 2
;   [88:12] ? arr[2] == 2
;   [88:12] ? arr[2] == 2
    cmp_88_12:
;   [88:12] allocate scratch register -> r14
;       [88:12] arr[2]
;       [88:12] arr[2]
;       [88:12] allocate scratch register -> r13
;       [88:16] set array index
;       [88:16] 2
;       [88:16] 2
;       [88:16] 2
        mov r13, 2
;       [88:16] bounds check
;       [88:16] allocate scratch register -> r12
;       [88:16] line number
        mov r12, 88
        test r13, r13
        cmovs rbp, r12
        js panic_bounds
        cmp r13, 4
        cmovge rbp, r12
        jge panic_bounds
;       [88:16] free scratch register 'r12'
        movsx r14, dword [rsp + r13 * 4 - 16]
;       [88:12] free scratch register 'r13'
    cmp r14, 2
;   [88:12] free scratch register 'r14'
    jne bool_false_88_12
    jmp bool_true_88_12
    bool_true_88_12:
    mov r15, true
    jmp bool_end_88_12
    bool_false_88_12:
    mov r15, false
    bool_end_88_12:
;   [20:6] assert(expr : bool) 
    assert_88_5:
;       [88:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_88_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_88_5:
        test r15, r15
        jne if_20_26_88_5_end
        jmp if_20_29_88_5_code
        if_20_29_88_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_88_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_88_5_end:
        if_20_26_88_5_end:
;       [88:5] free scratch register 'r15'
    assert_88_5_end:
;   [90:5] array_copy(arr[2], arr, 2)
;   [90:5] allocate named register 'rsi'
;   [90:5] allocate named register 'rdi'
;   [90:5] allocate named register 'rcx'
;   [90:29] 2
;   [90:29] 2
;   [90:29] 2
;   [90:29] 2
    mov rcx, 2
;   [90:16] arr[2]
;   [90:16] allocate scratch register -> r15
;   [90:20] set array index
;   [90:20] 2
;   [90:20] 2
;   [90:20] 2
    mov r15, 2
;   [90:20] bounds check
;   [90:20] allocate scratch register -> r14
;   [90:20] line number
    mov r14, 90
    test r15, r15
    cmovs rbp, r14
    js panic_bounds
;   [90:20] allocate scratch register -> r13
    mov r13, rcx
    add r13, r15
    cmp r13, 4
;   [90:20] free scratch register 'r13'
    cmovg rbp, r14
    jg panic_bounds
;   [90:20] free scratch register 'r14'
    lea rsi, [rsp + r15 * 4 - 16]
;   [90:5] free scratch register 'r15'
;   [90:24] arr
;   [90:24] bounds check
;   [90:24] allocate scratch register -> r15
;   [90:24] line number
    mov r15, 90
    test rcx, rcx
    cmovs rbp, r15
    js panic_bounds
    cmp rcx, 4
    cmovg rbp, r15
    jg panic_bounds
;   [90:24] free scratch register 'r15'
    lea rdi, [rsp - 16]
    shl rcx, 2
    rep movsb
;   [90:5] free named register 'rcx'
;   [90:5] free named register 'rdi'
;   [90:5] free named register 'rsi'
;   [91:5] # copy from, to, number of elements
;   [92:5] assert(arr[0] == 2)
;   [92:12] allocate scratch register -> r15
;   [92:12] arr[0] == 2
;   [92:12] ? arr[0] == 2
;   [92:12] ? arr[0] == 2
    cmp_92_12:
;   [92:12] allocate scratch register -> r14
;       [92:12] arr[0]
;       [92:12] arr[0]
;       [92:12] allocate scratch register -> r13
;       [92:16] set array index
;       [92:16] 0
;       [92:16] 0
;       [92:16] 0
        mov r13, 0
;       [92:16] bounds check
;       [92:16] allocate scratch register -> r12
;       [92:16] line number
        mov r12, 92
        test r13, r13
        cmovs rbp, r12
        js panic_bounds
        cmp r13, 4
        cmovge rbp, r12
        jge panic_bounds
;       [92:16] free scratch register 'r12'
        movsx r14, dword [rsp + r13 * 4 - 16]
;       [92:12] free scratch register 'r13'
    cmp r14, 2
;   [92:12] free scratch register 'r14'
    jne bool_false_92_12
    jmp bool_true_92_12
    bool_true_92_12:
    mov r15, true
    jmp bool_end_92_12
    bool_false_92_12:
    mov r15, false
    bool_end_92_12:
;   [20:6] assert(expr : bool) 
    assert_92_5:
;       [92:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_92_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_92_5:
        test r15, r15
        jne if_20_26_92_5_end
        jmp if_20_29_92_5_code
        if_20_29_92_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_92_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_92_5_end:
        if_20_26_92_5_end:
;       [92:5] free scratch register 'r15'
    assert_92_5_end:
;   [94:5] var arr1 : i32[8]
;   [94:9] arr1: i32[8] @ dword [rsp - 56]
;   [94:9] clear array 8 * 4 B = 32 B
;   [94:5] allocate named register 'rdi'
;   [94:5] allocate named register 'rcx'
;   [94:5] allocate named register 'rax'
    lea rdi, [rsp - 56]
    mov rcx, 32
    xor rax, rax
    rep stosb
;   [94:5] free named register 'rax'
;   [94:5] free named register 'rcx'
;   [94:5] free named register 'rdi'
;   [95:5] array_copy(arr, arr1, 4)
;   [95:5] allocate named register 'rsi'
;   [95:5] allocate named register 'rdi'
;   [95:5] allocate named register 'rcx'
;   [95:27] 4
;   [95:27] 4
;   [95:27] 4
;   [95:27] 4
    mov rcx, 4
;   [95:16] arr
;   [95:16] bounds check
;   [95:16] allocate scratch register -> r15
;   [95:16] line number
    mov r15, 95
    test rcx, rcx
    cmovs rbp, r15
    js panic_bounds
    cmp rcx, 4
    cmovg rbp, r15
    jg panic_bounds
;   [95:16] free scratch register 'r15'
    lea rsi, [rsp - 16]
;   [95:21] arr1
;   [95:21] bounds check
;   [95:21] allocate scratch register -> r15
;   [95:21] line number
    mov r15, 95
    test rcx, rcx
    cmovs rbp, r15
    js panic_bounds
    cmp rcx, 8
    cmovg rbp, r15
    jg panic_bounds
;   [95:21] free scratch register 'r15'
    lea rdi, [rsp - 56]
    shl rcx, 2
    rep movsb
;   [95:5] free named register 'rcx'
;   [95:5] free named register 'rdi'
;   [95:5] free named register 'rsi'
;   [96:5] assert(arrays_equal(arr, arr1, 4))
;   [96:12] allocate scratch register -> r15
;   [96:12] arrays_equal(arr, arr1, 4)
;   [96:12] ? arrays_equal(arr, arr1, 4)
;   [96:12] ? arrays_equal(arr, arr1, 4)
    cmp_96_12:
;   [96:12] allocate scratch register -> r14
;       [96:12] arrays_equal(arr, arr1, 4)
;       [96:12] r14 = arrays_equal(arr, arr1, 4)
;       [96:12] arrays_equal(arr, arr1, 4)
;       [96:12] allocate named register 'rsi'
;       [96:12] allocate named register 'rdi'
;       [96:12] allocate named register 'rcx'
;       [96:36] 4
;       [96:36] 4
;       [96:36] 4
;       [96:36] 4
        mov rcx, 4
;       [96:25] arr
;       [96:25] bounds check
;       [96:25] allocate scratch register -> r13
;       [96:25] line number
        mov r13, 96
        test rcx, rcx
        cmovs rbp, r13
        js panic_bounds
        cmp rcx, 4
        cmovg rbp, r13
        jg panic_bounds
;       [96:25] free scratch register 'r13'
        lea rsi, [rsp - 16]
;       [96:30] arr1
;       [96:30] bounds check
;       [96:30] allocate scratch register -> r13
;       [96:30] line number
        mov r13, 96
        test rcx, rcx
        cmovs rbp, r13
        js panic_bounds
        cmp rcx, 8
        cmovg rbp, r13
        jg panic_bounds
;       [96:30] free scratch register 'r13'
        lea rdi, [rsp - 56]
        shl rcx, 2
        repe cmpsb
;       [96:12] free named register 'rcx'
;       [96:12] free named register 'rdi'
;       [96:12] free named register 'rsi'
        je cmps_eq_96_12
        mov r14, false
        jmp cmps_end_96_12
        cmps_eq_96_12:
        mov r14, true
        cmps_end_96_12:
    test r14, r14
;   [96:12] free scratch register 'r14'
    je bool_false_96_12
    jmp bool_true_96_12
    bool_true_96_12:
    mov r15, true
    jmp bool_end_96_12
    bool_false_96_12:
    mov r15, false
    bool_end_96_12:
;   [20:6] assert(expr : bool) 
    assert_96_5:
;       [96:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_96_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_96_5:
        test r15, r15
        jne if_20_26_96_5_end
        jmp if_20_29_96_5_code
        if_20_29_96_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_96_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_96_5_end:
        if_20_26_96_5_end:
;       [96:5] free scratch register 'r15'
    assert_96_5_end:
;   [97:5] # note: `arrays_equal` is built-in function
;   [99:5] arr1[2] = -1
;   [99:5] allocate scratch register -> r15
;   [99:10] set array index
;   [99:10] 2
;   [99:10] 2
;   [99:10] 2
    mov r15, 2
;   [99:10] bounds check
;   [99:10] allocate scratch register -> r14
;   [99:10] line number
    mov r14, 99
    test r15, r15
    cmovs rbp, r14
    js panic_bounds
    cmp r15, 8
    cmovge rbp, r14
    jge panic_bounds
;   [99:10] free scratch register 'r14'
;   [99:15] -1
;   [99:15] -1
;   [99:16] -1
    mov dword [rsp + r15 * 4 - 56], -1
;   [99:5] free scratch register 'r15'
;   [100:5] assert(not arrays_equal(arr, arr1, 4))
;   [100:12] allocate scratch register -> r15
;   [100:12] not arrays_equal(arr, arr1, 4)
;   [100:12] ? not arrays_equal(arr, arr1, 4)
;   [100:12] ? not arrays_equal(arr, arr1, 4)
    cmp_100_12:
;   [100:16] allocate scratch register -> r14
;       [100:16] arrays_equal(arr, arr1, 4)
;       [100:16] r14 = arrays_equal(arr, arr1, 4)
;       [100:16] arrays_equal(arr, arr1, 4)
;       [100:16] allocate named register 'rsi'
;       [100:16] allocate named register 'rdi'
;       [100:16] allocate named register 'rcx'
;       [100:40] 4
;       [100:40] 4
;       [100:40] 4
;       [100:40] 4
        mov rcx, 4
;       [100:29] arr
;       [100:29] bounds check
;       [100:29] allocate scratch register -> r13
;       [100:29] line number
        mov r13, 100
        test rcx, rcx
        cmovs rbp, r13
        js panic_bounds
        cmp rcx, 4
        cmovg rbp, r13
        jg panic_bounds
;       [100:29] free scratch register 'r13'
        lea rsi, [rsp - 16]
;       [100:34] arr1
;       [100:34] bounds check
;       [100:34] allocate scratch register -> r13
;       [100:34] line number
        mov r13, 100
        test rcx, rcx
        cmovs rbp, r13
        js panic_bounds
        cmp rcx, 8
        cmovg rbp, r13
        jg panic_bounds
;       [100:34] free scratch register 'r13'
        lea rdi, [rsp - 56]
        shl rcx, 2
        repe cmpsb
;       [100:16] free named register 'rcx'
;       [100:16] free named register 'rdi'
;       [100:16] free named register 'rsi'
        je cmps_eq_100_16
        mov r14, false
        jmp cmps_end_100_16
        cmps_eq_100_16:
        mov r14, true
        cmps_end_100_16:
    test r14, r14
;   [100:12] free scratch register 'r14'
    jne bool_false_100_12
    jmp bool_true_100_12
    bool_true_100_12:
    mov r15, true
    jmp bool_end_100_12
    bool_false_100_12:
    mov r15, false
    bool_end_100_12:
;   [20:6] assert(expr : bool) 
    assert_100_5:
;       [100:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_100_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_100_5:
        test r15, r15
        jne if_20_26_100_5_end
        jmp if_20_29_100_5_code
        if_20_29_100_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_100_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_100_5_end:
        if_20_26_100_5_end:
;       [100:5] free scratch register 'r15'
    assert_100_5_end:
;   [102:5] ix = 3
;   [102:10] 3
;   [102:10] 3
;   [102:10] 3
    mov qword [rsp - 24], 3
;   [103:5] arr[ix] = ~inv(arr[ix - 1])
;   [103:5] allocate scratch register -> r15
;   [103:9] set array index
;   [103:9] ix
;   [103:9] ix
;   [103:9] ix
    mov r15, qword [rsp - 24]
;   [103:9] bounds check
;   [103:9] allocate scratch register -> r14
;   [103:9] line number
    mov r14, 103
    test r15, r15
    cmovs rbp, r14
    js panic_bounds
    cmp r15, 4
    cmovge rbp, r14
    jge panic_bounds
;   [103:9] free scratch register 'r14'
;   [103:15] ~inv(arr[ix - 1])
;   [103:15] ~inv(arr[ix - 1])
;   [103:16] dword [rsp + r15 * 4 - 16] = ~inv(arr[ix - 1])
;   [103:16] ~inv(arr[ix - 1])
;   [103:20] allocate scratch register -> r14
;   [103:24] set array index
;   [103:24] ix - 1
;   [103:24] ix - 1
;   [103:24] ix
    mov r14, qword [rsp - 24]
;   [103:29] r14 - 1
    sub r14, 1
;   [103:24] bounds check
;   [103:24] allocate scratch register -> r13
;   [103:24] line number
    mov r13, 103
    test r14, r14
    cmovs rbp, r13
    js panic_bounds
    cmp r14, 4
    cmovge rbp, r13
    jge panic_bounds
;   [103:24] free scratch register 'r13'
;   [65:6] inv(i : i32) : i32 res 
    inv_103_16:
;       [103:16] alias res -> dword [rsp + r15 * 4 - 16]  (lea: , len: 0)
;       [103:16] alias i -> arr  (lea: rsp + r14 * 4 - 16, len: 4)
;       [66:5] res = ~i
;       [66:11] ~i
;       [66:11] ~i
;       [66:12] ~i
;       [66:12] allocate scratch register -> r13
        lea r13, [rsp + r14 * 4 - 16]
;       [66:12] allocate scratch register -> r12
        mov r12d, dword [r13]
        mov dword [rsp + r15 * 4 - 16], r12d
;       [66:12] free scratch register 'r12'
        not dword [rsp + r15 * 4 - 16]
;       [66:12] free scratch register 'r13'
;       [103:16] free scratch register 'r14'
    inv_103_16_end:
    not dword [rsp + r15 * 4 - 16]
;   [103:5] free scratch register 'r15'
;   [104:5] assert(arr[ix] == 2)
;   [104:12] allocate scratch register -> r15
;   [104:12] arr[ix] == 2
;   [104:12] ? arr[ix] == 2
;   [104:12] ? arr[ix] == 2
    cmp_104_12:
;   [104:12] allocate scratch register -> r14
;       [104:12] arr[ix]
;       [104:12] arr[ix]
;       [104:12] allocate scratch register -> r13
;       [104:16] set array index
;       [104:16] ix
;       [104:16] ix
;       [104:16] ix
        mov r13, qword [rsp - 24]
;       [104:16] bounds check
;       [104:16] allocate scratch register -> r12
;       [104:16] line number
        mov r12, 104
        test r13, r13
        cmovs rbp, r12
        js panic_bounds
        cmp r13, 4
        cmovge rbp, r12
        jge panic_bounds
;       [104:16] free scratch register 'r12'
        movsx r14, dword [rsp + r13 * 4 - 16]
;       [104:12] free scratch register 'r13'
    cmp r14, 2
;   [104:12] free scratch register 'r14'
    jne bool_false_104_12
    jmp bool_true_104_12
    bool_true_104_12:
    mov r15, true
    jmp bool_end_104_12
    bool_false_104_12:
    mov r15, false
    bool_end_104_12:
;   [20:6] assert(expr : bool) 
    assert_104_5:
;       [104:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_104_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_104_5:
        test r15, r15
        jne if_20_26_104_5_end
        jmp if_20_29_104_5_code
        if_20_29_104_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_104_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_104_5_end:
        if_20_26_104_5_end:
;       [104:5] free scratch register 'r15'
    assert_104_5_end:
;   [106:5] faz(arr)
;   [75:6] faz(arg : i32[]) 
    faz_106_5:
;       [106:5] alias arg -> arr  (lea: , len: 0)
;       [76:5] arg[1] = 0xfe
;       [76:5] allocate scratch register -> r15
;       [76:9] set array index
;       [76:9] 1
;       [76:9] 1
;       [76:9] 1
        mov r15, 1
;       [76:9] bounds check
;       [76:9] allocate scratch register -> r14
;       [76:9] line number
        mov r14, 76
        test r15, r15
        cmovs rbp, r14
        js panic_bounds
        cmp r15, 4
        cmovge rbp, r14
        jge panic_bounds
;       [76:9] free scratch register 'r14'
;       [76:14] 0xfe
;       [76:14] 0xfe
;       [76:14] 0xfe
        mov dword [rsp + r15 * 4 - 16], 0xfe
;       [76:5] free scratch register 'r15'
    faz_106_5_end:
;   [107:5] assert(arr[1] == 0xfe)
;   [107:12] allocate scratch register -> r15
;   [107:12] arr[1] == 0xfe
;   [107:12] ? arr[1] == 0xfe
;   [107:12] ? arr[1] == 0xfe
    cmp_107_12:
;   [107:12] allocate scratch register -> r14
;       [107:12] arr[1]
;       [107:12] arr[1]
;       [107:12] allocate scratch register -> r13
;       [107:16] set array index
;       [107:16] 1
;       [107:16] 1
;       [107:16] 1
        mov r13, 1
;       [107:16] bounds check
;       [107:16] allocate scratch register -> r12
;       [107:16] line number
        mov r12, 107
        test r13, r13
        cmovs rbp, r12
        js panic_bounds
        cmp r13, 4
        cmovge rbp, r12
        jge panic_bounds
;       [107:16] free scratch register 'r12'
        movsx r14, dword [rsp + r13 * 4 - 16]
;       [107:12] free scratch register 'r13'
    cmp r14, 0xfe
;   [107:12] free scratch register 'r14'
    jne bool_false_107_12
    jmp bool_true_107_12
    bool_true_107_12:
    mov r15, true
    jmp bool_end_107_12
    bool_false_107_12:
    mov r15, false
    bool_end_107_12:
;   [20:6] assert(expr : bool) 
    assert_107_5:
;       [107:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_107_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_107_5:
        test r15, r15
        jne if_20_26_107_5_end
        jmp if_20_29_107_5_code
        if_20_29_107_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_107_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_107_5_end:
        if_20_26_107_5_end:
;       [107:5] free scratch register 'r15'
    assert_107_5_end:
;   [109:5] var p : point = {0, 0}
;   [109:9] p: point @ qword [rsp - 72]
;   [109:9] p ={0, 0}
;   [109:21] {0, 0}
;   [109:21] {0, 0}
;   [109:22] 0
;   [109:22] 0
;   [109:22] 0
    mov qword [rsp - 72], 0
;   [109:25] 0
;   [109:25] 0
;   [109:25] 0
    mov qword [rsp - 64], 0
;   [110:5] foo(p)
;   [51:6] foo(pt : point) 
    foo_110_5:
;       [110:5] alias pt -> p  (lea: , len: 0)
;       [52:5] pt.x = 0b10
;       [52:12] 0b10
;       [52:12] 0b10
;       [52:12] 0b10
        mov qword [rsp - 72], 0b10
;       [52:20] # binary value 2
;       [53:5] pt.y = 0xb
;       [53:12] 0xb
;       [53:12] 0xb
;       [53:12] 0xb
        mov qword [rsp - 64], 0xb
;       [53:20] # hex value 11
    foo_110_5_end:
;   [111:5] assert(p.x == 2)
;   [111:12] allocate scratch register -> r15
;   [111:12] p.x == 2
;   [111:12] ? p.x == 2
;   [111:12] ? p.x == 2
    cmp_111_12:
    cmp qword [rsp - 72], 2
    jne bool_false_111_12
    jmp bool_true_111_12
    bool_true_111_12:
    mov r15, true
    jmp bool_end_111_12
    bool_false_111_12:
    mov r15, false
    bool_end_111_12:
;   [20:6] assert(expr : bool) 
    assert_111_5:
;       [111:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_111_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_111_5:
        test r15, r15
        jne if_20_26_111_5_end
        jmp if_20_29_111_5_code
        if_20_29_111_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_111_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_111_5_end:
        if_20_26_111_5_end:
;       [111:5] free scratch register 'r15'
    assert_111_5_end:
;   [112:5] assert(p.y == 0xb)
;   [112:12] allocate scratch register -> r15
;   [112:12] p.y == 0xb
;   [112:12] ? p.y == 0xb
;   [112:12] ? p.y == 0xb
    cmp_112_12:
    cmp qword [rsp - 64], 0xb
    jne bool_false_112_12
    jmp bool_true_112_12
    bool_true_112_12:
    mov r15, true
    jmp bool_end_112_12
    bool_false_112_12:
    mov r15, false
    bool_end_112_12:
;   [20:6] assert(expr : bool) 
    assert_112_5:
;       [112:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_112_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_112_5:
        test r15, r15
        jne if_20_26_112_5_end
        jmp if_20_29_112_5_code
        if_20_29_112_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_112_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_112_5_end:
        if_20_26_112_5_end:
;       [112:5] free scratch register 'r15'
    assert_112_5_end:
;   [114:5] var i = 0
;   [114:9] i: i64 @ qword [rsp - 80]
;   [114:9] i =0
;   [114:13] 0
;   [114:13] 0
;   [114:13] 0
    mov qword [rsp - 80], 0
;   [115:5] bar(i)
;   [58:6] bar(arg) 
    bar_115_5:
;       [115:5] alias arg -> i  (lea: , len: 0)
        if_59_8_115_5:
;       [59:8] ? arg == 0
;       [59:8] ? arg == 0
        cmp_59_8_115_5:
        cmp qword [rsp - 80], 0
        jne if_59_5_115_5_end
        jmp if_59_8_115_5_code
        if_59_8_115_5_code:
;           [59:17] return
            jmp bar_115_5_end
        if_59_5_115_5_end:
;       [60:5] arg = 0xff
;       [60:11] 0xff
;       [60:11] 0xff
;       [60:11] 0xff
        mov qword [rsp - 80], 0xff
    bar_115_5_end:
;   [116:5] assert(i == 0)
;   [116:12] allocate scratch register -> r15
;   [116:12] i == 0
;   [116:12] ? i == 0
;   [116:12] ? i == 0
    cmp_116_12:
    cmp qword [rsp - 80], 0
    jne bool_false_116_12
    jmp bool_true_116_12
    bool_true_116_12:
    mov r15, true
    jmp bool_end_116_12
    bool_false_116_12:
    mov r15, false
    bool_end_116_12:
;   [20:6] assert(expr : bool) 
    assert_116_5:
;       [116:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_116_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_116_5:
        test r15, r15
        jne if_20_26_116_5_end
        jmp if_20_29_116_5_code
        if_20_29_116_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_116_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_116_5_end:
        if_20_26_116_5_end:
;       [116:5] free scratch register 'r15'
    assert_116_5_end:
;   [118:5] i = 1
;   [118:9] 1
;   [118:9] 1
;   [118:9] 1
    mov qword [rsp - 80], 1
;   [119:5] bar(i)
;   [58:6] bar(arg) 
    bar_119_5:
;       [119:5] alias arg -> i  (lea: , len: 0)
        if_59_8_119_5:
;       [59:8] ? arg == 0
;       [59:8] ? arg == 0
        cmp_59_8_119_5:
        cmp qword [rsp - 80], 0
        jne if_59_5_119_5_end
        jmp if_59_8_119_5_code
        if_59_8_119_5_code:
;           [59:17] return
            jmp bar_119_5_end
        if_59_5_119_5_end:
;       [60:5] arg = 0xff
;       [60:11] 0xff
;       [60:11] 0xff
;       [60:11] 0xff
        mov qword [rsp - 80], 0xff
    bar_119_5_end:
;   [120:5] assert(i == 0xff)
;   [120:12] allocate scratch register -> r15
;   [120:12] i == 0xff
;   [120:12] ? i == 0xff
;   [120:12] ? i == 0xff
    cmp_120_12:
    cmp qword [rsp - 80], 0xff
    jne bool_false_120_12
    jmp bool_true_120_12
    bool_true_120_12:
    mov r15, true
    jmp bool_end_120_12
    bool_false_120_12:
    mov r15, false
    bool_end_120_12:
;   [20:6] assert(expr : bool) 
    assert_120_5:
;       [120:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_120_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_120_5:
        test r15, r15
        jne if_20_26_120_5_end
        jmp if_20_29_120_5_code
        if_20_29_120_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_120_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_120_5_end:
        if_20_26_120_5_end:
;       [120:5] free scratch register 'r15'
    assert_120_5_end:
;   [122:5] var j = 1
;   [122:9] j: i64 @ qword [rsp - 88]
;   [122:9] j =1
;   [122:13] 1
;   [122:13] 1
;   [122:13] 1
    mov qword [rsp - 88], 1
;   [123:5] var k = baz(j)
;   [123:9] k: i64 @ qword [rsp - 96]
;   [123:9] k =baz(j)
;   [123:13] baz(j)
;   [123:13] allocate scratch register -> r15
;   [123:13] baz(j)
;   [123:13] r15 = baz(j)
;   [123:13] baz(j)
;   [69:6] baz(arg) : i64 res 
    baz_123_13:
;       [123:13] alias res -> r15  (lea: , len: 0)
;       [123:13] alias arg -> j  (lea: , len: 0)
;       [70:5] res = arg * 2
;       [70:11] arg * 2
;       [70:11] arg * 2
;       [70:11] arg
        mov r15, qword [rsp - 88]
;       [70:17] res * 2
        imul r15, 2
    baz_123_13_end:
    mov qword [rsp - 96], r15
;   [123:13] free scratch register 'r15'
;   [124:5] assert(k == 2)
;   [124:12] allocate scratch register -> r15
;   [124:12] k == 2
;   [124:12] ? k == 2
;   [124:12] ? k == 2
    cmp_124_12:
    cmp qword [rsp - 96], 2
    jne bool_false_124_12
    jmp bool_true_124_12
    bool_true_124_12:
    mov r15, true
    jmp bool_end_124_12
    bool_false_124_12:
    mov r15, false
    bool_end_124_12:
;   [20:6] assert(expr : bool) 
    assert_124_5:
;       [124:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_124_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_124_5:
        test r15, r15
        jne if_20_26_124_5_end
        jmp if_20_29_124_5_code
        if_20_29_124_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_124_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_124_5_end:
        if_20_26_124_5_end:
;       [124:5] free scratch register 'r15'
    assert_124_5_end:
;   [126:5] k = baz(1)
;   [126:9] baz(1)
;   [126:9] allocate scratch register -> r15
;   [126:9] baz(1)
;   [126:9] r15 = baz(1)
;   [126:9] baz(1)
;   [69:6] baz(arg) : i64 res 
    baz_126_9:
;       [126:9] alias res -> r15  (lea: , len: 0)
;       [126:9] alias arg -> 1  (lea: , len: 0)
;       [70:5] res = arg * 2
;       [70:11] arg * 2
;       [70:11] arg * 2
;       [70:11] arg
        mov r15, 1
;       [70:17] res * 2
        imul r15, 2
    baz_126_9_end:
    mov qword [rsp - 96], r15
;   [126:9] free scratch register 'r15'
;   [127:5] assert(k == 2)
;   [127:12] allocate scratch register -> r15
;   [127:12] k == 2
;   [127:12] ? k == 2
;   [127:12] ? k == 2
    cmp_127_12:
    cmp qword [rsp - 96], 2
    jne bool_false_127_12
    jmp bool_true_127_12
    bool_true_127_12:
    mov r15, true
    jmp bool_end_127_12
    bool_false_127_12:
    mov r15, false
    bool_end_127_12:
;   [20:6] assert(expr : bool) 
    assert_127_5:
;       [127:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_127_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_127_5:
        test r15, r15
        jne if_20_26_127_5_end
        jmp if_20_29_127_5_code
        if_20_29_127_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_127_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_127_5_end:
        if_20_26_127_5_end:
;       [127:5] free scratch register 'r15'
    assert_127_5_end:
;   [129:5] var p0 : point = {baz(2), 0}
;   [129:9] p0: point @ qword [rsp - 112]
;   [129:9] p0 ={baz(2), 0}
;   [129:22] {baz(2), 0}
;   [129:22] {baz(2), 0}
;   [129:23] baz(2)
;   [129:23] allocate scratch register -> r15
;   [129:23] baz(2)
;   [129:23] r15 = baz(2)
;   [129:23] baz(2)
;   [69:6] baz(arg) : i64 res 
    baz_129_23:
;       [129:23] alias res -> r15  (lea: , len: 0)
;       [129:23] alias arg -> 2  (lea: , len: 0)
;       [70:5] res = arg * 2
;       [70:11] arg * 2
;       [70:11] arg * 2
;       [70:11] arg
        mov r15, 2
;       [70:17] res * 2
        imul r15, 2
    baz_129_23_end:
    mov qword [rsp - 112], r15
;   [129:23] free scratch register 'r15'
;   [129:31] 0
;   [129:31] 0
;   [129:31] 0
    mov qword [rsp - 104], 0
;   [130:5] assert(p0.x == 4)
;   [130:12] allocate scratch register -> r15
;   [130:12] p0.x == 4
;   [130:12] ? p0.x == 4
;   [130:12] ? p0.x == 4
    cmp_130_12:
    cmp qword [rsp - 112], 4
    jne bool_false_130_12
    jmp bool_true_130_12
    bool_true_130_12:
    mov r15, true
    jmp bool_end_130_12
    bool_false_130_12:
    mov r15, false
    bool_end_130_12:
;   [20:6] assert(expr : bool) 
    assert_130_5:
;       [130:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_130_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_130_5:
        test r15, r15
        jne if_20_26_130_5_end
        jmp if_20_29_130_5_code
        if_20_29_130_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_130_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_130_5_end:
        if_20_26_130_5_end:
;       [130:5] free scratch register 'r15'
    assert_130_5_end:
;   [132:5] var x = 1
;   [132:9] x: i64 @ qword [rsp - 120]
;   [132:9] x =1
;   [132:13] 1
;   [132:13] 1
;   [132:13] 1
    mov qword [rsp - 120], 1
;   [133:5] var y = 2
;   [133:9] y: i64 @ qword [rsp - 128]
;   [133:9] y =2
;   [133:13] 2
;   [133:13] 2
;   [133:13] 2
    mov qword [rsp - 128], 2
;   [135:5] var o1 : object = {{x * 10, y}, 0xff0000}
;   [135:9] o1: object @ qword [rsp - 148]
;   [135:9] o1 ={{x * 10, y}, 0xff0000}
;   [135:23] {{x * 10, y}, 0xff0000}
;   [135:23] {{x * 10, y}, 0xff0000}
;       [135:24] {x * 10, y}
;       [135:25] x * 10
;       [135:25] allocate scratch register -> r15
;       [135:25] x * 10
;       [135:25] x
        mov r15, qword [rsp - 120]
;       [135:29] r15 * 10
        imul r15, 10
        mov qword [rsp - 148], r15
;       [135:25] free scratch register 'r15'
;       [135:33] y
;       [135:33] y
;       [135:33] y
;       [135:33] allocate scratch register -> r15
        mov r15, qword [rsp - 128]
        mov qword [rsp - 140], r15
;       [135:33] free scratch register 'r15'
;   [135:37] 0xff0000
;   [135:37] 0xff0000
;   [135:37] 0xff0000
    mov dword [rsp - 132], 0xff0000
;   [136:5] assert(o1.pos.x == 10)
;   [136:12] allocate scratch register -> r15
;   [136:12] o1.pos.x == 10
;   [136:12] ? o1.pos.x == 10
;   [136:12] ? o1.pos.x == 10
    cmp_136_12:
    cmp qword [rsp - 148], 10
    jne bool_false_136_12
    jmp bool_true_136_12
    bool_true_136_12:
    mov r15, true
    jmp bool_end_136_12
    bool_false_136_12:
    mov r15, false
    bool_end_136_12:
;   [20:6] assert(expr : bool) 
    assert_136_5:
;       [136:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_136_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_136_5:
        test r15, r15
        jne if_20_26_136_5_end
        jmp if_20_29_136_5_code
        if_20_29_136_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_136_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_136_5_end:
        if_20_26_136_5_end:
;       [136:5] free scratch register 'r15'
    assert_136_5_end:
;   [137:5] assert(o1.pos.y == 2)
;   [137:12] allocate scratch register -> r15
;   [137:12] o1.pos.y == 2
;   [137:12] ? o1.pos.y == 2
;   [137:12] ? o1.pos.y == 2
    cmp_137_12:
    cmp qword [rsp - 140], 2
    jne bool_false_137_12
    jmp bool_true_137_12
    bool_true_137_12:
    mov r15, true
    jmp bool_end_137_12
    bool_false_137_12:
    mov r15, false
    bool_end_137_12:
;   [20:6] assert(expr : bool) 
    assert_137_5:
;       [137:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_137_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_137_5:
        test r15, r15
        jne if_20_26_137_5_end
        jmp if_20_29_137_5_code
        if_20_29_137_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_137_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_137_5_end:
        if_20_26_137_5_end:
;       [137:5] free scratch register 'r15'
    assert_137_5_end:
;   [138:5] assert(o1.color == 0xff0000)
;   [138:12] allocate scratch register -> r15
;   [138:12] o1.color == 0xff0000
;   [138:12] ? o1.color == 0xff0000
;   [138:12] ? o1.color == 0xff0000
    cmp_138_12:
    cmp dword [rsp - 132], 0xff0000
    jne bool_false_138_12
    jmp bool_true_138_12
    bool_true_138_12:
    mov r15, true
    jmp bool_end_138_12
    bool_false_138_12:
    mov r15, false
    bool_end_138_12:
;   [20:6] assert(expr : bool) 
    assert_138_5:
;       [138:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_138_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_138_5:
        test r15, r15
        jne if_20_26_138_5_end
        jmp if_20_29_138_5_code
        if_20_29_138_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_138_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_138_5_end:
        if_20_26_138_5_end:
;       [138:5] free scratch register 'r15'
    assert_138_5_end:
;   [140:5] var p1 : point = {-x, -y}
;   [140:9] p1: point @ qword [rsp - 164]
;   [140:9] p1 ={-x, -y}
;   [140:22] {-x, -y}
;   [140:22] {-x, -y}
;   [140:23] -x
;   [140:23] -x
;   [140:24] -x
;   [140:24] allocate scratch register -> r15
    mov r15, qword [rsp - 120]
    mov qword [rsp - 164], r15
;   [140:24] free scratch register 'r15'
    neg qword [rsp - 164]
;   [140:27] -y
;   [140:27] -y
;   [140:28] -y
;   [140:28] allocate scratch register -> r15
    mov r15, qword [rsp - 128]
    mov qword [rsp - 156], r15
;   [140:28] free scratch register 'r15'
    neg qword [rsp - 156]
;   [141:5] o1.pos = p1
;   [141:5] allocate named register 'rsi'
;   [141:5] allocate named register 'rdi'
;   [141:5] allocate named register 'rcx'
    lea rdi, [rsp - 148]
;   [141:14] p1
    lea rsi, [rsp - 164]
    mov rcx, 16
    rep movsb
;   [141:5] free named register 'rcx'
;   [141:5] free named register 'rdi'
;   [141:5] free named register 'rsi'
;   [142:5] assert(o1.pos.x == -1)
;   [142:12] allocate scratch register -> r15
;   [142:12] o1.pos.x == -1
;   [142:12] ? o1.pos.x == -1
;   [142:12] ? o1.pos.x == -1
    cmp_142_12:
    cmp qword [rsp - 148], -1
    jne bool_false_142_12
    jmp bool_true_142_12
    bool_true_142_12:
    mov r15, true
    jmp bool_end_142_12
    bool_false_142_12:
    mov r15, false
    bool_end_142_12:
;   [20:6] assert(expr : bool) 
    assert_142_5:
;       [142:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_142_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_142_5:
        test r15, r15
        jne if_20_26_142_5_end
        jmp if_20_29_142_5_code
        if_20_29_142_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_142_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_142_5_end:
        if_20_26_142_5_end:
;       [142:5] free scratch register 'r15'
    assert_142_5_end:
;   [143:5] assert(o1.pos.y == -2)
;   [143:12] allocate scratch register -> r15
;   [143:12] o1.pos.y == -2
;   [143:12] ? o1.pos.y == -2
;   [143:12] ? o1.pos.y == -2
    cmp_143_12:
    cmp qword [rsp - 140], -2
    jne bool_false_143_12
    jmp bool_true_143_12
    bool_true_143_12:
    mov r15, true
    jmp bool_end_143_12
    bool_false_143_12:
    mov r15, false
    bool_end_143_12:
;   [20:6] assert(expr : bool) 
    assert_143_5:
;       [143:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_143_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_143_5:
        test r15, r15
        jne if_20_26_143_5_end
        jmp if_20_29_143_5_code
        if_20_29_143_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_143_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_143_5_end:
        if_20_26_143_5_end:
;       [143:5] free scratch register 'r15'
    assert_143_5_end:
;   [145:5] var o2 : object = o1
;   [145:9] o2: object @ qword [rsp - 184]
;   [145:9] o2 =o1
;   [145:9] allocate named register 'rsi'
;   [145:9] allocate named register 'rdi'
;   [145:9] allocate named register 'rcx'
    lea rdi, [rsp - 184]
;   [145:23] o1
    lea rsi, [rsp - 148]
    mov rcx, 20
    rep movsb
;   [145:9] free named register 'rcx'
;   [145:9] free named register 'rdi'
;   [145:9] free named register 'rsi'
;   [146:5] assert(o2.pos.x == -1)
;   [146:12] allocate scratch register -> r15
;   [146:12] o2.pos.x == -1
;   [146:12] ? o2.pos.x == -1
;   [146:12] ? o2.pos.x == -1
    cmp_146_12:
    cmp qword [rsp - 184], -1
    jne bool_false_146_12
    jmp bool_true_146_12
    bool_true_146_12:
    mov r15, true
    jmp bool_end_146_12
    bool_false_146_12:
    mov r15, false
    bool_end_146_12:
;   [20:6] assert(expr : bool) 
    assert_146_5:
;       [146:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_146_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_146_5:
        test r15, r15
        jne if_20_26_146_5_end
        jmp if_20_29_146_5_code
        if_20_29_146_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_146_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_146_5_end:
        if_20_26_146_5_end:
;       [146:5] free scratch register 'r15'
    assert_146_5_end:
;   [147:5] assert(o2.pos.y == -2)
;   [147:12] allocate scratch register -> r15
;   [147:12] o2.pos.y == -2
;   [147:12] ? o2.pos.y == -2
;   [147:12] ? o2.pos.y == -2
    cmp_147_12:
    cmp qword [rsp - 176], -2
    jne bool_false_147_12
    jmp bool_true_147_12
    bool_true_147_12:
    mov r15, true
    jmp bool_end_147_12
    bool_false_147_12:
    mov r15, false
    bool_end_147_12:
;   [20:6] assert(expr : bool) 
    assert_147_5:
;       [147:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_147_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_147_5:
        test r15, r15
        jne if_20_26_147_5_end
        jmp if_20_29_147_5_code
        if_20_29_147_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_147_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_147_5_end:
        if_20_26_147_5_end:
;       [147:5] free scratch register 'r15'
    assert_147_5_end:
;   [148:5] assert(o2.color == 0xff0000)
;   [148:12] allocate scratch register -> r15
;   [148:12] o2.color == 0xff0000
;   [148:12] ? o2.color == 0xff0000
;   [148:12] ? o2.color == 0xff0000
    cmp_148_12:
    cmp dword [rsp - 168], 0xff0000
    jne bool_false_148_12
    jmp bool_true_148_12
    bool_true_148_12:
    mov r15, true
    jmp bool_end_148_12
    bool_false_148_12:
    mov r15, false
    bool_end_148_12:
;   [20:6] assert(expr : bool) 
    assert_148_5:
;       [148:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_148_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_148_5:
        test r15, r15
        jne if_20_26_148_5_end
        jmp if_20_29_148_5_code
        if_20_29_148_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_148_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_148_5_end:
        if_20_26_148_5_end:
;       [148:5] free scratch register 'r15'
    assert_148_5_end:
;   [150:5] var o3 : object[1]
;   [150:9] o3: object[1] @ qword [rsp - 204]
;   [150:9] clear array 1 * 20 B = 20 B
;   [150:5] allocate named register 'rdi'
;   [150:5] allocate named register 'rcx'
;   [150:5] allocate named register 'rax'
    lea rdi, [rsp - 204]
    mov rcx, 20
    xor rax, rax
    rep stosb
;   [150:5] free named register 'rax'
;   [150:5] free named register 'rcx'
;   [150:5] free named register 'rdi'
;   [151:5] # index 0 in an array can be accessed without array index
;   [152:5] o3.pos.y = 73
;   [152:16] 73
;   [152:16] 73
;   [152:16] 73
    mov qword [rsp - 196], 73
;   [153:5] assert(o3[0].pos.y == 73)
;   [153:12] allocate scratch register -> r15
;   [153:12] o3[0].pos.y == 73
;   [153:12] ? o3[0].pos.y == 73
;   [153:12] ? o3[0].pos.y == 73
    cmp_153_12:
;   [153:12] allocate scratch register -> r14
;       [153:12] o3[0].pos.y
;       [153:12] o3[0].pos.y
;       [153:12] allocate scratch register -> r13
        lea r13, [rsp - 204]
;       [153:12] allocate scratch register -> r12
;       [153:15] set array index
;       [153:15] 0
;       [153:15] 0
;       [153:15] 0
        mov r12, 0
;       [153:15] bounds check
;       [153:15] allocate scratch register -> r11
;       [153:15] line number
        mov r11, 153
        test r12, r12
        cmovs rbp, r11
        js panic_bounds
        cmp r12, 1
        cmovge rbp, r11
        jge panic_bounds
;       [153:15] free scratch register 'r11'
        imul r12, 20
        add r13, r12
;       [153:12] free scratch register 'r12'
        mov r14, qword [r13 + 8]
;       [153:12] free scratch register 'r13'
    cmp r14, 73
;   [153:12] free scratch register 'r14'
    jne bool_false_153_12
    jmp bool_true_153_12
    bool_true_153_12:
    mov r15, true
    jmp bool_end_153_12
    bool_false_153_12:
    mov r15, false
    bool_end_153_12:
;   [20:6] assert(expr : bool) 
    assert_153_5:
;       [153:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_153_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_153_5:
        test r15, r15
        jne if_20_26_153_5_end
        jmp if_20_29_153_5_code
        if_20_29_153_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_153_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_153_5_end:
        if_20_26_153_5_end:
;       [153:5] free scratch register 'r15'
    assert_153_5_end:
;   [155:5] var input_buffer : i8[80]
;   [155:9] input_buffer: i8[80] @ byte [rsp - 284]
;   [155:9] clear array 80 * 1 B = 80 B
;   [155:5] allocate named register 'rdi'
;   [155:5] allocate named register 'rcx'
;   [155:5] allocate named register 'rax'
    lea rdi, [rsp - 284]
    mov rcx, 80
    xor rax, rax
    rep stosb
;   [155:5] free named register 'rax'
;   [155:5] free named register 'rcx'
;   [155:5] free named register 'rdi'
;   [157:5] var worlds : world[8]
;   [157:9] worlds: world[8] @ qword [rsp - 796]
;   [157:9] clear array 8 * 64 B = 512 B
;   [157:5] allocate named register 'rdi'
;   [157:5] allocate named register 'rcx'
;   [157:5] allocate named register 'rax'
    lea rdi, [rsp - 796]
    mov rcx, 512
    xor rax, rax
    rep stosb
;   [157:5] free named register 'rax'
;   [157:5] free named register 'rcx'
;   [157:5] free named register 'rdi'
;   [158:5] worlds[1].locations[1] = 0xffee
;   [158:5] allocate scratch register -> r15
    lea r15, [rsp - 796]
;   [158:5] allocate scratch register -> r14
;   [158:12] set array index
;   [158:12] 1
;   [158:12] 1
;   [158:12] 1
    mov r14, 1
;   [158:12] bounds check
;   [158:12] allocate scratch register -> r13
;   [158:12] line number
    mov r13, 158
    test r14, r14
    cmovs rbp, r13
    js panic_bounds
    cmp r14, 8
    cmovge rbp, r13
    jge panic_bounds
;   [158:12] free scratch register 'r13'
    shl r14, 6
    add r15, r14
;   [158:5] free scratch register 'r14'
;   [158:5] allocate scratch register -> r14
;   [158:25] set array index
;   [158:25] 1
;   [158:25] 1
;   [158:25] 1
    mov r14, 1
;   [158:25] bounds check
;   [158:25] allocate scratch register -> r13
;   [158:25] line number
    mov r13, 158
    test r14, r14
    cmovs rbp, r13
    js panic_bounds
    cmp r14, 8
    cmovge rbp, r13
    jge panic_bounds
;   [158:25] free scratch register 'r13'
;   [158:30] 0xffee
;   [158:30] 0xffee
;   [158:30] 0xffee
    mov qword [r15 + r14 * 8], 0xffee
;   [158:5] free scratch register 'r14'
;   [158:5] free scratch register 'r15'
;   [159:5] assert(worlds[1].locations[1] == 0xffee)
;   [159:12] allocate scratch register -> r15
;   [159:12] worlds[1].locations[1] == 0xffee
;   [159:12] ? worlds[1].locations[1] == 0xffee
;   [159:12] ? worlds[1].locations[1] == 0xffee
    cmp_159_12:
;   [159:12] allocate scratch register -> r14
;       [159:12] worlds[1].locations[1]
;       [159:12] worlds[1].locations[1]
;       [159:12] allocate scratch register -> r13
        lea r13, [rsp - 796]
;       [159:12] allocate scratch register -> r12
;       [159:19] set array index
;       [159:19] 1
;       [159:19] 1
;       [159:19] 1
        mov r12, 1
;       [159:19] bounds check
;       [159:19] allocate scratch register -> r11
;       [159:19] line number
        mov r11, 159
        test r12, r12
        cmovs rbp, r11
        js panic_bounds
        cmp r12, 8
        cmovge rbp, r11
        jge panic_bounds
;       [159:19] free scratch register 'r11'
        shl r12, 6
        add r13, r12
;       [159:12] free scratch register 'r12'
;       [159:12] allocate scratch register -> r12
;       [159:32] set array index
;       [159:32] 1
;       [159:32] 1
;       [159:32] 1
        mov r12, 1
;       [159:32] bounds check
;       [159:32] allocate scratch register -> r11
;       [159:32] line number
        mov r11, 159
        test r12, r12
        cmovs rbp, r11
        js panic_bounds
        cmp r12, 8
        cmovge rbp, r11
        jge panic_bounds
;       [159:32] free scratch register 'r11'
        mov r14, qword [r13 + r12 * 8]
;       [159:12] free scratch register 'r12'
;       [159:12] free scratch register 'r13'
    cmp r14, 0xffee
;   [159:12] free scratch register 'r14'
    jne bool_false_159_12
    jmp bool_true_159_12
    bool_true_159_12:
    mov r15, true
    jmp bool_end_159_12
    bool_false_159_12:
    mov r15, false
    bool_end_159_12:
;   [20:6] assert(expr : bool) 
    assert_159_5:
;       [159:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_159_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_159_5:
        test r15, r15
        jne if_20_26_159_5_end
        jmp if_20_29_159_5_code
        if_20_29_159_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_159_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_159_5_end:
        if_20_26_159_5_end:
;       [159:5] free scratch register 'r15'
    assert_159_5_end:
;   [161:5] array_copy( worlds[1].locations, worlds[0].locations, array_size_of(worlds.locations) )
;   [161:5] allocate named register 'rsi'
;   [161:5] allocate named register 'rdi'
;   [161:5] allocate named register 'rcx'
;   [163:9] array_size_of(worlds.locations)
;   [163:9] array_size_of(worlds.locations)
;   [164:9] array_size_of(worlds.locations)
;   [164:9] rcx = array_size_of(worlds.locations)
;   [164:9] array_size_of(worlds.locations)
    mov rcx, 8
;   [162:9] worlds[1].locations
;   [162:9] allocate scratch register -> r15
    lea r15, [rsp - 796]
;   [162:9] allocate scratch register -> r14
;   [162:16] set array index
;   [162:16] 1
;   [162:16] 1
;   [162:16] 1
    mov r14, 1
;   [162:16] bounds check
;   [162:16] allocate scratch register -> r13
;   [162:16] line number
    mov r13, 162
    test r14, r14
    cmovs rbp, r13
    js panic_bounds
    cmp r14, 8
    cmovge rbp, r13
    jge panic_bounds
;   [162:16] free scratch register 'r13'
    shl r14, 6
    add r15, r14
;   [162:9] free scratch register 'r14'
;   [162:9] bounds check
;   [162:9] allocate scratch register -> r14
;   [162:9] line number
    mov r14, 162
    test rcx, rcx
    cmovs rbp, r14
    js panic_bounds
    cmp rcx, 8
    cmovg rbp, r14
    jg panic_bounds
;   [162:9] free scratch register 'r14'
    lea rsi, [r15]
;   [161:5] free scratch register 'r15'
;   [163:9] worlds[0].locations
;   [163:9] allocate scratch register -> r15
    lea r15, [rsp - 796]
;   [163:9] allocate scratch register -> r14
;   [163:16] set array index
;   [163:16] 0
;   [163:16] 0
;   [163:16] 0
    mov r14, 0
;   [163:16] bounds check
;   [163:16] allocate scratch register -> r13
;   [163:16] line number
    mov r13, 163
    test r14, r14
    cmovs rbp, r13
    js panic_bounds
    cmp r14, 8
    cmovge rbp, r13
    jge panic_bounds
;   [163:16] free scratch register 'r13'
    shl r14, 6
    add r15, r14
;   [163:9] free scratch register 'r14'
;   [163:9] bounds check
;   [163:9] allocate scratch register -> r14
;   [163:9] line number
    mov r14, 163
    test rcx, rcx
    cmovs rbp, r14
    js panic_bounds
    cmp rcx, 8
    cmovg rbp, r14
    jg panic_bounds
;   [163:9] free scratch register 'r14'
    lea rdi, [r15]
;   [161:5] free scratch register 'r15'
    shl rcx, 3
    rep movsb
;   [161:5] free named register 'rcx'
;   [161:5] free named register 'rdi'
;   [161:5] free named register 'rsi'
;   [166:5] # note: `array_copy` is built-in and can use indexed positions
;   [167:5] # `array_size_of` is built-in
;   [168:5] assert(worlds[0].locations[1] == 0xffee)
;   [168:12] allocate scratch register -> r15
;   [168:12] worlds[0].locations[1] == 0xffee
;   [168:12] ? worlds[0].locations[1] == 0xffee
;   [168:12] ? worlds[0].locations[1] == 0xffee
    cmp_168_12:
;   [168:12] allocate scratch register -> r14
;       [168:12] worlds[0].locations[1]
;       [168:12] worlds[0].locations[1]
;       [168:12] allocate scratch register -> r13
        lea r13, [rsp - 796]
;       [168:12] allocate scratch register -> r12
;       [168:19] set array index
;       [168:19] 0
;       [168:19] 0
;       [168:19] 0
        mov r12, 0
;       [168:19] bounds check
;       [168:19] allocate scratch register -> r11
;       [168:19] line number
        mov r11, 168
        test r12, r12
        cmovs rbp, r11
        js panic_bounds
        cmp r12, 8
        cmovge rbp, r11
        jge panic_bounds
;       [168:19] free scratch register 'r11'
        shl r12, 6
        add r13, r12
;       [168:12] free scratch register 'r12'
;       [168:12] allocate scratch register -> r12
;       [168:32] set array index
;       [168:32] 1
;       [168:32] 1
;       [168:32] 1
        mov r12, 1
;       [168:32] bounds check
;       [168:32] allocate scratch register -> r11
;       [168:32] line number
        mov r11, 168
        test r12, r12
        cmovs rbp, r11
        js panic_bounds
        cmp r12, 8
        cmovge rbp, r11
        jge panic_bounds
;       [168:32] free scratch register 'r11'
        mov r14, qword [r13 + r12 * 8]
;       [168:12] free scratch register 'r12'
;       [168:12] free scratch register 'r13'
    cmp r14, 0xffee
;   [168:12] free scratch register 'r14'
    jne bool_false_168_12
    jmp bool_true_168_12
    bool_true_168_12:
    mov r15, true
    jmp bool_end_168_12
    bool_false_168_12:
    mov r15, false
    bool_end_168_12:
;   [20:6] assert(expr : bool) 
    assert_168_5:
;       [168:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_168_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_168_5:
        test r15, r15
        jne if_20_26_168_5_end
        jmp if_20_29_168_5_code
        if_20_29_168_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_168_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_168_5_end:
        if_20_26_168_5_end:
;       [168:5] free scratch register 'r15'
    assert_168_5_end:
;   [169:5] assert(arrays_equal( worlds[0].locations, worlds[1].locations, array_size_of(worlds.locations) ))
;   [169:12] allocate scratch register -> r15
;   [169:12] arrays_equal( worlds[0].locations, worlds[1].locations, array_size_of(worlds.locations) )
;   [169:12] ? arrays_equal( worlds[0].locations, worlds[1].locations, array_size_of(worlds.locations) )
;   [169:12] ? arrays_equal( worlds[0].locations, worlds[1].locations, array_size_of(worlds.locations) )
    cmp_169_12:
;   [169:12] allocate scratch register -> r14
;       [169:12] arrays_equal( worlds[0].locations, worlds[1].locations, array_size_of(worlds.locations) )
;       [169:12] r14 = arrays_equal( worlds[0].locations, worlds[1].locations, array_size_of(worlds.locations) )
;       [169:12] arrays_equal( worlds[0].locations, worlds[1].locations, array_size_of(worlds.locations) )
;       [169:12] allocate named register 'rsi'
;       [169:12] allocate named register 'rdi'
;       [169:12] allocate named register 'rcx'
;       [171:14] array_size_of(worlds.locations)
;       [171:14] array_size_of(worlds.locations)
;       [172:14] array_size_of(worlds.locations)
;       [172:14] rcx = array_size_of(worlds.locations)
;       [172:14] array_size_of(worlds.locations)
        mov rcx, 8
;       [170:14] worlds[0].locations
;       [170:14] allocate scratch register -> r13
        lea r13, [rsp - 796]
;       [170:14] allocate scratch register -> r12
;       [170:21] set array index
;       [170:21] 0
;       [170:21] 0
;       [170:21] 0
        mov r12, 0
;       [170:21] bounds check
;       [170:21] allocate scratch register -> r11
;       [170:21] line number
        mov r11, 170
        test r12, r12
        cmovs rbp, r11
        js panic_bounds
        cmp r12, 8
        cmovge rbp, r11
        jge panic_bounds
;       [170:21] free scratch register 'r11'
        shl r12, 6
        add r13, r12
;       [170:14] free scratch register 'r12'
;       [170:14] bounds check
;       [170:14] allocate scratch register -> r12
;       [170:14] line number
        mov r12, 170
        test rcx, rcx
        cmovs rbp, r12
        js panic_bounds
        cmp rcx, 8
        cmovg rbp, r12
        jg panic_bounds
;       [170:14] free scratch register 'r12'
        lea rsi, [r13]
;       [169:12] free scratch register 'r13'
;       [171:14] worlds[1].locations
;       [171:14] allocate scratch register -> r13
        lea r13, [rsp - 796]
;       [171:14] allocate scratch register -> r12
;       [171:21] set array index
;       [171:21] 1
;       [171:21] 1
;       [171:21] 1
        mov r12, 1
;       [171:21] bounds check
;       [171:21] allocate scratch register -> r11
;       [171:21] line number
        mov r11, 171
        test r12, r12
        cmovs rbp, r11
        js panic_bounds
        cmp r12, 8
        cmovge rbp, r11
        jge panic_bounds
;       [171:21] free scratch register 'r11'
        shl r12, 6
        add r13, r12
;       [171:14] free scratch register 'r12'
;       [171:14] bounds check
;       [171:14] allocate scratch register -> r12
;       [171:14] line number
        mov r12, 171
        test rcx, rcx
        cmovs rbp, r12
        js panic_bounds
        cmp rcx, 8
        cmovg rbp, r12
        jg panic_bounds
;       [171:14] free scratch register 'r12'
        lea rdi, [r13]
;       [169:12] free scratch register 'r13'
        shl rcx, 3
        repe cmpsb
;       [169:12] free named register 'rcx'
;       [169:12] free named register 'rdi'
;       [169:12] free named register 'rsi'
        je cmps_eq_169_12
        mov r14, false
        jmp cmps_end_169_12
        cmps_eq_169_12:
        mov r14, true
        cmps_end_169_12:
    test r14, r14
;   [169:12] free scratch register 'r14'
    je bool_false_169_12
    jmp bool_true_169_12
    bool_true_169_12:
    mov r15, true
    jmp bool_end_169_12
    bool_false_169_12:
    mov r15, false
    bool_end_169_12:
;   [20:6] assert(expr : bool) 
    assert_169_5:
;       [169:5] alias expr -> r15  (lea: , len: 0)
        if_20_29_169_5:
;       [20:29] ? not expr
;       [20:29] ? not expr
        cmp_20_29_169_5:
        test r15, r15
        jne if_20_26_169_5_end
        jmp if_20_29_169_5_code
        if_20_29_169_5_code:
;           [20:38] exit(1)
;           [20:43] allocate named register 'rdi'
            mov rdi, 1
;           [12:6] exit(v : reg_rdi) 
            exit_20_38_169_5:
;               [20:38] alias v -> rdi  (lea: , len: 0)
;               [13:5] mov(rax, 60)
;                   [13:14] 60
;                   [13:14] 60
;                   [13:14] 60
                    mov rax, 60
;               [13:19] # exit system call
;               [14:5] mov(rdi, v)
;                   [14:14] v
;                   [14:14] v
;                   [14:14] v
;               [14:19] # return code
;               [15:5] syscall()
                syscall
;               [20:38] free named register 'rdi'
            exit_20_38_169_5_end:
        if_20_26_169_5_end:
;       [169:5] free scratch register 'r15'
    assert_169_5_end:
;   [175:5] print(hello.len, hello)
;   [175:11] allocate named register 'rdx'
    mov rdx, hello.len
;   [175:22] allocate named register 'rsi'
    mov rsi, hello
;   [22:6] print(len : reg_rdx, ptr : reg_rsi) 
    print_175_5:
;       [175:5] alias len -> rdx  (lea: , len: 0)
;       [175:5] alias ptr -> rsi  (lea: , len: 0)
;       [23:5] mov(rax, 1)
;           [23:14] 1
;           [23:14] 1
;           [23:14] 1
            mov rax, 1
;       [23:19] # write system call
;       [24:5] mov(rdi, 1)
;           [24:14] 1
;           [24:14] 1
;           [24:14] 1
            mov rdi, 1
;       [24:19] # file descriptor for standard out
;       [25:5] mov(rsi, ptr)
;           [25:14] ptr
;           [25:14] ptr
;           [25:14] ptr
;       [25:19] # buffer address
;       [26:5] mov(rdx, len)
;           [26:14] len
;           [26:14] len
;           [26:14] len
;       [26:19] # buffer size
;       [27:5] syscall()
        syscall
;       [175:5] free named register 'rsi'
;       [175:5] free named register 'rdx'
    print_175_5_end:
;   [176:5] loop
    loop_176_5:
;       [177:9] print(prompt1.len, prompt1)
;       [177:15] allocate named register 'rdx'
        mov rdx, prompt1.len
;       [177:28] allocate named register 'rsi'
        mov rsi, prompt1
;       [22:6] print(len : reg_rdx, ptr : reg_rsi) 
        print_177_9:
;           [177:9] alias len -> rdx  (lea: , len: 0)
;           [177:9] alias ptr -> rsi  (lea: , len: 0)
;           [23:5] mov(rax, 1)
;               [23:14] 1
;               [23:14] 1
;               [23:14] 1
                mov rax, 1
;           [23:19] # write system call
;           [24:5] mov(rdi, 1)
;               [24:14] 1
;               [24:14] 1
;               [24:14] 1
                mov rdi, 1
;           [24:19] # file descriptor for standard out
;           [25:5] mov(rsi, ptr)
;               [25:14] ptr
;               [25:14] ptr
;               [25:14] ptr
;           [25:19] # buffer address
;           [26:5] mov(rdx, len)
;               [26:14] len
;               [26:14] len
;               [26:14] len
;           [26:19] # buffer size
;           [27:5] syscall()
            syscall
;           [177:9] free named register 'rsi'
;           [177:9] free named register 'rdx'
        print_177_9_end:
;       [179:9] var len = read(array_size_of(input_buffer), address_of(input_buffer)) - 1
;       [179:13] len: i64 @ qword [rsp - 804]
;       [179:13] len =read(array_size_of(input_buffer), address_of(input_buffer)) - 1
;       [179:19] read(array_size_of(input_buffer), address_of(input_buffer)) - 1
;       [179:19] read(array_size_of(input_buffer), address_of(input_buffer)) - 1
;       [179:19] len = read(array_size_of(input_buffer), address_of(input_buffer))
;       [179:19] read(array_size_of(input_buffer), address_of(input_buffer))
;       [179:24] allocate named register 'rdx'
;       [179:24] array_size_of(input_buffer)
;       [179:24] array_size_of(input_buffer)
;       [179:24] rdx = array_size_of(input_buffer)
;       [179:24] array_size_of(input_buffer)
        mov rdx, 80
;       [179:53] allocate named register 'rsi'
;       [179:53] address_of(input_buffer)
;       [179:53] address_of(input_buffer)
;       [179:53] rsi = address_of(input_buffer)
;       [179:53] address_of(input_buffer)
        lea rsi, [rsp - 284]
;       [30:6] read(len : reg_rdx, ptr : reg_rsi) : i64 nbytes 
        read_179_19:
;           [179:19] alias nbytes -> qword [rsp - 804]  (lea: , len: 0)
;           [179:19] alias len -> rdx  (lea: , len: 0)
;           [179:19] alias ptr -> rsi  (lea: , len: 0)
;           [31:5] mov(rax, 0)
;               [31:14] 0
;               [31:14] 0
;               [31:14] 0
                mov rax, 0
;           [31:19] # read system call
;           [32:5] mov(rdi, 0)
;               [32:14] 0
;               [32:14] 0
;               [32:14] 0
                mov rdi, 0
;           [32:19] # file descriptor for standard input
;           [33:5] mov(rsi, ptr)
;               [33:14] ptr
;               [33:14] ptr
;               [33:14] ptr
;           [33:19] # buffer address
;           [34:5] mov(rdx, len)
;               [34:14] len
;               [34:14] len
;               [34:14] len
;           [34:19] # buffer size
;           [35:5] syscall()
            syscall
;           [36:5] mov(nbytes, rax)
;               [36:17] rax
;               [36:17] rax
;               [36:17] rax
                mov qword [rsp - 804], rax
;           [36:22] # return value
;           [179:19] free named register 'rsi'
;           [179:19] free named register 'rdx'
        read_179_19_end:
;       [179:81] len - 1
        sub qword [rsp - 804], 1
;       [180:9] # note: `address_of` is built-in function
;       [181:9] # -1 to not include the trailing '\n'
        if_183_12:
;       [183:12] ? len == 0
;       [183:12] ? len == 0
        cmp_183_12:
        cmp qword [rsp - 804], 0
        jne if_185_19
        jmp if_183_12_code
        if_183_12_code:
;           [184:13] break
            jmp loop_176_5_end
        jmp if_183_9_end
        if_185_19:
;       [185:19] ? len <= 4
;       [185:19] ? len <= 4
        cmp_185_19:
        cmp qword [rsp - 804], 4
        jg if_else_183_9
        jmp if_185_19_code
        if_185_19_code:
;           [186:13] print(prompt2.len, prompt2)
;           [186:19] allocate named register 'rdx'
            mov rdx, prompt2.len
;           [186:32] allocate named register 'rsi'
            mov rsi, prompt2
;           [22:6] print(len : reg_rdx, ptr : reg_rsi) 
            print_186_13:
;               [186:13] alias len -> rdx  (lea: , len: 0)
;               [186:13] alias ptr -> rsi  (lea: , len: 0)
;               [23:5] mov(rax, 1)
;                   [23:14] 1
;                   [23:14] 1
;                   [23:14] 1
                    mov rax, 1
;               [23:19] # write system call
;               [24:5] mov(rdi, 1)
;                   [24:14] 1
;                   [24:14] 1
;                   [24:14] 1
                    mov rdi, 1
;               [24:19] # file descriptor for standard out
;               [25:5] mov(rsi, ptr)
;                   [25:14] ptr
;                   [25:14] ptr
;                   [25:14] ptr
;               [25:19] # buffer address
;               [26:5] mov(rdx, len)
;                   [26:14] len
;                   [26:14] len
;                   [26:14] len
;               [26:19] # buffer size
;               [27:5] syscall()
                syscall
;               [186:13] free named register 'rsi'
;               [186:13] free named register 'rdx'
            print_186_13_end:
;           [187:13] continue
            jmp loop_176_5
        jmp if_183_9_end
        if_else_183_9:
;           [189:13] print(prompt3.len, prompt3)
;           [189:19] allocate named register 'rdx'
            mov rdx, prompt3.len
;           [189:32] allocate named register 'rsi'
            mov rsi, prompt3
;           [22:6] print(len : reg_rdx, ptr : reg_rsi) 
            print_189_13:
;               [189:13] alias len -> rdx  (lea: , len: 0)
;               [189:13] alias ptr -> rsi  (lea: , len: 0)
;               [23:5] mov(rax, 1)
;                   [23:14] 1
;                   [23:14] 1
;                   [23:14] 1
                    mov rax, 1
;               [23:19] # write system call
;               [24:5] mov(rdi, 1)
;                   [24:14] 1
;                   [24:14] 1
;                   [24:14] 1
                    mov rdi, 1
;               [24:19] # file descriptor for standard out
;               [25:5] mov(rsi, ptr)
;                   [25:14] ptr
;                   [25:14] ptr
;                   [25:14] ptr
;               [25:19] # buffer address
;               [26:5] mov(rdx, len)
;                   [26:14] len
;                   [26:14] len
;                   [26:14] len
;               [26:19] # buffer size
;               [27:5] syscall()
                syscall
;               [189:13] free named register 'rsi'
;               [189:13] free named register 'rdx'
            print_189_13_end:
;           [190:13] print(len, address_of(input_buffer))
;           [190:19] allocate named register 'rdx'
            mov rdx, qword [rsp - 804]
;           [190:24] allocate named register 'rsi'
;           [190:24] address_of(input_buffer)
;           [190:24] address_of(input_buffer)
;           [190:24] rsi = address_of(input_buffer)
;           [190:24] address_of(input_buffer)
            lea rsi, [rsp - 284]
;           [22:6] print(len : reg_rdx, ptr : reg_rsi) 
            print_190_13:
;               [190:13] alias len -> rdx  (lea: , len: 0)
;               [190:13] alias ptr -> rsi  (lea: , len: 0)
;               [23:5] mov(rax, 1)
;                   [23:14] 1
;                   [23:14] 1
;                   [23:14] 1
                    mov rax, 1
;               [23:19] # write system call
;               [24:5] mov(rdi, 1)
;                   [24:14] 1
;                   [24:14] 1
;                   [24:14] 1
                    mov rdi, 1
;               [24:19] # file descriptor for standard out
;               [25:5] mov(rsi, ptr)
;                   [25:14] ptr
;                   [25:14] ptr
;                   [25:14] ptr
;               [25:19] # buffer address
;               [26:5] mov(rdx, len)
;                   [26:14] len
;                   [26:14] len
;                   [26:14] len
;               [26:19] # buffer size
;               [27:5] syscall()
                syscall
;               [190:13] free named register 'rsi'
;               [190:13] free named register 'rdx'
            print_190_13_end:
;           [191:13] print(dot.len, dot)
;           [191:19] allocate named register 'rdx'
            mov rdx, dot.len
;           [191:28] allocate named register 'rsi'
            mov rsi, dot
;           [22:6] print(len : reg_rdx, ptr : reg_rsi) 
            print_191_13:
;               [191:13] alias len -> rdx  (lea: , len: 0)
;               [191:13] alias ptr -> rsi  (lea: , len: 0)
;               [23:5] mov(rax, 1)
;                   [23:14] 1
;                   [23:14] 1
;                   [23:14] 1
                    mov rax, 1
;               [23:19] # write system call
;               [24:5] mov(rdi, 1)
;                   [24:14] 1
;                   [24:14] 1
;                   [24:14] 1
                    mov rdi, 1
;               [24:19] # file descriptor for standard out
;               [25:5] mov(rsi, ptr)
;                   [25:14] ptr
;                   [25:14] ptr
;                   [25:14] ptr
;               [25:19] # buffer address
;               [26:5] mov(rdx, len)
;                   [26:14] len
;                   [26:14] len
;                   [26:14] len
;               [26:19] # buffer size
;               [27:5] syscall()
                syscall
;               [191:13] free named register 'rsi'
;               [191:13] free named register 'rdx'
            print_191_13_end:
;           [192:13] print(nl.len, nl)
;           [192:19] allocate named register 'rdx'
            mov rdx, nl.len
;           [192:27] allocate named register 'rsi'
            mov rsi, nl
;           [22:6] print(len : reg_rdx, ptr : reg_rsi) 
            print_192_13:
;               [192:13] alias len -> rdx  (lea: , len: 0)
;               [192:13] alias ptr -> rsi  (lea: , len: 0)
;               [23:5] mov(rax, 1)
;                   [23:14] 1
;                   [23:14] 1
;                   [23:14] 1
                    mov rax, 1
;               [23:19] # write system call
;               [24:5] mov(rdi, 1)
;                   [24:14] 1
;                   [24:14] 1
;                   [24:14] 1
                    mov rdi, 1
;               [24:19] # file descriptor for standard out
;               [25:5] mov(rsi, ptr)
;                   [25:14] ptr
;                   [25:14] ptr
;                   [25:14] ptr
;               [25:19] # buffer address
;               [26:5] mov(rdx, len)
;                   [26:14] len
;                   [26:14] len
;                   [26:14] len
;               [26:19] # buffer size
;               [27:5] syscall()
                syscall
;               [192:13] free named register 'rsi'
;               [192:13] free named register 'rdx'
            print_192_13_end:
        if_183_9_end:
    jmp loop_176_5
    loop_176_5_end:
    ; system call: exit 0
    mov rax, 60
    mov rdi, 0
    syscall

panic_bounds:
;   print message to stderr
    mov rax, 1
    mov rdi, 2
    lea rsi, [msg_panic]
    mov rdx, msg_panic_len
    syscall
;   line number is in `rbp`
    mov rax, rbp
;   convert to string
    lea rdi, [num_buffer + 19]
    mov byte [rdi], 10
    dec rdi
    mov rcx, 10
.convert_loop:
    xor rdx, rdx
    div rcx
    add dl, '0'
    mov [rdi], dl
    dec rdi
    test rax, rax
    jnz .convert_loop
    inc rdi
;   print line number to stderr
    mov rax, 1
    mov rsi, rdi
    lea rdx, [num_buffer + 20]
    sub rdx, rdi
    mov rdi, 2
    syscall
;   exit with error code 255
    mov rax, 60
    mov rdi, 255
    syscall
section .rodata
    msg_panic: db 'panic: bounds at line '
    msg_panic_len equ $ - msg_panic
section .bss
    num_buffer: resb 21

; max scratch registers in use: 5
;            max frames in use: 7
;               max stack size: 804 B
