[ ] initializer of arrays: var str : i8[] = {0x61, 0x41}
[ ] nasm_operand in ident_info for less text processing sprinkled in the code?
[ ] toc::rep_movs: heuristics around when to switch from movs to rep
[ ] initializer for types that contain array does not work as intended:
    var input_buffer : str = {0, 0} where second element is an array
[ ] review "//?" comments
[ ] review "todo" comments
[ ] array_copy does not handle when destination overlaps source
[ ] lea_path not be necessary since only most recent lea relevant
    => also index of where in elems path lea was found
[ ] fix better the re-occurring code:
            if (arg.is_identifier() and
                (arg.is_expression() or tc.make_ident_info(arg).has_lea())) {
[ ] stmt_identifier: 358: if register will be just offset without indexing
    register then that can be calculated in init_reg_offset
[ ] expr_ops_list: tidy asm_op_xxx with more streamlined flow of make_ident
[ ] const allowed in function declaration and code
    foo(ix : const i32) { const x = ix }
[ ] expr_*: pre-calculate consts
[ ] C++ brace initializers offer no performance advantage and the narrowing
    issues do not exist in this project. they are ugly. ponder switching to =
[ ] refactor the passing first token to every constructor. push back and
    construct
[ ] ponder an iterator of elements in array that does not require bounds
    checking:
      for(e : arr) {
        e = 0
      }
[ ] ponder whether a compiler flag to check for over/underflow in arithmetics
[ ] a return reference might be used as an argument to a function that set it.
    current UB detection does not allow that
[ ] break: exit current block instead of just loop?
[ ] regex is not performant. replace with hand-rolled string operations
[ ] some improvements (performance wise) of toc::indent using a buffer on the
    stack
    => do perf tests first using etc/perf.sh
[ ] implement "size_of" for fields
[ ] review code before next step
[ ] lut: change to map
[ ] make unary_ops trivially copyable by using a fixed array instead of vector
[ ] immediate value can maximum be 32 bit. handle that at initiation of var
[ ] parsing comments in single statement block fails:
        if nibble > 9 nibble = nibble + 0x41 # 0 through 9
        else nibble = nibble + 0x30
[ ] etc/run-test with peak memory usage and inspect why some test cases use so
    much more memory than other
[ ] toc::get_stack_size -> keep track of it with a member variable
[ ] a way to initiate a i8 array with a string:
    var hello : i8[] = "hello world"
[ ] allow trailing comma at type definition. e.g:
    type object {
        pos : point,
        color : i32,
    }
[ ] using size_t (8 bytes) is a bit much for certain uses cases such as lineno
[ ] allow declaration of instance without initializer, zero it
    => var o : object[1] then accessed through o.pos does that
[ ] review the reading of white spaces sprinkled about
[ ] instrumentation to find out max heap and stack usage by the compiler
[ ] handle constant array index case
[ ] argument to the compiler specifying stack size
[ ] expr_ops_list: const eval
[ ] numbers such as i8 : 255 cause problems when cmp because value is moved
    to unspecified register size with sign extension
[ ] array implicit identifiers. var ar[10] ar.len
[ ] catch edge cases when dealing with constant. byte -128 - 127 etc since cmp
    sign-extends loads
[ ] handle case where x86_64 cannot load immediate 64 bit value to memory
[ ] when passing an array as an argument the call can insert quasi variables
    for length. fat pointers
[ ] stmt_call: check arguments vs parameters in constructor instead of at
    compile
[ ] review bool_ops_list + bool_op parsing considering the whitespaces handling
[ ] consider refactoring to 1 pass compiler making compiling in constructor
    constructor(os data,os code,indent)
[ ] implement strings
[ ] support for float and double?
[ ] rename compiler_exception
[ ] specify whether ok for an op to truncate value instead of error
    => it is no longer an error
[ ] simple LSP supporting rename

--------------------------------------------------------------------------------
resolved ([x]: done [-]: not completed with reason specified)
--------------------------------------------------------------------------------
[x] expr_type_value::compile_assign: checks types, array sizes etc
[x] expr_type_value: is a mess. make nicer
    => reduced indentation by one level. a tree och code paths, not too bad
[x] expr_type_value has 2 responsibilities: when it is "= { ... }" or
    "= obj.x". should be split into: expr_type_value_assign and
    expr_type_value_initialize
    => unified and better recursion, but it is a mess
[x] the last issue when using cppcoreguidelines-avoid-const-or-ref-data-members
    at linting are the const refs
    => pointers instead of refs in structs and classes, better? unless
       shared_ptr still dangling problem
[x] code after "return", "break" and "continue" is dead code. generate error
    because UB check can be fooled by code after "break" or "continue"
    => ignore statements after "end-of-code-path" statement
       => virtual statement::is_code_after_this_unreachable()
[x] array size 0 or negative should not be allowed
[x] initializer of variable optional and if omitted zero
[x] optimize rep stosX, movX and repe cmpsX to q, d, w if possible
    => if more than X number of required mov use `rep`
    => heuristics about when to use "rep stosX" 
       => start with stosq, then mov dword, word and byte
       => works when size is known at compile-time
       [x] if less than 32 bytes do moves, else try rep stosq and
           if not evenly divisible by 8 rep stosb
    => affected: stmt_def_var, stmt_assign_var, stmt_arrays_equal
       => stmt_arrays_equal size not known at compile-time
    => see vmovntdq for 32 B aligned data
       see AVX-512
    [x] if evenly divisible of 8 then rep stoq
        [x] for non evenly divisible do the mov dword, word, byte
[x] neovim: tree-sitter and color scheme
    => tree-sitter color scheme done
[x] review function signatures
[x] check function argument is array or not vs argument
    [x] for simple foo(arr) when arr can be aliased
    [x] for other foo(polygons[1].indices) not easy
[-] ponder having traditional return statement instead of return variable
    => return variable is a reference. if returns expression then it might be
       necessary to create temporary variables while computing the result
       instead of just writing to the reference
[x] ;       [156:32] free scratch register 'r11'
            mov r14, qword [r13 + r12 * 8 + 0]
[x] bounds checking: line number is moved twice during the same check. fix
[x] test and js slightly better
[x] bounds checking: if array indexing are within a range a single unsigned
    comparison is enough assuming positive negative numbers are smaller than
    possible positive numbers. compiler flag
    => use option "upper"
[x] bounds checking does not catch negative array indexes
[x] t56: fails with negative numbers because they are not sign extended when
    using scratch register in expr_ops_list
[x] see edge case t116 'c' should not be 2
    => it should be 2 because the returned value is not a reference to the
       argument
[x] find where displacement in generated assembler is 0 and fix it:
    e.g. r15 + r14 * 4 - 0
    => in stmt_assign_var: fixed
[x] t79 generates asm: mov dword [rsp + r15 * 4 - 16 + 0], r13d
[x] stmt_call: 176: see comment, is that correct? 
    => was a bug
[x] ident_info: the stack of "lea" might not be necessary: lea is set when base
    identifier address is in a register
[x] t112: optimize:
            mov r11, r15
            movsx r12, byte [r11 + 128]
          to
            ; mov r11, r15
            movsx r12, byte [r15 + 128]
[x] stmt_identifier: optimize known offset by returning "r15 + 20" etc instead
    of add r15, 20
[x] expr_ops_list: 313 and expr_bool_op: 453 are a hack. fix
[x] toc::lea instead of generic command
[x] arguments const vector and returns of const vector to span
[x] function arguments as array of user types (nested)
[x] function arguments as arrays:
    func write_to_array(res : i64[]) {
        res[1] = 2
    }
[x] UB if the return value is used as an argument in a expr_any before set
[x] more precise indication of where in the source the uninitialized variable
    is used
[x] var x = foo() becomes UB if foo does not set the return value
    is_var_set(var, block) : bool
      for each s in statements:
        s is assign var return true
        s is if: (ignored since condition is not known at compile time)
                 return is_var_set(else_block, var)
        s is call: return is_var_set(func_block, func_var_bound_to_var)
                                 can be argument or return
        s is break return false
    stmt_block::is_var_set(var_name) -> bool
       stmt_assign_var::is_var_set(var_name) -> bool
          ? what if expr_any contains uninitialized var_name?
          stmt_expr_any::is_var_used(var_name) -> bool
       stmt_if::is_var_set(var_name) -> bool
          else_.is_var_set(var_name)
       stmt_call::is_arg_set(arg_idx) - > bool
       stmt_call::is_return_set() -> bool
    program:
      for each f in funcs:
        if f returns stmt_func::is_return_set()
    => done in a simpler way
[-] replace the regex with manual string manipulation for performance?
    => duplicate
[x] put all regex construction in toc
    => public members: regex_XXX
[x] token: regex construction to static
    => all regex pre-compiled as const in toc
[x] don't allow indexing on a non-index var
[x] check that everything that can be const is in function arguments also
[x] check that everything that can be const is in constructors
[x] use asm command 'test' instead of 'cmp' when checking for constant 0
[-] consider mapping execution paths in a tree to find out if a variable is
    always assigned
    => duplicate, only valid for returns
[-] check that return value is assigned in functions
    => should check all execution paths to find out if the variable is always
       assigned now it may result in undefined behavior because the compiler
       checks that the return value is set in any branch of execution
       => duplicate
[x] a more detailed compilation option: bounds check with line numbers
    cmp r14, 8
    mov rsi, 42           ; Line number for first check
    cmovge rax, rsi       ; Move line number to rax if r14 >= 8
    jge panic_bounds

    ; For the second check
    cmp rcx, 8
    mov rsi, 87           ; Line number for second check
    cmovg rax, rsi        ; Move line number to rax if rcx > 8
    jg panic_bounds
    => ./baz prog.baz 65536 checked line
[x] review where compiler_exceptions happen and try to make good source
    location reports
[x] review that source locations are accurate in gen.s comments
    [x] stmt_address_of.hpp
    [x] stmt_array_copy.hpp: more comments about src and dst
    [x] stmt_arrays_equal.hpp: more comments about src and dst
    [x] stmt_array_size_of.hpp
    [x] stmt_assign_var.hpp
    [x] stmt_block.hpp
    [x] stmt_break.hpp
    [x] stmt_call_asm_mov.hpp
    [x] stmt_call_asm_syscall.hpp
    [x] stmt_call.hpp
    [x] stmt_comment.hpp
    [x] stmt_continue.hpp
    [x] stmt_def_field.hpp
    [x] stmt_def_func.hpp: no comments
    [x] stmt_def_func_param.hpp: no comments
    [x] stmt_def_type_field.hpp: no comments
    [x] stmt_def_type.hpp: no comments
    [x] stmt_def_var.hpp
    [x] stmt_identifier.hpp
    [x] stmt_if_branch.hpp
    [x] stmt_if.hpp
    [x] stmt_loop.hpp
    [x] stmt_return.hpp
    [x] stmt_size_of.hpp
    [x] expr_any.hpp
    [x] expr_bool_op.hpp
    [x] expr_bool_ops_list.hpp
    [x] expr_ops_list.hpp
    [x] expr_type_value.hpp
[x] stmt_identifier generates: mov qword [r15 + r14 * 8 + 0], 0xffee
[x] arguments to baz regarding stack size and bounds checking
    ./baz (prog.baz 131072 checked)
    ./baz file.baz (131072 checked)
    ./baz file.baz 65536 (checked)
    ./baz file.baz 65536 unchecked
[x] bounds check array access (optional compiler flag)
    [x] least intrusive is two instructions:
        cmp r14, 8 ; r14 is result of index calculation, 8 is array size
        jge panic
    [x] handle offset in array: e.g, 2 + 6 <= array_size_of(arr1)
        array_copy(arr1[2], arr2, 6)
        arrays_equal(arr1[2], arr2[1], 3)
    => boolean argument to toc if bounds checks to be done
[x] an efficient way of comparing two arrays or instances:
    bool equal = array_equal(src, dst, nelements)
      works with instances also when nelements is 1 
    ; Compare two memory regions
    ; rsi = pointer to slice1
    ; rdi = pointer to slice2
    ; rcx = length in bytes
    ; Returns: ZF=1 if equal, ZF=0 if different
    cld              ; Clear direction flag (forward)
    repe cmpsb       ; Repeat while equal, compare bytes
    ; After: ZF=1 if equal, ZF=0 if not equal
    je equal
    jne not_equal
    => arrays_equal(arr1, arr2, nelements)
[x] a way to efficiently copy arrays:
    e.g., copy_array(buf[2], buf, 10)
    copies from second element to base 10 elements
    => array_copy(src, dst, nelements)
       works with non arrays also as side effect
[x] array_copy: validate that source and destination same type
[x] tokenizer: handle string with escaped " 
[x] token: handle character ' in string 
[x] considering not parsing multiple return statements
    => done
[x] handle constants when deducing operand size 
     => deduce if possible to the size of the desired type
     => constant is sized to destination type size
[x] token: consider using string_view since string for name is not necessary
    because source will not change during its lifetime
[-] support assigning strings to i8 arrays
    => duplicate issue
[-] consider a built-in function "lea" that returns the address of an
    identifier. purpose: to be able to use "var" for read and write
    to console
    => implemented as `address_of`
[x] usage of ad-hoc strings specifying destination of result from an exception
    is messy, same as assembler operation size, review
    [-] toc: consider abstracting registers into a class for less quirky string
        manipulations
    => toc::asm_cmd handles that with some minimal string handling
       the idea is that when compiler requires assembler it sends the src and
       dst with size specified in the strings and asm_cmd handles the
       conversions since it is a assembler level operation
[x] allow block to be create by user for context: { var i = 2 { var i = 3 }}
[x] switch from streams to std::print
    [x] toc
    [x] rest
[x] allow shadowing of variables
[x] a way of using "read" and "write" functions with var buffers:
    read(address_of(buf), size_of(buf)) does:
    lea dst, [....]
    also handles if "dst" is not a register
    => experimental "address_of"" implemented: accepts variable as in and out
       must be register
    => implemented "array_size_of(...)"
    => done without the limitation of "address_of" to register only
    => checks that destination is type i64
[x] allow anonymous blocks inside block {...}
[x] fix the mess of string handling when truncating
    => remarkably, a few string based handling and it functions as intended
[x] fix the mess in toc::asm_cmd
    => it is not too bad. the complexity regarding different sized arguments
       isolated in that functions
[-] refactor the string handling of register and memory operand sizes
[x] adjust source so it passes also MSAN
    -fsanitize=undefined,integer
    => undefined passes
       integer breaks at common use of: while (n--)
[x] refactor to use std::string_view
[x] refactor for structs to be POD with pointers instead of refs
[x] use std::string_view where possible instead of std::string
    e.g. in expr_bool_op to return constexpr strings
[o] tidy
    [x] use std::format
    [-] rep movsb can be done faster with q if objects are sized to 2^n
        => duplicate issue
    [-] toc.allocate_named_register_or_throw requires statement for src_loc_tk
[x] try different compilation errors and improve messages and source position
    indicators
[x] source differs when (notice - and then comment):
        print(prompt1.len, prompt1)
        var len = read(input.len, input) -     # -1 don't include the '\n'
        if len == 0 {
    => source now ok
       problem is that expr_ops_list reads comment as an expression
       it is a not easily fixable bug
       => fixed with error: unexpected comment in expression
[x] tokenizer: keep track of line-number instead of computing it
    => problem when generating comments in the result with excessive calling
       ok for for reporting parsing error
       => keeps track of line numbers, calculates column at request
[x] source recreation does not work with comment at end of file and
    newlines:
        var objs : object[10]
        objs[1].pos.y = 0xab
        # hello

      }
[x] improve source location token in stmt_identifier
    [x] accurate position on identifier that cannot be found
[x] assume "x" is "x[0]"
[x] adapt to be able to use -Wunsafe-buffer-usage
    [-] implement a buffer safe parse integer function in toc
        => that portion is marked as "safe" to clang
    [x] handle arguments to main appropriately 
        => cannot be done so that section is marked as "safe" to clang
[x] optimize array indexing using lea
    [x] does not do the multiplication if type size is 1
    [x] the special case of array of built-in type single implement identifier
        path
        => handled by general case
    [x] use "shl" if type size 2^n
    [x] use mov [base + index * scale + disp] type of instructions to optimize
        store to and from array
        [x] support special case of identifier with one element, array index
            with supported size for effective memory scaling
[x] implement arrays
    => exploratory quick and dirty coding of arrays for primitives: ok
       [x] initialize arrays to 0
       [x] lea instruction should use scaling if type size 2, 4 or 8
       [x] multiplication by 1 is not necessary, post compilation optimized
           => types of size 1, 2, 4, 8 are specified in instruction lea
       [x] if array type 1, 2, 4, 8  use lea with scaling
       [-] allow types to be power of 2 sizes only and use shift instead of
           multiplication
           => the compiler chooses 'shl' if size is 2^n
       [x] support indexing in user defined types: e.g. obj[x].pts[y].x = z
[x] bool_ops_list: does not throw parsing error:
    var b : bool = (true == false
[x] use C++23 facilities to convert string to number instead of 'strtol'
[x] parsing error not correct when 'foo(p:point)'
    var o1 : object = {{x * 10, y}, 0xff0000}
    foo(o1)
[x] nicer formatting of generated source
        ; Standard Assembly Formatting (Intel/NASM style)
        mov     qword [rsp - 24], 3
        mov     r15, qword [rsp - 24]
        lea     r15, [rsp + r15 * 4 - 16]
        mov     r13, qword [rsp - 24]
        sub     r13, 1
        lea     r13, [rsp + r13 * 4 - 16]
        movsx   r14, dword [r13]
[-] stmt_call: enable nested use of named registers
      example: f(x+1,x) where x is argument that was passed through register and the
      first argument to f is the same register then the second argument is clobbered
[-]   non-inlined
[x]   inlined
[-] optimize stack adjustment between calls
      call bar
      add rsp,40
      sub rsp,24
      call foo
      => obsoleted since only in-lined functions allowed
[-] optimize return pattern:
       mov qword[rbp-8],r15
       mov rax,qword[rbp-8]
       pop rbp
       ret
    to
       mov rax,r15
       pop rbp
       ret
      => obsoleted since only in-lined functions allowed
[-] stmt_call: use std::source_location in panic exception
    => string in exception is unique
[-] unary_ops: use std::source_location in panic exception
    => string in exception is unique
[x] fix 'cmp' with left hand side constant 
    => moves lhs to register and makes compilation. todo: if lhs and rhs are constants evaluate
       at compile time
       => the if does the constant evaluation never reaching cmp assembler command
[x] expr_ops_list: does calculate e*b/a + (b % (-a)) 
    fix t47.baz:
    c = a - e*b/a + (b % (-a))
    if not c==4 exit(17)
    => c = (a - e*b/a) + (b % (-a))  ok
       c = a - e*b/a + (b % (-a)) not ok
       expr_ops_list does:
       c = a - (   e*b/a + (b % (-a))  ) 
[x] bool_ops_list fix:
    var t1 = 5
    var t2 = 5
    var t3 = 10
    var t4 = 2
    var t5 : bool = false
    var h9 : bool = not ( (t1 + t2 + t3 + t4) > 20 and not t5 ) and (t3 / 5 > 1 or t4 / 1 == 2)
[x] bool_ops_list: there can be no spaces between ( () )
[x] find out why toc.source_comment does not remove trailing spaces
[x] var u : bool = not ( (false or true) and not (true and false) ) or (x > 10)
                 => false
[x] t69.baz has commented samples that break baz
[x] refactor parsing of bool_ops_list and check compilation:
    => don't allow mixing of 'or's and 'and's without parenthesis greatly
       reduces the complexity. (same like in C++)
[x] var w : bool = (x + y <= z) and (not (z == 4) or (x == 1 and y == 3))
[x] bool_ops_list:
    var r : bool = (x + y <= z)  and (not (z == 4) or (x == 1 and y == 3))
[x] toc: review the is_variable_initiated and set_variable_initiated
        case '<': // shift left
        case '>': // shift right
            return 4;
    regarding registers (get_id_and_frame_for_identifier is dubious)
[x] consider removing support for non-inlined functions because it is out of scope
    => intention of program is super-loop non-reentrant inlined functions
[x] replace all {0} and {false} to default {}
[x] make auto for all functions with trailing return
[x] better format
[x] adjust for neovim clangd development
[x] type.hpp:66: why by reference in: const string &memsize{get_memory_operand_for_size(tk, tp_first_field->size())}
    => get_memory_operand_for_size now returns const std::string&
[-] allow non-register types to functions
    => pass address to argument through stack
[-] allow return types to be non-registers
    => pass address to return through stack 
[x] replace endl with '\n'
[x] consider disabling function definitions and calls without ()
[x] calculate stack size at compile time instead of hardcoded
[x]   calculate max stack size used
[x] fix 'cmp' with left hand side constant => compilation error instead of further complications
    => "if 1 + 1 == x" is not considered constant because expr_ops_list does not support
        constant evaluation 
[x] change vector indexing to safer .at(i)
[-] pointers?
    => try without
[x] toc: rename baz_ident
    => identifier
[x] clean-up:
[x]     toc
[x]     statement
[x]     stmt_return
[x]     stmt_breaks
[x]     stmt_continue
[x]     stmt_loop
[x]     stmt_comment
[x]     stmt_block
[x]     stmt_if
[x]     stmt_if_branch
[x]     stmt_def_var
[x]     stmt_assign_var
[x]     stmt_def_field
[x]     stmt_def_type
[x]     stmt_def_type_field
[x]     expression
[x]     expr_any
[x]     expr_type_value
[x]     call_asm: deleted
[x]     call_asm_syscall
[x]     call_asm_mov
[x]     compiler_exception
[x]     panic_exception
[x]     decouple.hpp
[x]     stmt_def_func
[x]     stmt_def_func_param
[x]     stmt_call
[x]     expr_ops_list
[x]     bool_op
[x]     bool_ops_list (the 'not' and sub-expressions makes it complex)
[x]     unary_ops
[x]     tokenizer
[x]     token
[x]     lut
[x]     main.cpp[x] review new code
[x] "#comment" should be accepted as "# comment"
[-] process generated asm to remove duplicate labels
    => was error in bool_ops_list
[x] coverage: bool_ops_list
[x] coverage: stmt_call
[-] func f() : point p { p = {1, 2} }
[-]    var pos : point = f()
[-]     where p refers into caller stack (rbp+xx)
    => does not work for non-inlined functions, stack is unknown, depending on caller context
[-] function arguments relative to rsp allowing writing to variable in previous function context
    => non-inlined functions don't know the stack of caller regarding how many registers where saved on the stack
[x] review main.cpp move of tokens and unary_ops
[x] modernize: pass by value and move
[x] main:create_statement_from_tokenizer review move(tk) ..
[x] var v : vector = {1, a + b, f() - 1}
[x] var o:object={{1,2},{0,0},1}
[x] o.pos = v
[x] expr_ops_list: more coverage
    => t65
[x] qa/t63 sometimes fails when run in batch. examine t63.py
    => error in t63.py
[x] f(a==1) where argument is a boolean
[x] type size{value}, var s:size=1, s.value=2 == s=2 
[x] type point{x,y}
[-] var p:point{1,2}
[-] p=point(1,2)
[x] p.x=1 == p=1
    => type point{x,y}
[x] function argument types
[x] built-in types
[x]   var b:bool=false
[x]   var c:i8=0
[x]   var w:i16=0
[x]   var d:i32=0
[x]   var q:i64=0   var q=0  i64 is default
[-]   var x=c+w+d+q gives error, not matching types, no implicit conversion
[x]      built-in integer (registers) allowed to size up to 'i64'
[-]   var x=i8(c)+i16(w)+i32(w)+i64(d): deduced size i64
[x]   var c=i gives error, source type size is larger than destination
[x] user defined types
[-]   typedef size i64?  alias size i64?
[-]     var i=1 var s=size(i) i=s gives error i=quad(s) 
[x]   type vector{x,y} type object{pos:vector,vel:vector,color:i8}
[-]     var o=object({1,2},{0,0},1)
[-] bool_op_list use cmovexx when assignment
    => simplicity trumps complexity of generating the assembler
[x] better coverage of bool_op. qa/see coverage-report
[x] source location of a character index counts tabs as one character
    => editor set to treat tabs as spaces
[x] clang-format everything for less dense code?
    => visual code formatter
[x] review the declaration of default move,copy,constructor in every class
     -> although redundant it declares intention. keep.
[x] fix 'cmp' two constants case
      -> messy code that does dead-code elimination
[x] bool_op: implement !=
[x] use expr_any in stmt_assign_var
[-] bool_op: implement ! (logical not) -> same as "not a"
[x] clean-up: consistent function arguments names
[x] toc.allocate_named_register_or_break: if allocated then tell where
[x] toc.add_field: if defined tell where
[x] toc.add_function: if defined tell where
[x] toc.add_var: if defined tell where
[x] toc.add_var(...) check if name shadows -> consider in-lined functions
[-] examine expression, expr_ops_list, stmt_call relation
[-]   circular reference stmt_call -> expr_ops_list -> stmt_call
[-] decouple by implementing functions that cause circular references in decouple.cpp
[-]    block -> if,loop -> block
[-]    block -> call (in-lined) -> block
[-]    cannot without making field in declaration of 'if' and 'loop' to unique_ptr<stmt_block>
[x] make sub lists taking in account precedence of 'and' over 'or'
      i.e. 'a or b and c or d' -> 'a or (b and c) or d'
[x]   review/remake messy code -> messy but readable and simple
[-] token.is_empty maybe same as is_name("") instead of considering whitespaces
    -> stmt_block depends on is_empty() considering whitespaces also
[x] short-hand boolean expression i.e. if a or b
[x] compile error when i.e.:
      var b=-b-(-1) # b is used before initiated
[x] expr_ops_list: div: push/pop rax,rdx if not allocatable
[x] expr_ops_list: shift: push/pop rcx if not allocatable
[-] expr_ops_list: src.get_unary_ops().get_ops_as_string()+src_r.id -> src.as_const()
    -> resolved identifier might differ from src.identifier
[-] compile for pczero task -> pczero is 32bit
[x] negated sub-expression. i.e. 'not (a=1 and b=2)'
[x]   review
[x] unary decoration parsed prior to any statement. i.e. '~-a', '~-f(o)'
[x]   review
[x] bitwise logical ops: & | ^
[x]   review
[x] op shift left and right
[x]   review
[x] implement division op
[x]   review
[x] stmt_call::vector<expr_ops_list> instead of unique pointer
    -> tag prior refactoring 2023-04-19--8--checkpoint
[x] negated expression
[x]   support for negated expr_ops_list. i.e. a=-(1+2)
[x]   review
[x] review fragile optimze_jumps_x
[-] stmt_if_branch.code_ can be value instead of unique_ptr
    -> circular reference?
[x] statement.parent can be removed
[x] experiments with linking to the standard c library and using printf
[x] review stmt_call
[x] when calling non-inlined functions the allocated register is pushed and popped
    although it hasn't been assigned. keep track of that in toc and optimize away
    the push/pop
[x] all allocated registers pushed before a call not necessary
[x] registers get clobbered in non-inlined functions
[x] rax gets clobbered in recursive functions
[x] non-inlined function calls
[x]   review
[-]     rbp=rsp before pushing arguments and at the beginning of functions
          can be optimized if nasm ident not hard-coded [rbp+...]
        example: "rbp" or "rsp" as argument to toc.nasm_ident(ident,"rbp",displacement)
          where displacement is used when pushing arguments to compensate for the moving rsp
[x] keyword 'inline'. func inline foo()...
[x] fix generated code of "if (a=1 and b=2) or (c=3 and d=4)"
        jne cmp_14_26
        jmp if_14_8_code
        cmp_14_26:
     possibly with a post processor of nasm file
        je if_14_8_code
        cmp_14_26:
[x]   review fragile implementation
[x] fix generated code
        jmp cmp_13_26
        cmp_13_26:
[x] review the ugly 'if' code
[x] variant instead of stmt_if_bool_op_list extends stmt_if_bool_op
[x] assembler 64 bit code
[x] return statement for in-lined
[x] optimize:
        mov edi,dword[ebp+16]
        sub edi,1
        mov dword[ebp+16],edi
      to
        sub dword[ebp+16],1
[x] optimize: r=a+b+c+d
     ;  [12:11] r=a
        mov edi,dword[ebp+0]
        mov dword[ebp+16],edi
     ;  [12:13] r+b
        mov edi,dword[ebp+4]
        add dword[ebp+16],edi
     ;  [12:15] r+c
        mov edi,dword[ebp+8]
        add dword[ebp+16],edi
     ;  [12:17] r+d 
        mov edi,dword[ebp+12]
        add dword[ebp+16],edi
[x] stmt_assign_var.compile
      -> try evaluation with scratch register and evaluation without scratch register
         select the one that generates fewest instructions
-------------------------------------------------------------------------------
stage 5
-------------------------------------------------------------------------------
[ ] function return of non-register passable type
[ ]     var pos : point = foo()
[ ] func f(p : point inout) { p.x = 1 } writes to caller 'p'
[ ] func f(p : point copy) copies point to callee stack
[ ] func f(p : point const) const is default. same as "func f(p : point)"
[ ] func object(self : object inout, pos, vel, color) called when 'var o : object = {...}'
[ ] func foo(object& self, arg) can be called with o.foo(arg)
[ ] string type
[ ]   var str = "hello world"
[ ]   var len = str.len
[ ] var points : point[10] = {{1, 2}, {3, 4}}
[ ]   points[1].x = 1
[ ]   points.len
[ ] multiple return values: func f() : point pos, point vel { ... }
[ ]    var p,v = f()
[ ] consider cmovxx when evaluating a boolean expression
[ ] floating point numbers
[ ] func f(p : point) {} ... f({x, y})
[ ] expr_any: deduce expression type to bool or numbers
[ ]   is_const, is_bool_expression, is_number_expression
[ ] let i=1 creates a constant
[ ] def table{x,y,z}
[ ] token.compile assumes is_str is field (db)
[ ]   review fragile implementation
[ ] include source file: i.e. "include io" includes io.baz
[ ] inlined function call: if a named register is not available: push/pop?
[ ] post processing optimization for: var b=-(-a*-a)
      mov r15,qword[rbp-8]
      neg r15
      neg r15
      mov qword[rbp-16],r15
[ ] why is the binary so big although in-line is turned off in make.sh?




-------------------------------------------------------------------------------
stage 5
-------------------------------------------------------------------------------
[ ] function return of non-register passable type
[ ]     var pos : point = foo()
[ ] func f(p : point inout) { p.x = 1 } writes to caller 'p'
[ ] func f(p : point copy) copies point to callee stack
[ ] func f(p : point const) const is default. same as "func f(p : point)"
[ ] func object(self : object inout, pos, vel, color) called when 'var o : object = {...}'
[ ] func foo(object& self, arg) can be called with o.foo(arg)
[ ] string type
[ ]   var str = "hello world"
[ ]   var len = str.len
[ ] var points : point[10] = {{1, 2}, {3, 4}}
[ ]   points[1].x = 1
[ ]   points.len
[ ] multiple return values: func f() : point pos, point vel { ... }
[ ]    var p,v = f()
[ ] consider cmovxx when evaluating a boolean expression
[ ] floating point numbers
[ ] func f(p : point) {} ... f({x, y})
[ ] expr_any: deduce expression type to bool or numbers
[ ]   is_const, is_bool_expression, is_number_expression
[ ] let i=1 creates a constant
[ ] def table{x,y,z}
[ ] token.compile assumes is_str is field (db)
[ ]   review fragile implementation
[ ] include source file: i.e. "include io" includes io.baz
[ ] inlined function call: if a named register is not available: push/pop?
[ ] post processing optimization for: var b=-(-a*-a)
      mov r15,qword[rbp-8]
      neg r15
      neg r15
      mov qword[rbp-16],r15
[ ] why is the binary so big although in-line is turned off in make.sh?

