#pragma once

#include"statement.hpp"
#include"toc.hpp"
#include"tokenizer.hpp"
#include"stmt_def_field.hpp"
#include"stmt_def_func.hpp"
#include"stmt_def_type.hpp"

class stmt_program final:public statement{
public:
	inline stmt_program(const string&source):
		statement{token{}},
		tc_{source}
	{
		// add built-in assembler calls
		vector<string>assem{"mov","syscall"};
		for(const string&s:assem)
			tc_.add_func(*this,s,"",nullptr);

		// built-in type
		const type&type_i64 {"i64"  ,8,true};
		const type&type_i32 {"i32"  ,4,true};
		const type&type_i16 {"i16"  ,2,true};
		const type&type_i8  {"i8"   ,1,true};
		const type&type_bool{"bool" ,1,true};
		tc_.add_type(*this,type_i64);
		tc_.add_type(*this,type_i32);
		tc_.add_type(*this,type_i16);
		tc_.add_type(*this,type_i8);
		tc_.add_type(*this,type_bool);

		tokenizer t{source};
		while(true){
			token tk{t.next_token()};
			if(tk.is_empty()){
				if(t.is_eos())
					break;
				throw compiler_error(tk,"unexpected '"+string{t.next_char()}+"'");
			}
			if(tk.is_name("field")){
				stms_.emplace_back(make_unique<stmt_def_field>(tc_,move(tk),t));
			}else if(tk.is_name("func")){
				stms_.emplace_back(make_unique<stmt_def_func>(tc_,move(tk),t));
			}else if(tk.is_name("type")){
				stms_.emplace_back(make_unique<stmt_def_type>(tc_,move(tk),t));
			}else if(tk.is_name("#")){
				stms_.emplace_back(make_unique<stmt_comment>(move(tk),t));
			}else if(tk.is_name("")){
				stms_.emplace_back(make_unique<statement>(move(tk)));
			}else{
				throw compiler_error(tk,"unexpected keyword '"+tk.name()+"'");
			}
		}
	}

	inline stmt_program()=default;
	inline stmt_program(const stmt_program&)=default;
	inline stmt_program(stmt_program&&)=default;
	inline stmt_program&operator=(const stmt_program&)=default;
	inline stmt_program&operator=(stmt_program&&)=default;

	inline void source_to(ostream&os)const override{
		statement::source_to(os);
		for(const auto&s:stms_)
			s->source_to(os);
	}

	inline void compile(toc&tc,ostream&os,size_t indent,const string&dst="")const override{
		os<<"; generated by baz\n\n";
		os<<"true equ 1\nfalse equ 0\n";

		os<<"\nsection .data\nalign 4\n";
		for(const auto&s:stms_)
			if(s->is_in_data_section())
				s->compile(tc,os,indent);

		os<<"\nsection .bss\nalign 4\nstk resd 1024\nstk.end:\n";
		os<<"\nsection .text\nalign 4\nbits 64\nglobal _start\n_start:\nmov rsp,stk.end\nmov rbp,rsp\njmp main\n\n";
		for(const auto&s:stms_)
			if(not s->is_in_data_section())
				s->compile(tc,os,indent);

		// get the main function and compile
		const stmt_def_func&main=tc.get_func_or_break(*this,"main");
		if(not main.is_inline())
			throw compiler_error(main,"main function must be declared inline");

		os<<"main:"<<endl;
		tc.enter_func("main","","",true,"");
		main.code().compile(tc,os,indent);
		tc.exit_func("main");
	}

	inline void build(ostream&os){
		tc_={tc_.source()};
		// add built-in assembler calls
		vector<string>assem{"mov","syscall"};
		for(const string&s:assem)
			tc_.add_func(*this,s,"",nullptr);

		// built-in type
		const type&type_i64 {"i64"  ,8,true};
		const type&type_i32 {"i32"  ,4,true};
		const type&type_i16 {"i16"  ,2,true};
		const type&type_i8  {"i8"   ,1,true};
		const type&type_bool{"bool" ,1,true};
		tc_.add_type(*this,type_i64);
		tc_.add_type(*this,type_i32);
		tc_.add_type(*this,type_i16);
		tc_.add_type(*this,type_i8);
		tc_.add_type(*this,type_bool);

		compile(tc_,os,0);

		tc_.finish(os);
	}


private:
	vector<unique_ptr<statement>>stms_;
	toc tc_;
};
