#pragma once

#include "statement.hpp"
#include "stmt_def_field.hpp"
#include "stmt_def_func.hpp"
#include "stmt_def_type.hpp"
#include "toc.hpp"
#include "tokenizer.hpp"

class program final {
  // built-in type
  type type_void{"void", 0, true};
  type type_i64{"i64", 8, true};
  type type_i32{"i32", 4, true};
  type type_i16{"i16", 2, true};
  type type_i8{"i8", 1, true};
  type type_bool{"bool", 1, true};
  statement prg{}; // place-holder
public:
  inline explicit program(const string &source) : tc_{source} {
    // add built-in assembler calls
    const vector<string> assem{"mov", "syscall"};
    for (const string &s : assem)
      tc_.add_func(prg, s, type_void, nullptr);

    tc_.add_type(prg, type_i64);
    tc_.add_type(prg, type_i32);
    tc_.add_type(prg, type_i16);
    tc_.add_type(prg, type_i8);
    tc_.add_type(prg, type_bool);
    tc_.add_type(prg, type_void);

    tc_.set_type_void(type_void);
    tc_.set_type_bool(type_bool);
    tc_.set_type_default(type_i64);

    tokenizer t{source};
    while (true) {
      token tk{t.next_token()};
      if (tk.is_empty()) {
        if (t.is_eos())
          break;
        throw compiler_error(tk, "unexpected '" + string{t.next_char()} + "'");
      }
      if (tk.is_name("field")) {
        stms_.emplace_back(make_unique<stmt_def_field>(tc_, std::move(tk), t));
      } else if (tk.is_name("func")) {
        stms_.emplace_back(make_unique<stmt_def_func>(tc_, std::move(tk), t));
      } else if (tk.is_name("type")) {
        stms_.emplace_back(make_unique<stmt_def_type>(tc_, std::move(tk), t));
      } else if (tk.is_name("#")) {
        stms_.emplace_back(make_unique<stmt_comment>(tc_, std::move(tk), t));
      } else if (tk.is_name("")) {
        stms_.emplace_back(make_unique<statement>(std::move(tk)));
      } else {
        throw compiler_error(tk, "unexpected keyword '" + tk.name() + "'");
      }
    }
  }

  inline program() = default;
  inline program(const program &) = default;
  inline program(program &&) = default;
  inline auto operator=(const program &) -> program & = default;
  inline auto operator=(program &&) -> program & = default;

  inline ~program() = default;

  inline void source_to(ostream &os) const {
    for (const auto &s : stms_)
      s->source_to(os);
  }

  inline void compile(toc &tc, ostream &os, size_t indent,
                      [[maybe_unused]] const string &dst = "") const {
    os << "; generated by baz\n\n";
    os << "true equ 1\nfalse equ 0\n";

    os << "\nsection .data\nalign 4\n";
    for (const auto &s : stms_)
      if (s->is_in_data_section())
        s->compile(tc, os, indent);

    os << "\nsection .bss\nalign 4\nstk resd 1024\nstk.end:\n";
    os << "\nsection .text\nalign 4\nbits 64\nglobal _start\n_start:\nmov "
          "rsp,stk.end\nmov rbp,rsp\njmp main\n\n";
    for (const auto &s : stms_)
      if (not s->is_in_data_section())
        s->compile(tc, os, indent);

    // get the main function and compile
    const stmt_def_func &main = tc.get_func_or_throw(prg, "main");
    if (not main.is_inline())
      throw compiler_error(main, "main function must be declared inline");

    os << "main:" << endl;
    tc.enter_func("main", "", "", true, "");
    main.code().compile(tc, os, indent);
    tc.exit_func("main");
  }

  inline void build(ostream &os) {
    compile(tc_, os, 0);
    tc_.finish(os);
  }

private:
  vector<unique_ptr<statement>> stms_{};
  toc tc_{};
};
