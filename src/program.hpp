#pragma once
// reviewed: 2025-09-28

#include "compiler_exception.hpp"
#include "statement.hpp"
#include "stmt_def_field.hpp"
#include "stmt_def_func.hpp"
#include "stmt_def_type.hpp"
#include "toc.hpp"
#include "tokenizer.hpp"
#include "unary_ops.hpp"
#include <memory>
#include <ostream>
#include <span>
#include <string>
#include <string_view>
#include <vector>

class program final {
    // built-in types
    type type_void{"void", 0, true};
    type type_i64{"i64", toc::size_qword, true};
    type type_i32{"i32", toc::size_dword, true};
    type type_i16{"i16", toc::size_word, true};
    type type_i8{"i8", toc::size_byte, true};
    type type_bool{"bool", toc::size_byte, true};

    std::vector<std::unique_ptr<statement>> statements_;
    toc tc_;    // table of contents
    token ws1_; // whitespace
    size_t stack_size_{};

  public:
    program(const std::string_view source, const size_t stack_size,
            const bool bounds_check_upper, const bool bounds_check_lower,
            const bool bounds_check_with_line)
        : tc_{source, bounds_check_upper, bounds_check_lower,
              bounds_check_with_line},
          stack_size_{stack_size} {

        // create a placeholder token to use with `toc` functions
        const token prgtk{};

        // add built-in assembler calls
        tc_.add_func(prgtk, "mov", type_void, nullptr);
        tc_.add_func(prgtk, "syscall", type_void, nullptr);

        // add built-in types
        tc_.add_type(prgtk, type_i64);
        tc_.add_type(prgtk, type_i32);
        tc_.add_type(prgtk, type_i16);
        tc_.add_type(prgtk, type_i8);
        tc_.add_type(prgtk, type_bool);
        tc_.add_type(prgtk, type_void);

        // set defaults
        tc_.set_type_void(type_void);
        tc_.set_type_bool(type_bool);
        tc_.set_type_default(type_i64);

        tokenizer tz{source};
        while (true) {
            const token tk{tz.next_token()};
            if (tk.is_empty()) {
                if (not tz.is_eos()) {
                    throw compiler_exception{tk, "unexpected character"};
                }
                break;
            }
            if (tk.is_text("field")) {
                statements_.emplace_back(
                    std::make_unique<stmt_def_field>(tc_, tk, tz));
            } else if (tk.is_text("func")) {
                statements_.emplace_back(
                    std::make_unique<stmt_def_func>(tc_, tk, tz));
            } else if (tk.is_text("type")) {
                statements_.emplace_back(
                    std::make_unique<stmt_def_type>(tc_, tk, tz));
            } else if (tk.text().starts_with("#")) {
                statements_.emplace_back(
                    std::make_unique<stmt_comment>(tc_, unary_ops{}, tk, tz));
            } else if (tk.is_text("")) {
                // empty space at the end of the file; necessary for source
                // reproduction to be identical
                ws1_ = tk;
            } else {
                throw compiler_exception{
                    tk, std::format("unexpected keyword '{}'", tk.text())};
            }
        }

        assert_functions_set_return_value(tc_.get_func_defs());
    }

    program() = delete;
    program(const program&) = default;
    program(program&&) = default;
    auto operator=(const program&) -> program& = delete;
    auto operator=(program&&) -> program& = delete;

    ~program() = default;

    auto source_to(std::ostream& os) const -> void {
        for (const auto& st : statements_) {
            st->source_to(os);
        }
        ws1_.source_to(os);
    }

    auto compile(toc& tc, std::ostream& os, const size_t indent) const -> void {
        std::println(os, ";\n; generated by baz\n;\n\nDEFAULT REL\n");
        std::println(os, "section .bss\nstk resd {}\nstk.end:\n",
                     std::to_string(stack_size_));
        std::println(os, "true equ 1\nfalse equ 0");
        std::println(os, "\nsection .data");
        for (const auto& st : statements_) {
            if (st->is_in_data_section()) {
                st->compile(tc, os, indent, "");
            }
        }
        std::println(os,
                     "\nsection .text\nbits 64\nglobal _start\n_start:\nmov "
                     "rsp,stk.end\n;\n; program\n;");
        for (const auto& st : statements_) {
            if (not st->is_in_data_section()) {
                st->compile(tc, os, indent, "");
            }
        }

        // get the main function and compile
        const stmt_def_func& func_main{tc.get_func_or_throw(token{}, "main")};
        std::println(os, "main:"); // note: not necessary
        tc.enter_func("main", {});
        func_main.code().compile(tc, os, indent, "");
        tc.exit_func("main");
        std::println(os, "    ; system call: exit 0");
        std::println(os, "    mov rax, 60");
        std::println(os, "    mov rdi, 0");
        std::println(os, "    syscall");
        std::println(os);
        if (tc.is_bounds_check_upper() or tc.is_bounds_check_lower()) {
            if (not tc.is_bounds_check_with_line()) {
                std::println(os);
                std::println(os, "panic_bounds:");
                std::println(os, "    ; system call: exit 255");
                std::println(os, "    mov rax, 60");
                std::println(os, "    mov rdi, 255");
                std::println(os, "    syscall");
            } else {
                std::println(os, "panic_bounds:");
                std::println(os, ";   print message to stderr");
                std::println(os, "    mov rax, 1");
                std::println(os, "    mov rdi, 2");
                std::println(os, "    lea rsi, [msg_panic]");
                std::println(os, "    mov rdx, msg_panic_len");
                std::println(os, "    syscall");
                std::println(os, ";   line number is in `rbp`");
                std::println(os, "    mov rax, rbp");
                std::println(os, ";   convert to string");
                std::println(os, "    lea rdi, [num_buffer + 19]");
                std::println(os, "    mov byte [rdi], 10");
                std::println(os, "    dec rdi");
                std::println(os, "    mov rcx, 10");
                std::println(os, ".convert_loop:");
                std::println(os, "    xor rdx, rdx");
                std::println(os, "    div rcx");
                std::println(os, "    add dl, '0'");
                std::println(os, "    mov [rdi], dl");
                std::println(os, "    dec rdi");
                std::println(os, "    test rax, rax");
                std::println(os, "    jnz .convert_loop");
                std::println(os, "    inc rdi");
                std::println(os, ";   print line number to stderr");
                std::println(os, "    mov rax, 1");
                std::println(os, "    mov rsi, rdi");
                std::println(os, "    lea rdx, [num_buffer + 20]");
                std::println(os, "    sub rdx, rdi");
                std::println(os, "    mov rdi, 2");
                std::println(os, "    syscall");
                std::println(os, ";   exit with error code 255");
                std::println(os, "    mov rax, 60");
                std::println(os, "    mov rdi, 255");
                std::println(os, "    syscall");
                std::println(os, "section .rodata");
                std::println(os, "    msg_panic: db 'panic: bounds at line '");
                std::println(os, "    msg_panic_len equ $ - msg_panic");
                std::println(os, "section .bss");
                std::println(os, "    num_buffer: resb 21");
            }
        }
    }

    auto build(std::ostream& os) -> void {
        compile(tc_, os, 0);
        tc_.finish(os);
    }

    static auto assert_functions_set_return_value(
        const std::span<const stmt_def_func* const>& funcs) -> void {

        for (const stmt_def_func* f : funcs) {
            std::optional<func_return_info> ret_info{f->returns()};
            if (not ret_info) {
                continue;
            }
            if (not f->code().is_var_set(ret_info->ident_tk.text())) {
                throw compiler_exception(
                    f->tok(),
                    "cannot guarantee that function return value is set");
            }
            f->code().assert_no_ub_for_var(ret_info->ident_tk.text());
        }
    }
};
