#pragma once

#include "statement.hpp"
#include "stmt_def_field.hpp"
#include "stmt_def_func.hpp"
#include "stmt_def_type.hpp"
#include "toc.hpp"
#include "tokenizer.hpp"

class program final {
    // built-in types
    type type_void{"void", 0, true};
    type type_i64{"i64", 8, true};
    type type_i32{"i32", 4, true};
    type type_i16{"i16", 2, true};
    type type_i8{"i8", 1, true};
    type type_bool{"bool", 1, true};

    statement prg; // place-holder
    std::vector<std::unique_ptr<statement>> statements_;
    toc tc_;

  public:
    explicit program(const std::string& source) : tc_{source} {
        const token prgtk{prg.tok()};
        // add built-in assembler calls
        const std::vector<std::string> assembler_funcs{"mov", "syscall"};
        for (const std::string& str : assembler_funcs) {
            tc_.add_func(prgtk, str, type_void, nullptr);
        }
        tc_.add_type(prgtk, type_i64);
        tc_.add_type(prgtk, type_i32);
        tc_.add_type(prgtk, type_i16);
        tc_.add_type(prgtk, type_i8);
        tc_.add_type(prgtk, type_bool);
        tc_.add_type(prgtk, type_void);

        tc_.set_type_void(type_void);
        tc_.set_type_bool(type_bool);
        tc_.set_type_default(type_i64);

        tokenizer tkz{source};
        while (true) {
            const token tk{tkz.next_token()};
            if (tk.is_empty()) {
                if (tkz.is_eos()) {
                    break;
                }
                throw compiler_exception(
                    tk, "unexpected '" + std::string{tkz.next_char()} + "'");
            }
            if (tk.is_name("field")) {
                statements_.emplace_back(
                    std::make_unique<stmt_def_field>(tc_, tk, tkz));
            } else if (tk.is_name("func")) {
                statements_.emplace_back(
                    std::make_unique<stmt_def_func>(tc_, tk, tkz));
            } else if (tk.is_name("type")) {
                statements_.emplace_back(
                    std::make_unique<stmt_def_type>(tc_, tk, tkz));
            } else if (tk.name().starts_with("#")) {
                statements_.emplace_back(
                    std::make_unique<stmt_comment>(tc_, tk, tkz));
            } else if (tk.is_name("")) {
                //? should this be able to happen?
                // throw panic_exception("program:1");
                statements_.emplace_back(
                    std::make_unique<statement>(tk, unary_ops{}));
            } else {
                throw compiler_exception(tk, "unexpected keyword '" +
                                                 tk.name() + "'");
            }
        }
    }

    program() = delete;
    program(const program&) = delete;
    program(program&&) = delete;
    auto operator=(const program&) -> program& = delete;
    auto operator=(program&&) -> program& = delete;

    ~program() = default;

    auto source_to(std::ostream& os) const -> void {
        for (const auto& st : statements_) {
            st->source_to(os);
        }
    }

    auto compile(toc& tc, std::ostream& os, size_t indent,
                 [[maybe_unused]] const std::string& dst = "") const -> void {
        os << "; generated by baz\n\n";
        os << "true equ 1\nfalse equ 0\n";

        os << "\nsection .data\nalign 4\n";
        for (const auto& st : statements_) {
            if (st->is_in_data_section()) {
                st->compile(tc, os, indent);
            }
        }

        os << "\nsection .bss\nstk resd 1024\nstk.end:\n";
        os << "\nsection .text\nbits 64\nglobal _start\n_start:\nmov "
              "rsp,stk.end\n";
        os << ";----------------------------------------------------\n";
        for (const auto& st : statements_) {
            if (not st->is_in_data_section()) {
                st->compile(tc, os, indent);
            }
        }

        // get the main function and compile
        const stmt_def_func& func_main{tc.get_func_or_throw(prg.tok(), "main")};
        tc.enter_func("main");
        func_main.code().compile(tc, os, indent);
        tc.exit_func("main");
        os << ";----------------------------------------------------\n";
        os << "; system call: exit 0\n";
        os << "mov rax, 60\n";
        os << "mov rdi, 0\n";
        os << "syscall\n";
    }

    auto build(std::ostream& os) -> void {
        compile(tc_, os, 0);
        tc_.finish(os);
    }
};
