#pragma once
// reviewed: 2025-09-28

#include "compiler_exception.hpp"
#include "statement.hpp"
#include "stmt_def_field.hpp"
#include "stmt_def_func.hpp"
#include "stmt_def_type.hpp"
#include "toc.hpp"
#include "tokenizer.hpp"
#include "unary_ops.hpp"
#include <string_view>

class program final {
    // built-in types
    type type_void{"void", 0, true};
    type type_i64{"i64", 8, true};
    type type_i32{"i32", 4, true};
    type type_i16{"i16", 2, true};
    type type_i8{"i8", 1, true};
    type type_bool{"bool", 1, true};

    std::vector<std::unique_ptr<statement>> statements_;
    toc tc_;    // table of contents
    token ws1_; // whitespace

  public:
    explicit program(const std::string& source) : tc_{source} {
        // create a placeholder token to use with `toc` functions
        const token prgtk{};

        // add built-in assembler calls
        tc_.add_func(prgtk, "mov", type_void, nullptr);
        tc_.add_func(prgtk, "syscall", type_void, nullptr);
        tc_.add_func(prgtk, "address_of", type_i64, nullptr);
        tc_.add_func(prgtk, "array_size_of", type_i64, nullptr);

        // add built-in types
        tc_.add_type(prgtk, type_i64);
        tc_.add_type(prgtk, type_i32);
        tc_.add_type(prgtk, type_i16);
        tc_.add_type(prgtk, type_i8);
        tc_.add_type(prgtk, type_bool);
        tc_.add_type(prgtk, type_void);

        // set defaults
        tc_.set_type_void(type_void);
        tc_.set_type_bool(type_bool);
        tc_.set_type_default(type_i64);

        tokenizer tz{source};
        while (true) {
            const token tk{tz.next_token()};
            if (tk.is_empty()) {
                if (not tz.is_eos()) {
                    throw compiler_exception{tk, "unexpected empty token"};
                }
                break;
            }
            if (tk.is_text("field")) {
                statements_.emplace_back(
                    std::make_unique<stmt_def_field>(tc_, tk, tz));
            } else if (tk.is_text("func")) {
                statements_.emplace_back(
                    std::make_unique<stmt_def_func>(tc_, tk, tz));
            } else if (tk.is_text("type")) {
                statements_.emplace_back(
                    std::make_unique<stmt_def_type>(tc_, tk, tz));
            } else if (tk.text().starts_with("#")) {
                statements_.emplace_back(
                    std::make_unique<stmt_comment>(tc_, unary_ops{}, tk, tz));
            } else if (tk.is_text("")) {
                // empty space at the end of the file; necessary for source
                // reproduction to be identical
                ws1_ = tk;
            } else {
                throw compiler_exception{
                    tk, std::format("unexpected keyword '{}'", tk.text())};
            }
        }
    }

    program() = delete;
    program(const program&) = default;
    program(program&&) = default;
    auto operator=(const program&) -> program& = delete;
    auto operator=(program&&) -> program& = delete;

    ~program() = default;

    auto source_to(std::ostream& os) const -> void {
        for (const auto& st : statements_) {
            st->source_to(os);
        }
        ws1_.source_to(os);
    }

    auto compile(toc& tc, std::ostream& os, size_t indent) const -> void {
        const std::string_view stack_size{"0x10000"};
        std::println(os, "; generated by baz\n");
        std::println(os, "section .bss\nstk resd {}\nstk.end:\n", stack_size);
        std::println(os, "true equ 1\nfalse equ 0");
        std::println(os, "\nsection .data");
        for (const auto& st : statements_) {
            if (st->is_in_data_section()) {
                st->compile(tc, os, indent, "");
            }
        }
        std::println(os,
                     "\nsection .text\nbits 64\nglobal _start\n_start:\nmov "
                     "rsp,stk.end\n; program");
        for (const auto& st : statements_) {
            if (not st->is_in_data_section()) {
                st->compile(tc, os, indent, "");
            }
        }

        // get the main function and compile
        const stmt_def_func& func_main{tc.get_func_or_throw(token{}, "main")};
        std::println(os, "main:"); // note: not necessary
        tc.enter_func("main", {});
        func_main.code().compile(tc, os, indent, "");
        tc.exit_func("main");
        std::println(os, "    ; system call: exit 0");
        std::println(os, "    mov rax, 60");
        std::println(os, "    mov rdi, 0");
        std::println(os, "    syscall");
    }

    auto build(std::ostream& os) -> void {
        compile(tc_, os, 0);
        tc_.finish(os);
    }
};
